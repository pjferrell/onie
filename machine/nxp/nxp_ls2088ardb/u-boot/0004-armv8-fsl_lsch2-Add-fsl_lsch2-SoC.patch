From 2196ab37a81233c14d0657cd222e25d366e2fb38 Mon Sep 17 00:00:00 2001
From: Mingkai Hu <Mingkai.Hu@freescale.com>
Date: Mon, 26 Oct 2015 19:47:51 +0800
Subject: [PATCH 04/74] armv8/fsl_lsch2: Add fsl_lsch2 SoC

Freescale LayerScape with Chassis Generation 2 is a set of SoCs with
ARMv8 cores and 2rd generation of Chassis.

Signed-off-by: Li Yang <leoli@freescale.com>
Signed-off-by: Hou Zhiqiang <B48286@freescale.com>
Signed-off-by: Mingkai Hu <Mingkai.Hu@freescale.com>
Signed-off-by: Gong Qianyu <Qianyu.Gong@freescale.com>
Reviewed-by: York Sun <yorksun@freescale.com>
---
 arch/arm/cpu/armv8/fsl-layerscape/Makefile         |   5 +
 arch/arm/cpu/armv8/fsl-layerscape/README.lsch2     |  10 +
 arch/arm/cpu/armv8/fsl-layerscape/cpu.c            |  13 +
 .../cpu/armv8/fsl-layerscape/fsl_lsch2_serdes.c    | 117 +++++
 .../arm/cpu/armv8/fsl-layerscape/fsl_lsch2_speed.c | 137 +++++
 arch/arm/cpu/armv8/fsl-layerscape/soc.c            |  17 +
 arch/arm/include/asm/arch-fsl-layerscape/config.h  |  47 ++
 arch/arm/include/asm/arch-fsl-layerscape/cpu.h     |  64 +++
 .../include/asm/arch-fsl-layerscape/fsl_serdes.h   |  91 ++++
 .../include/asm/arch-fsl-layerscape/immap_lsch2.h  | 555 +++++++++++++++++++++
 .../include/asm/arch-fsl-layerscape/ns_access.h    | 158 ++++++
 arch/arm/include/asm/arch-fsl-layerscape/soc.h     |   6 +
 arch/arm/include/asm/armv8/mmu.h                   |   1 +
 include/common.h                                   |   3 +
 14 files changed, 1224 insertions(+)
 create mode 100644 arch/arm/cpu/armv8/fsl-layerscape/README.lsch2
 create mode 100644 arch/arm/cpu/armv8/fsl-layerscape/fsl_lsch2_serdes.c
 create mode 100644 arch/arm/cpu/armv8/fsl-layerscape/fsl_lsch2_speed.c
 create mode 100644 arch/arm/include/asm/arch-fsl-layerscape/immap_lsch2.h
 create mode 100644 arch/arm/include/asm/arch-fsl-layerscape/ns_access.h

diff --git a/arch/arm/cpu/armv8/fsl-layerscape/Makefile b/arch/arm/cpu/armv8/fsl-layerscape/Makefile
index ccb3aa5..4754e59 100644
--- a/arch/arm/cpu/armv8/fsl-layerscape/Makefile
+++ b/arch/arm/cpu/armv8/fsl-layerscape/Makefile
@@ -14,6 +14,11 @@ obj-$(CONFIG_SPL) += spl.o
 ifneq ($(CONFIG_FSL_LSCH3),)
 obj-y += fsl_lsch3_speed.o
 obj-$(CONFIG_SYS_HAS_SERDES) += fsl_lsch3_serdes.o
+else
+ifneq ($(CONFIG_FSL_LSCH2),)
+obj-y += fsl_lsch2_speed.o
+obj-$(CONFIG_SYS_HAS_SERDES) += fsl_lsch2_serdes.o
+endif
 endif
 
 ifneq ($(CONFIG_LS2085A),)
diff --git a/arch/arm/cpu/armv8/fsl-layerscape/README.lsch2 b/arch/arm/cpu/armv8/fsl-layerscape/README.lsch2
new file mode 100644
index 0000000..a6ef830
--- /dev/null
+++ b/arch/arm/cpu/armv8/fsl-layerscape/README.lsch2
@@ -0,0 +1,10 @@
+#
+# Copyright 2015 Freescale Semiconductor
+#
+# SPDX-License-Identifier:      GPL-2.0+
+#
+
+Freescale LayerScape with Chassis Generation 2
+
+This architecture supports Freescale ARMv8 SoCs with Chassis generation 2,
+for example LS1043A.
diff --git a/arch/arm/cpu/armv8/fsl-layerscape/cpu.c b/arch/arm/cpu/armv8/fsl-layerscape/cpu.c
index be7442d..fe9d982 100644
--- a/arch/arm/cpu/armv8/fsl-layerscape/cpu.c
+++ b/arch/arm/cpu/armv8/fsl-layerscape/cpu.c
@@ -180,6 +180,8 @@ static inline void early_mmu_setup(void)
 	set_pgtable_table(level1_table0,
 			  CONFIG_SYS_FLASH_BASE >> SECTION_SHIFT_L1,
 			  level2_table1);
+#elif defined(CONFIG_FSL_LSCH2)
+	set_pgtable_table(level1_table0, 1, level2_table1);
 #endif
 	/* Find the table and fill in the block entries */
 	for (i = 0; i < ARRAY_SIZE(early_mmu_table); i++) {
@@ -215,6 +217,9 @@ static inline void early_mmu_setup(void)
  *
  * For LSCH3:
  * Level 2 table 1 contains 512 entries for each 2MB from 32GB to 33GB.
+ * For LSCH2:
+ * Level 2 table 1 contains 512 entries for each 2MB from 1GB to 2GB.
+ * Level 2 table 2 contains 512 entries for each 2MB from 20GB to 21GB.
  */
 static inline void final_mmu_setup(void)
 {
@@ -225,6 +230,9 @@ static inline void final_mmu_setup(void)
 	u64 *level2_table0 = (u64 *)(gd->arch.tlb_addr + 0x3000);
 #ifdef CONFIG_FSL_LSCH3
 	u64 *level2_table1 = (u64 *)(gd->arch.tlb_addr + 0x4000);
+#elif defined(CONFIG_FSL_LSCH2)
+	u64 *level2_table1 = (u64 *)(gd->arch.tlb_addr + 0x4000);
+	u64 *level2_table2 = (u64 *)(gd->arch.tlb_addr + 0x5000);
 #endif
 	struct table_info table = {level0_table, 0, BLOCK_SIZE_L0};
 
@@ -239,6 +247,11 @@ static inline void final_mmu_setup(void)
 	set_pgtable_table(level1_table0,
 			  CONFIG_SYS_FSL_QBMAN_BASE >> SECTION_SHIFT_L1,
 			  level2_table1);
+#elif defined(CONFIG_FSL_LSCH2)
+	set_pgtable_table(level1_table0, 1, level2_table1);
+	set_pgtable_table(level1_table0,
+			  CONFIG_SYS_FSL_QBMAN_BASE >> SECTION_SHIFT_L1,
+			  level2_table2);
 #endif
 
 	/* Find the table and fill in the block entries */
diff --git a/arch/arm/cpu/armv8/fsl-layerscape/fsl_lsch2_serdes.c b/arch/arm/cpu/armv8/fsl-layerscape/fsl_lsch2_serdes.c
new file mode 100644
index 0000000..f7178d1
--- /dev/null
+++ b/arch/arm/cpu/armv8/fsl-layerscape/fsl_lsch2_serdes.c
@@ -0,0 +1,117 @@
+/*
+ * Copyright 2015 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <asm/io.h>
+#include <asm/errno.h>
+#include <asm/arch/fsl_serdes.h>
+#include <asm/arch/soc.h>
+
+#ifdef CONFIG_SYS_FSL_SRDS_1
+static u8 serdes1_prtcl_map[SERDES_PRCTL_COUNT];
+#endif
+
+int is_serdes_configured(enum srds_prtcl device)
+{
+	int ret = 0;
+
+#ifdef CONFIG_SYS_FSL_SRDS_1
+	ret |= serdes1_prtcl_map[device];
+#endif
+
+	return !!ret;
+}
+
+int serdes_get_first_lane(u32 sd, enum srds_prtcl device)
+{
+	struct ccsr_gur __iomem *gur = (void *)(CONFIG_SYS_FSL_GUTS_ADDR);
+	u32 cfg = gur_in32(&gur->rcwsr[4]);
+	int i;
+
+	switch (sd) {
+#ifdef CONFIG_SYS_FSL_SRDS_1
+	case FSL_SRDS_1:
+		cfg &= FSL_CHASSIS2_RCWSR4_SRDS1_PRTCL_MASK;
+		cfg >>= FSL_CHASSIS2_RCWSR4_SRDS1_PRTCL_SHIFT;
+		break;
+#endif
+	default:
+		printf("invalid SerDes%d\n", sd);
+		break;
+	}
+
+	/* Is serdes enabled at all? */
+	if (unlikely(cfg == 0))
+		return -ENODEV;
+
+	for (i = 0; i < SRDS_MAX_LANES; i++) {
+		if (serdes_get_prtcl(sd, cfg, i) == device)
+			return i;
+	}
+
+	return -ENODEV;
+}
+
+int get_serdes_protocol(void)
+{
+	struct ccsr_gur __iomem *gur = (void *)(CONFIG_SYS_FSL_GUTS_ADDR);
+	u32 cfg = gur_in32(&gur->rcwsr[4]) &
+			  FSL_CHASSIS2_RCWSR4_SRDS1_PRTCL_MASK;
+	cfg >>= FSL_CHASSIS2_RCWSR4_SRDS1_PRTCL_SHIFT;
+
+	return cfg;
+}
+
+const char *serdes_clock_to_string(u32 clock)
+{
+	switch (clock) {
+	case SRDS_PLLCR0_RFCK_SEL_100:
+		return "100";
+	case SRDS_PLLCR0_RFCK_SEL_125:
+		return "125";
+	case SRDS_PLLCR0_RFCK_SEL_156_25:
+		return "156.25";
+	default:
+		return "100";
+	}
+}
+
+void serdes_init(u32 sd, u32 sd_addr, u32 sd_prctl_mask, u32 sd_prctl_shift,
+		 u8 serdes_prtcl_map[SERDES_PRCTL_COUNT])
+{
+	struct ccsr_gur __iomem *gur = (void *)(CONFIG_SYS_FSL_GUTS_ADDR);
+	u32 cfg;
+	int lane;
+
+	memset(serdes_prtcl_map, 0, sizeof(serdes_prtcl_map));
+
+	cfg = gur_in32(&gur->rcwsr[4]) & sd_prctl_mask;
+	cfg >>= sd_prctl_shift;
+	printf("Using SERDES%d Protocol: %d (0x%x)\n", sd + 1, cfg, cfg);
+
+	if (!is_serdes_prtcl_valid(sd, cfg))
+		printf("SERDES%d[PRTCL] = 0x%x is not valid\n", sd + 1, cfg);
+
+	for (lane = 0; lane < SRDS_MAX_LANES; lane++) {
+		enum srds_prtcl lane_prtcl = serdes_get_prtcl(sd, cfg, lane);
+
+		if (unlikely(lane_prtcl >= SERDES_PRCTL_COUNT))
+			debug("Unknown SerDes lane protocol %d\n", lane_prtcl);
+		else
+			serdes_prtcl_map[lane_prtcl] = 1;
+	}
+}
+
+void fsl_serdes_init(void)
+{
+#ifdef CONFIG_SYS_FSL_SRDS_1
+	serdes_init(FSL_SRDS_1,
+		    CONFIG_SYS_FSL_SERDES_ADDR,
+		    FSL_CHASSIS2_RCWSR4_SRDS1_PRTCL_MASK,
+		    FSL_CHASSIS2_RCWSR4_SRDS1_PRTCL_SHIFT,
+		    serdes1_prtcl_map);
+#endif
+}
diff --git a/arch/arm/cpu/armv8/fsl-layerscape/fsl_lsch2_speed.c b/arch/arm/cpu/armv8/fsl-layerscape/fsl_lsch2_speed.c
new file mode 100644
index 0000000..ea3723f
--- /dev/null
+++ b/arch/arm/cpu/armv8/fsl-layerscape/fsl_lsch2_speed.c
@@ -0,0 +1,137 @@
+/*
+ * Copyright 2015 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <linux/compiler.h>
+#include <asm/io.h>
+#include <asm/processor.h>
+#include <asm/arch/clock.h>
+#include <asm/arch/soc.h>
+#include <fsl_ifc.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#ifndef CONFIG_SYS_FSL_NUM_CC_PLLS
+#define CONFIG_SYS_FSL_NUM_CC_PLLS      2
+#endif
+
+void get_sys_info(struct sys_info *sys_info)
+{
+	struct ccsr_gur __iomem *gur = (void *)(CONFIG_SYS_FSL_GUTS_ADDR);
+#ifdef CONFIG_FSL_IFC
+	struct fsl_ifc ifc_regs = {(void *)CONFIG_SYS_IFC_ADDR, (void *)NULL};
+	u32 ccr;
+#endif
+	struct ccsr_clk *clk = (void *)(CONFIG_SYS_FSL_CLK_ADDR);
+	unsigned int cpu;
+	const u8 core_cplx_pll[8] = {
+		[0] = 0,	/* CC1 PPL / 1 */
+		[1] = 0,	/* CC1 PPL / 2 */
+		[4] = 1,	/* CC2 PPL / 1 */
+		[5] = 1,	/* CC2 PPL / 2 */
+	};
+
+	const u8 core_cplx_pll_div[8] = {
+		[0] = 1,	/* CC1 PPL / 1 */
+		[1] = 2,	/* CC1 PPL / 2 */
+		[4] = 1,	/* CC2 PPL / 1 */
+		[5] = 2,	/* CC2 PPL / 2 */
+	};
+
+	uint i;
+	uint freq_c_pll[CONFIG_SYS_FSL_NUM_CC_PLLS];
+	uint ratio[CONFIG_SYS_FSL_NUM_CC_PLLS];
+	unsigned long sysclk = CONFIG_SYS_CLK_FREQ;
+
+	sys_info->freq_systembus = sysclk;
+#ifdef CONFIG_DDR_CLK_FREQ
+	sys_info->freq_ddrbus = CONFIG_DDR_CLK_FREQ;
+#else
+	sys_info->freq_ddrbus = sysclk;
+#endif
+
+	sys_info->freq_systembus *= (gur_in32(&gur->rcwsr[0]) >>
+			FSL_CHASSIS2_RCWSR0_SYS_PLL_RAT_SHIFT) &
+			FSL_CHASSIS2_RCWSR0_SYS_PLL_RAT_MASK;
+	sys_info->freq_ddrbus *= (gur_in32(&gur->rcwsr[0]) >>
+			FSL_CHASSIS2_RCWSR0_MEM_PLL_RAT_SHIFT) &
+			FSL_CHASSIS2_RCWSR0_MEM_PLL_RAT_MASK;
+
+	for (i = 0; i < CONFIG_SYS_FSL_NUM_CC_PLLS; i++) {
+		ratio[i] = (in_be32(&clk->pllcgsr[i].pllcngsr) >> 1) & 0xff;
+		if (ratio[i] > 4)
+			freq_c_pll[i] = sysclk * ratio[i];
+		else
+			freq_c_pll[i] = sys_info->freq_systembus * ratio[i];
+	}
+
+	for (cpu = 0; cpu < CONFIG_MAX_CPUS; cpu++) {
+		u32 c_pll_sel = (in_be32(&clk->clkcsr[cpu].clkcncsr) >> 27)
+				& 0xf;
+		u32 cplx_pll = core_cplx_pll[c_pll_sel];
+
+		sys_info->freq_processor[cpu] =
+			freq_c_pll[cplx_pll] / core_cplx_pll_div[c_pll_sel];
+	}
+
+#define HWA_CGA_M1_CLK_SEL	0xe0000000
+#define HWA_CGA_M1_CLK_SHIFT	29
+
+#define HWA_CGA_M2_CLK_SEL	0x00000007
+#define HWA_CGA_M2_CLK_SHIFT	0
+
+#if defined(CONFIG_FSL_IFC)
+	ccr = ifc_in32(&ifc_regs.gregs->ifc_ccr);
+	ccr = ((ccr & IFC_CCR_CLK_DIV_MASK) >> IFC_CCR_CLK_DIV_SHIFT) + 1;
+
+	sys_info->freq_localbus = sys_info->freq_systembus / ccr;
+#endif
+}
+
+int get_clocks(void)
+{
+	struct sys_info sys_info;
+
+	get_sys_info(&sys_info);
+	gd->cpu_clk = sys_info.freq_processor[0];
+	gd->bus_clk = sys_info.freq_systembus;
+	gd->mem_clk = sys_info.freq_ddrbus;
+
+	if (gd->cpu_clk != 0)
+		return 0;
+	else
+		return 1;
+}
+
+ulong get_bus_freq(ulong dummy)
+{
+	return gd->bus_clk;
+}
+
+ulong get_ddr_freq(ulong dummy)
+{
+	return gd->mem_clk;
+}
+
+int get_serial_clock(void)
+{
+	return gd->bus_clk;
+}
+
+unsigned int mxc_get_clock(enum mxc_clock clk)
+{
+	switch (clk) {
+	case MXC_I2C_CLK:
+		return get_bus_freq(0);
+	case MXC_DSPI_CLK:
+		return get_bus_freq(0);
+	case MXC_UART_CLK:
+		return get_bus_freq(0);
+	default:
+		printf("Unsupported clock\n");
+	}
+	return 0;
+}
diff --git a/arch/arm/cpu/armv8/fsl-layerscape/soc.c b/arch/arm/cpu/armv8/fsl-layerscape/soc.c
index 73e48a7..637853d 100644
--- a/arch/arm/cpu/armv8/fsl-layerscape/soc.c
+++ b/arch/arm/cpu/armv8/fsl-layerscape/soc.c
@@ -76,6 +76,23 @@ void fsl_lsch3_early_init_f(void)
 	init_early_memctl_regs();	/* tighten IFC timing */
 	erratum_a009203();
 }
+
+#elif defined(CONFIG_LS1043A)
+void fsl_lsch2_early_init_f(void)
+{
+	struct ccsr_cci400 *cci = (struct ccsr_cci400 *)CONFIG_SYS_CCI400_ADDR;
+
+#ifdef CONFIG_FSL_IFC
+	init_early_memctl_regs();	/* tighten IFC timing */
+#endif
+
+	/*
+	 * Enable snoop requests and DVM message requests for
+	 * Slave insterface S4 (A53 core cluster)
+	 */
+	out_le32(&cci->slave[4].snoop_ctrl,
+		 CCI400_DVM_MESSAGE_REQ_EN | CCI400_SNOOP_REQ_EN);
+}
 #endif
 
 #ifdef CONFIG_BOARD_LATE_INIT
diff --git a/arch/arm/include/asm/arch-fsl-layerscape/config.h b/arch/arm/include/asm/arch-fsl-layerscape/config.h
index dd7203f..87bb937 100644
--- a/arch/arm/include/asm/arch-fsl-layerscape/config.h
+++ b/arch/arm/include/asm/arch-fsl-layerscape/config.h
@@ -89,6 +89,53 @@
 #define CONFIG_SYS_FSL_ERRATUM_A008514
 #define CONFIG_SYS_FSL_ERRATUM_A008585
 #define CONFIG_SYS_FSL_ERRATUM_A008751
+#elif defined(CONFIG_LS1043A)
+#define CONFIG_MAX_CPUS				4
+#define CONFIG_SYS_CACHELINE_SIZE		64
+#define CONFIG_SYS_FMAN_V3
+#define CONFIG_SYS_NUM_FMAN			1
+#define CONFIG_SYS_NUM_FM1_DTSEC		7
+#define CONFIG_SYS_NUM_FM1_10GEC		1
+#define CONFIG_SYS_FSL_IFC_BANK_COUNT		4
+#define CONFIG_NUM_DDR_CONTROLLERS		1
+#define CONFIG_SYS_CCSRBAR_DEFAULT		0x01000000
+#define CONFIG_SYS_FSL_SEC_COMPAT		5
+#define CONFIG_SYS_FSL_OCRAM_BASE		0x10000000 /* initial RAM */
+#define CONFIG_SYS_FSL_OCRAM_SIZE		0x200000 /* 2 MiB */
+#define CONFIG_SYS_FSL_DDR_BE
+#define CONFIG_SYS_LS1_DDR_BLOCK1_SIZE  ((phys_size_t)2 << 30)
+#define CONFIG_MAX_MEM_MAPPED           CONFIG_SYS_LS1_DDR_BLOCK1_SIZE
+
+#define CONFIG_SYS_FSL_CCSR_GUR_BE
+#define CONFIG_SYS_FSL_CCSR_SCFG_BE
+#define CONFIG_SYS_FSL_IFC_BE
+#define CONFIG_SYS_FSL_ESDHC_BE
+#define CONFIG_SYS_FSL_WDOG_BE
+#define CONFIG_SYS_FSL_DSPI_BE
+#define CONFIG_SYS_FSL_QSPI_BE
+
+#define QE_MURAM_SIZE		0x6000UL
+#define MAX_QE_RISC		1
+#define QE_NUM_OF_SNUM		28
+
+#define SRDS_MAX_LANES		4
+#define CONFIG_SYS_FSL_SRDS_1
+#define CONFIG_SYS_FSL_PCIE_COMPAT		"fsl,qoriq-pcie-v2.4"
+
+#define CONFIG_SYS_FSL_SFP_VER_3_2
+#define CONFIG_SYS_FSL_SNVS_LE
+#define CONFIG_SYS_FSL_SEC_LE
+#define CONFIG_SYS_FSL_SFP_BE
+#define CONFIG_SYS_FSL_SRK_LE
+#define CONFIG_KEY_REVOCATION
+
+/* SMMU Defintions */
+#define SMMU_BASE		0x09000000
+
+/* Generic Interrupt Controller Definitions */
+#define GICD_BASE		0x01401000
+#define GICC_BASE		0x01402000
+
 #else
 #error SoC not defined
 #endif
diff --git a/arch/arm/include/asm/arch-fsl-layerscape/cpu.h b/arch/arm/include/asm/arch-fsl-layerscape/cpu.h
index b7b8e5d..2903996 100644
--- a/arch/arm/include/asm/arch-fsl-layerscape/cpu.h
+++ b/arch/arm/include/asm/arch-fsl-layerscape/cpu.h
@@ -11,6 +11,7 @@ static struct cpu_type cpu_type_list[] = {
 	CPU_TYPE_ENTRY(LS2085, LS2085, 8),
 	CPU_TYPE_ENTRY(LS2080, LS2080, 8),
 	CPU_TYPE_ENTRY(LS2045, LS2045, 4),
+	CPU_TYPE_ENTRY(LS1043, LS1043, 4),
 };
 
 #ifndef CONFIG_SYS_DCACHE_OFF
@@ -73,6 +74,28 @@ static struct cpu_type cpu_type_list[] = {
 #define CONFIG_SYS_FSL_PEBUF_SIZE	0x400000000
 #define CONFIG_SYS_FSL_DRAM_BASE2	0x8080000000
 #define CONFIG_SYS_FSL_DRAM_SIZE2	0x7F80000000
+#elif defined(CONFIG_FSL_LSCH2)
+#define CONFIG_SYS_FSL_BOOTROM_BASE	0x0
+#define CONFIG_SYS_FSL_BOOTROM_SIZE	0x1000000
+#define CONFIG_SYS_FSL_CCSR_BASE	0x1000000
+#define CONFIG_SYS_FSL_CCSR_SIZE	0xf000000
+#define CONFIG_SYS_FSL_DCSR_BASE	0x20000000
+#define CONFIG_SYS_FSL_DCSR_SIZE	0x4000000
+#define CONFIG_SYS_FSL_QSPI_BASE	0x40000000
+#define CONFIG_SYS_FSL_QSPI_SIZE	0x20000000
+#define CONFIG_SYS_FSL_IFC_BASE		0x60000000
+#define CONFIG_SYS_FSL_IFC_SIZE		0x20000000
+#define CONFIG_SYS_FSL_DRAM_BASE1	0x80000000
+#define CONFIG_SYS_FSL_DRAM_SIZE1	0x80000000
+#define CONFIG_SYS_FSL_QBMAN_BASE	0x500000000
+#define CONFIG_SYS_FSL_QBMAN_SIZE	0x10000000
+#define CONFIG_SYS_FSL_DRAM_BASE2	0x880000000
+#define CONFIG_SYS_FSL_DRAM_SIZE2	0x780000000	/* 30GB */
+#define CONFIG_SYS_PCIE1_PHYS_SIZE	0x800000000
+#define CONFIG_SYS_PCIE2_PHYS_SIZE	0x800000000
+#define CONFIG_SYS_PCIE3_PHYS_SIZE	0x800000000
+#define CONFIG_SYS_FSL_DRAM_BASE3	0x8800000000
+#define CONFIG_SYS_FSL_DRAM_SIZE3	0x7800000000	/* 480GB */
 #endif
 
 struct sys_mmu_table {
@@ -110,6 +133,19 @@ static const struct sys_mmu_table early_mmu_table[] = {
 	  CONFIG_SYS_FSL_DCSR_SIZE, MT_DEVICE_NGNRNE, PMD_SECT_NON_SHARE },
 	{ CONFIG_SYS_FSL_DRAM_BASE2, CONFIG_SYS_FSL_DRAM_BASE2,
 	  CONFIG_SYS_FSL_DRAM_SIZE2, MT_NORMAL, PMD_SECT_OUTER_SHARE },
+#elif defined(CONFIG_FSL_LSCH2)
+	{ CONFIG_SYS_FSL_CCSR_BASE, CONFIG_SYS_FSL_CCSR_BASE,
+	  CONFIG_SYS_FSL_CCSR_SIZE, MT_DEVICE_NGNRNE, PMD_SECT_NON_SHARE },
+	{ CONFIG_SYS_FSL_OCRAM_BASE, CONFIG_SYS_FSL_OCRAM_BASE,
+	  CONFIG_SYS_FSL_OCRAM_SIZE, MT_NORMAL, PMD_SECT_NON_SHARE },
+	{ CONFIG_SYS_FSL_DCSR_BASE, CONFIG_SYS_FSL_DCSR_BASE,
+	  CONFIG_SYS_FSL_DCSR_SIZE, MT_DEVICE_NGNRNE, PMD_SECT_NON_SHARE },
+	{ CONFIG_SYS_FSL_IFC_BASE, CONFIG_SYS_FSL_IFC_BASE,
+	  CONFIG_SYS_FSL_IFC_SIZE, MT_DEVICE_NGNRNE, PMD_SECT_NON_SHARE },
+	{ CONFIG_SYS_FSL_DRAM_BASE1, CONFIG_SYS_FSL_DRAM_BASE1,
+	  CONFIG_SYS_FSL_DRAM_SIZE1, MT_NORMAL, PMD_SECT_OUTER_SHARE },
+	{ CONFIG_SYS_FSL_DRAM_BASE2, CONFIG_SYS_FSL_DRAM_BASE2,
+	  CONFIG_SYS_FSL_DRAM_SIZE2, MT_NORMAL, PMD_SECT_OUTER_SHARE },
 #endif
 };
 
@@ -156,6 +192,34 @@ static const struct sys_mmu_table final_mmu_table[] = {
 	  CONFIG_SYS_FSL_PEBUF_SIZE, MT_DEVICE_NGNRNE, PMD_SECT_NON_SHARE },
 	{ CONFIG_SYS_FSL_DRAM_BASE2, CONFIG_SYS_FSL_DRAM_BASE2,
 	  CONFIG_SYS_FSL_DRAM_SIZE2, MT_NORMAL, PMD_SECT_OUTER_SHARE },
+#elif defined(CONFIG_FSL_LSCH2)
+	{ CONFIG_SYS_FSL_BOOTROM_BASE, CONFIG_SYS_FSL_BOOTROM_BASE,
+	  CONFIG_SYS_FSL_BOOTROM_SIZE, MT_DEVICE_NGNRNE, PMD_SECT_NON_SHARE },
+	{ CONFIG_SYS_FSL_CCSR_BASE, CONFIG_SYS_FSL_CCSR_BASE,
+	  CONFIG_SYS_FSL_CCSR_SIZE, MT_DEVICE_NGNRNE, PMD_SECT_NON_SHARE },
+	{ CONFIG_SYS_FSL_OCRAM_BASE, CONFIG_SYS_FSL_OCRAM_BASE,
+	  CONFIG_SYS_FSL_OCRAM_SIZE, MT_NORMAL, PMD_SECT_NON_SHARE },
+	{ CONFIG_SYS_FSL_DCSR_BASE, CONFIG_SYS_FSL_DCSR_BASE,
+	  CONFIG_SYS_FSL_DCSR_SIZE, MT_DEVICE_NGNRNE, PMD_SECT_NON_SHARE },
+	{ CONFIG_SYS_FSL_QSPI_BASE, CONFIG_SYS_FSL_QSPI_BASE,
+	  CONFIG_SYS_FSL_QSPI_SIZE, MT_DEVICE_NGNRNE, PMD_SECT_NON_SHARE },
+	{ CONFIG_SYS_FSL_IFC_BASE, CONFIG_SYS_FSL_IFC_BASE,
+	  CONFIG_SYS_FSL_IFC_SIZE, MT_DEVICE_NGNRNE, PMD_SECT_NON_SHARE },
+	{ CONFIG_SYS_FSL_DRAM_BASE1, CONFIG_SYS_FSL_DRAM_BASE1,
+	  CONFIG_SYS_FSL_DRAM_SIZE1, MT_NORMAL,
+	  PMD_SECT_OUTER_SHARE | PMD_SECT_NS },
+	{ CONFIG_SYS_FSL_QBMAN_BASE, CONFIG_SYS_FSL_QBMAN_BASE,
+	  CONFIG_SYS_FSL_QBMAN_SIZE, MT_DEVICE_NGNRNE, PMD_SECT_NON_SHARE },
+	{ CONFIG_SYS_FSL_DRAM_BASE2, CONFIG_SYS_FSL_DRAM_BASE2,
+	  CONFIG_SYS_FSL_DRAM_SIZE2, MT_NORMAL, PMD_SECT_OUTER_SHARE },
+	{ CONFIG_SYS_PCIE1_PHYS_ADDR, CONFIG_SYS_PCIE1_PHYS_ADDR,
+	  CONFIG_SYS_PCIE1_PHYS_SIZE, MT_DEVICE_NGNRNE, PMD_SECT_NON_SHARE },
+	{ CONFIG_SYS_PCIE2_PHYS_ADDR, CONFIG_SYS_PCIE2_PHYS_ADDR,
+	  CONFIG_SYS_PCIE2_PHYS_SIZE, MT_DEVICE_NGNRNE, PMD_SECT_NON_SHARE },
+	{ CONFIG_SYS_PCIE3_PHYS_ADDR, CONFIG_SYS_PCIE3_PHYS_ADDR,
+	  CONFIG_SYS_PCIE3_PHYS_SIZE, MT_DEVICE_NGNRNE, PMD_SECT_NON_SHARE },
+	{ CONFIG_SYS_FSL_DRAM_BASE3, CONFIG_SYS_FSL_DRAM_BASE3,
+	  CONFIG_SYS_FSL_DRAM_SIZE3, MT_NORMAL, PMD_SECT_OUTER_SHARE },
 #endif
 };
 #endif
diff --git a/arch/arm/include/asm/arch-fsl-layerscape/fsl_serdes.h b/arch/arm/include/asm/arch-fsl-layerscape/fsl_serdes.h
index 730c2b2..e1043b5 100644
--- a/arch/arm/include/asm/arch-fsl-layerscape/fsl_serdes.h
+++ b/arch/arm/include/asm/arch-fsl-layerscape/fsl_serdes.h
@@ -55,6 +55,92 @@ enum srds {
 	FSL_SRDS_1  = 0,
 	FSL_SRDS_2  = 1,
 };
+#elif defined(CONFIG_LS1043A)
+enum srds_prtcl {
+	NONE = 0,
+	PCIE1,
+	PCIE2,
+	PCIE3,
+	PCIE4,
+	SATA1,
+	SATA2,
+	SRIO1,
+	SRIO2,
+	SGMII_FM1_DTSEC1,
+	SGMII_FM1_DTSEC2,
+	SGMII_FM1_DTSEC3,
+	SGMII_FM1_DTSEC4,
+	SGMII_FM1_DTSEC5,
+	SGMII_FM1_DTSEC6,
+	SGMII_FM1_DTSEC9,
+	SGMII_FM1_DTSEC10,
+	SGMII_FM2_DTSEC1,
+	SGMII_FM2_DTSEC2,
+	SGMII_FM2_DTSEC3,
+	SGMII_FM2_DTSEC4,
+	SGMII_FM2_DTSEC5,
+	SGMII_FM2_DTSEC6,
+	SGMII_FM2_DTSEC9,
+	SGMII_FM2_DTSEC10,
+	SGMII_TSEC1,
+	SGMII_TSEC2,
+	SGMII_TSEC3,
+	SGMII_TSEC4,
+	XAUI_FM1,
+	XAUI_FM2,
+	AURORA,
+	CPRI1,
+	CPRI2,
+	CPRI3,
+	CPRI4,
+	CPRI5,
+	CPRI6,
+	CPRI7,
+	CPRI8,
+	XAUI_FM1_MAC9,
+	XAUI_FM1_MAC10,
+	XAUI_FM2_MAC9,
+	XAUI_FM2_MAC10,
+	HIGIG_FM1_MAC9,
+	HIGIG_FM1_MAC10,
+	HIGIG_FM2_MAC9,
+	HIGIG_FM2_MAC10,
+	QSGMII_FM1_A,		/* A indicates MACs 1,2,5,6 */
+	QSGMII_FM1_B,		/* B indicates MACs 5,6,9,10 */
+	QSGMII_FM2_A,
+	QSGMII_FM2_B,
+	XFI_FM1_MAC1,
+	XFI_FM1_MAC2,
+	XFI_FM1_MAC9,
+	XFI_FM1_MAC10,
+	XFI_FM2_MAC9,
+	XFI_FM2_MAC10,
+	INTERLAKEN,
+	QSGMII_SW1_A,		/* Indicates ports on L2 Switch */
+	QSGMII_SW1_B,
+	SGMII_2500_FM1_DTSEC1,
+	SGMII_2500_FM1_DTSEC2,
+	SGMII_2500_FM1_DTSEC3,
+	SGMII_2500_FM1_DTSEC4,
+	SGMII_2500_FM1_DTSEC5,
+	SGMII_2500_FM1_DTSEC6,
+	SGMII_2500_FM1_DTSEC9,
+	SGMII_2500_FM1_DTSEC10,
+	SGMII_2500_FM2_DTSEC1,
+	SGMII_2500_FM2_DTSEC2,
+	SGMII_2500_FM2_DTSEC3,
+	SGMII_2500_FM2_DTSEC4,
+	SGMII_2500_FM2_DTSEC5,
+	SGMII_2500_FM2_DTSEC6,
+	SGMII_2500_FM2_DTSEC9,
+	SGMII_2500_FM2_DTSEC10,
+	SERDES_PRCTL_COUNT
+};
+
+enum srds {
+	FSL_SRDS_1  = 0,
+};
+
 #endif
 
 int is_serdes_configured(enum srds_prtcl device);
@@ -63,4 +149,9 @@ int serdes_get_first_lane(u32 sd, enum srds_prtcl device);
 enum srds_prtcl serdes_get_prtcl(int serdes, int cfg, int lane);
 int is_serdes_prtcl_valid(int serdes, u32 prtcl);
 
+#ifdef	CONFIG_LS1043A
+const char *serdes_clock_to_string(u32 clock);
+int get_serdes_protocol(void);
+#endif
+
 #endif /* __FSL_SERDES_H__ */
diff --git a/arch/arm/include/asm/arch-fsl-layerscape/immap_lsch2.h b/arch/arm/include/asm/arch-fsl-layerscape/immap_lsch2.h
new file mode 100644
index 0000000..d941437
--- /dev/null
+++ b/arch/arm/include/asm/arch-fsl-layerscape/immap_lsch2.h
@@ -0,0 +1,555 @@
+/*
+ * Copyright 2013-2015 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __ARCH_FSL_LSCH2_IMMAP_H__
+#define __ARCH_FSL_LSCH2_IMMAP_H__
+
+#include <fsl_immap.h>
+
+#define CONFIG_SYS_IMMR				0x01000000
+#define CONFIG_SYS_DCSRBAR			0x20000000
+#define CONFIG_SYS_DCSR_DCFG_ADDR	(CONFIG_SYS_DCSRBAR + 0x00220000)
+
+#define CONFIG_SYS_FSL_DDR_ADDR			(CONFIG_SYS_IMMR + 0x00080000)
+#define CONFIG_SYS_CCI400_ADDR			(CONFIG_SYS_IMMR + 0x00180000)
+#define CONFIG_SYS_GIC400_ADDR			(CONFIG_SYS_IMMR + 0x00400000)
+#define CONFIG_SYS_IFC_ADDR			(CONFIG_SYS_IMMR + 0x00530000)
+#define CONFIG_SYS_FSL_ESDHC_ADDR		(CONFIG_SYS_IMMR + 0x00560000)
+#define CONFIG_SYS_FSL_CSU_ADDR			(CONFIG_SYS_IMMR + 0x00510000)
+#define CONFIG_SYS_FSL_GUTS_ADDR		(CONFIG_SYS_IMMR + 0x00ee0000)
+#define CONFIG_SYS_FSL_RST_ADDR			(CONFIG_SYS_IMMR + 0x00ee00b0)
+#define CONFIG_SYS_FSL_SCFG_ADDR		(CONFIG_SYS_IMMR + 0x00570000)
+#define CONFIG_SYS_FSL_FMAN_ADDR		(CONFIG_SYS_IMMR + 0x00a00000)
+#define CONFIG_SYS_FSL_SERDES_ADDR		(CONFIG_SYS_IMMR + 0x00ea0000)
+#define CONFIG_SYS_FSL_DCFG_ADDR		(CONFIG_SYS_IMMR + 0x00ee0000)
+#define CONFIG_SYS_FSL_CLK_ADDR			(CONFIG_SYS_IMMR + 0x00ee1000)
+#define CONFIG_SYS_NS16550_COM1			(CONFIG_SYS_IMMR + 0x011c0500)
+#define CONFIG_SYS_NS16550_COM2			(CONFIG_SYS_IMMR + 0x011c0600)
+#define CONFIG_SYS_NS16550_COM3			(CONFIG_SYS_IMMR + 0x011d0500)
+#define CONFIG_SYS_NS16550_COM4			(CONFIG_SYS_IMMR + 0x011d0600)
+#define CONFIG_SYS_FSL_XHCI_USB1_ADDR		(CONFIG_SYS_IMMR + 0x01f00000)
+#define CONFIG_SYS_FSL_XHCI_USB2_ADDR		(CONFIG_SYS_IMMR + 0x02000000)
+#define CONFIG_SYS_FSL_XHCI_USB3_ADDR		(CONFIG_SYS_IMMR + 0x02100000)
+#define CONFIG_SYS_PCIE1_ADDR			(CONFIG_SYS_IMMR + 0x2400000)
+#define CONFIG_SYS_PCIE2_ADDR			(CONFIG_SYS_IMMR + 0x2500000)
+#define CONFIG_SYS_PCIE3_ADDR			(CONFIG_SYS_IMMR + 0x2600000)
+#define CONFIG_SYS_FSL_SEC_ADDR			(CONFIG_SYS_IMMR + 0x700000)
+#define CONFIG_SYS_FSL_JR0_ADDR			(CONFIG_SYS_IMMR + 0x710000)
+#define CONFIG_SYS_SNVS_ADDR			(CONFIG_SYS_IMMR + 0xe90000)
+#define CONFIG_SYS_SFP_ADDR			(CONFIG_SYS_IMMR + 0xe80200)
+
+#define CONFIG_SYS_FSL_TIMER_ADDR		0x02b00000
+
+#define I2C1_BASE_ADDR				(CONFIG_SYS_IMMR + 0x01180000)
+#define I2C2_BASE_ADDR				(CONFIG_SYS_IMMR + 0x01190000)
+#define I2C3_BASE_ADDR				(CONFIG_SYS_IMMR + 0x011a0000)
+#define I2C4_BASE_ADDR				(CONFIG_SYS_IMMR + 0x011b0000)
+
+#define WDOG1_BASE_ADDR				(CONFIG_SYS_IMMR + 0x01ad0000)
+
+#define QSPI0_BASE_ADDR				(CONFIG_SYS_IMMR + 0x00550000)
+#define DSPI1_BASE_ADDR				(CONFIG_SYS_IMMR + 0x01100000)
+
+#define LPUART_BASE				(CONFIG_SYS_IMMR + 0x01950000)
+
+#define AHCI_BASE_ADDR				(CONFIG_SYS_IMMR + 0x02200000)
+
+#define CONFIG_SYS_PCIE1_PHYS_ADDR		0x4000000000ULL
+#define CONFIG_SYS_PCIE2_PHYS_ADDR		0x4800000000ULL
+#define CONFIG_SYS_PCIE3_PHYS_ADDR		0x5000000000ULL
+
+/* TZ Address Space Controller Definitions */
+#define TZASC1_BASE			0x01100000	/* as per CCSR map. */
+#define TZASC2_BASE			0x01110000	/* as per CCSR map. */
+#define TZASC3_BASE			0x01120000	/* as per CCSR map. */
+#define TZASC4_BASE			0x01130000	/* as per CCSR map. */
+#define TZASC_BUILD_CONFIG_REG(x)	((TZASC1_BASE + (x * 0x10000)))
+#define TZASC_ACTION_REG(x)		((TZASC1_BASE + (x * 0x10000)) + 0x004)
+#define TZASC_GATE_KEEPER(x)		((TZASC1_BASE + (x * 0x10000)) + 0x008)
+#define TZASC_REGION_BASE_LOW_0(x)	((TZASC1_BASE + (x * 0x10000)) + 0x100)
+#define TZASC_REGION_BASE_HIGH_0(x)	((TZASC1_BASE + (x * 0x10000)) + 0x104)
+#define TZASC_REGION_TOP_LOW_0(x)	((TZASC1_BASE + (x * 0x10000)) + 0x108)
+#define TZASC_REGION_TOP_HIGH_0(x)	((TZASC1_BASE + (x * 0x10000)) + 0x10C)
+#define TZASC_REGION_ATTRIBUTES_0(x)	((TZASC1_BASE + (x * 0x10000)) + 0x110)
+#define TZASC_REGION_ID_ACCESS_0(x)	((TZASC1_BASE + (x * 0x10000)) + 0x114)
+
+#define TP_ITYP_AV              0x00000001      /* Initiator available */
+#define TP_ITYP_TYPE(x) (((x) & 0x6) >> 1)      /* Initiator Type */
+#define TP_ITYP_TYPE_ARM        0x0
+#define TP_ITYP_TYPE_PPC        0x1             /* PowerPC */
+#define TP_ITYP_TYPE_OTHER      0x2             /* StarCore DSP */
+#define TP_ITYP_TYPE_HA         0x3             /* HW Accelerator */
+#define TP_ITYP_THDS(x) (((x) & 0x18) >> 3)     /* # threads */
+#define TP_ITYP_VER(x)  (((x) & 0xe0) >> 5)     /* Initiator Version */
+#define TY_ITYP_VER_A7          0x1
+#define TY_ITYP_VER_A53         0x2
+#define TY_ITYP_VER_A57         0x3
+
+#define TP_CLUSTER_EOC		0xc0000000      /* end of clusters */
+#define TP_CLUSTER_INIT_MASK    0x0000003f      /* initiator mask */
+#define TP_INIT_PER_CLUSTER     4
+
+/*
+ * Define default values for some CCSR macros to make header files cleaner*
+ *
+ * To completely disable CCSR relocation in a board header file, define
+ * CONFIG_SYS_CCSR_DO_NOT_RELOCATE.  This will force CONFIG_SYS_CCSRBAR_PHYS
+ * to a value that is the same as CONFIG_SYS_CCSRBAR.
+ */
+
+#ifdef CONFIG_SYS_CCSRBAR_PHYS
+#error "Do not define CONFIG_SYS_CCSRBAR_PHYS directly.  Use \
+CONFIG_SYS_CCSRBAR_PHYS_LOW and/or CONFIG_SYS_CCSRBAR_PHYS_HIGH instead."
+#endif
+
+#ifdef CONFIG_SYS_CCSR_DO_NOT_RELOCATE
+#undef CONFIG_SYS_CCSRBAR_PHYS_HIGH
+#undef CONFIG_SYS_CCSRBAR_PHYS_LOW
+#define CONFIG_SYS_CCSRBAR_PHYS_HIGH	0
+#endif
+
+#ifndef CONFIG_SYS_CCSRBAR
+#define CONFIG_SYS_CCSRBAR		CONFIG_SYS_CCSRBAR_DEFAULT
+#endif
+
+#ifndef CONFIG_SYS_CCSRBAR_PHYS_HIGH
+#define CONFIG_SYS_CCSRBAR_PHYS_HIGH	0
+#endif
+
+#ifndef CONFIG_SYS_CCSRBAR_PHYS_LOW
+#define CONFIG_SYS_CCSRBAR_PHYS_LOW	CONFIG_SYS_CCSRBAR_DEFAULT
+#endif
+
+#define CONFIG_SYS_CCSRBAR_PHYS ((CONFIG_SYS_CCSRBAR_PHYS_HIGH * 1ull) << 32 | \
+				 CONFIG_SYS_CCSRBAR_PHYS_LOW)
+
+struct sys_info {
+	unsigned long freq_processor[CONFIG_MAX_CPUS];
+	unsigned long freq_systembus;
+	unsigned long freq_ddrbus;
+	unsigned long freq_localbus;
+	unsigned long freq_sdhc;
+#ifdef CONFIG_SYS_DPAA_FMAN
+	unsigned long freq_fman[CONFIG_SYS_NUM_FMAN];
+#endif
+	unsigned long freq_qman;
+};
+
+#define CONFIG_SYS_FSL_FM1_OFFSET		0xa00000
+#define CONFIG_SYS_FSL_FM1_RX0_1G_OFFSET	0xa88000
+#define CONFIG_SYS_FSL_FM1_RX1_1G_OFFSET	0xa89000
+#define CONFIG_SYS_FSL_FM1_RX2_1G_OFFSET	0xa8a000
+#define CONFIG_SYS_FSL_FM1_RX3_1G_OFFSET	0xa8b000
+#define CONFIG_SYS_FSL_FM1_RX4_1G_OFFSET	0xa8c000
+#define CONFIG_SYS_FSL_FM1_RX5_1G_OFFSET	0xa8d000
+
+#define CONFIG_SYS_FSL_FM1_DTSEC1_OFFSET	0xae0000
+#define CONFIG_SYS_FSL_FM1_ADDR			\
+		(CONFIG_SYS_IMMR + CONFIG_SYS_FSL_FM1_OFFSET)
+#define CONFIG_SYS_FSL_FM1_DTSEC1_ADDR		\
+		(CONFIG_SYS_IMMR + CONFIG_SYS_FSL_FM1_DTSEC1_OFFSET)
+
+/* Device Configuration and Pin Control */
+struct ccsr_gur {
+	u32     porsr1;         /* POR status 1 */
+#define FSL_CHASSIS2_CCSR_PORSR1_RCW_MASK	0xFF800000
+	u32     porsr2;         /* POR status 2 */
+	u8      res_008[0x20-0x8];
+	u32     gpporcr1;       /* General-purpose POR configuration */
+	u32	gpporcr2;
+#define FSL_CHASSIS2_DCFG_FUSESR_VID_SHIFT	25
+#define FSL_CHASSIS2_DCFG_FUSESR_VID_MASK	0x1F
+#define FSL_CHASSIS2_DCFG_FUSESR_ALTVID_SHIFT	20
+#define FSL_CHASSIS2_DCFG_FUSESR_ALTVID_MASK	0x1F
+	u32     dcfg_fusesr;    /* Fuse status register */
+	u8      res_02c[0x70-0x2c];
+	u32     devdisr;        /* Device disable control */
+#define FSL_CHASSIS2_DEVDISR2_DTSEC1_1	0x80000000
+#define FSL_CHASSIS2_DEVDISR2_DTSEC1_2	0x40000000
+#define FSL_CHASSIS2_DEVDISR2_DTSEC1_3	0x20000000
+#define FSL_CHASSIS2_DEVDISR2_DTSEC1_4	0x10000000
+#define FSL_CHASSIS2_DEVDISR2_DTSEC1_5	0x08000000
+#define FSL_CHASSIS2_DEVDISR2_DTSEC1_6	0x04000000
+#define FSL_CHASSIS2_DEVDISR2_DTSEC1_9	0x00800000
+#define FSL_CHASSIS2_DEVDISR2_DTSEC1_10	0x00400000
+#define FSL_CHASSIS2_DEVDISR2_10GEC1_1	0x00800000
+#define FSL_CHASSIS2_DEVDISR2_10GEC1_2	0x00400000
+#define FSL_CHASSIS2_DEVDISR2_10GEC1_3	0x80000000
+#define FSL_CHASSIS2_DEVDISR2_10GEC1_4	0x40000000
+	u32     devdisr2;       /* Device disable control 2 */
+	u32     devdisr3;       /* Device disable control 3 */
+	u32     devdisr4;       /* Device disable control 4 */
+	u32     devdisr5;       /* Device disable control 5 */
+	u32     devdisr6;       /* Device disable control 6 */
+	u32     devdisr7;       /* Device disable control 7 */
+	u8      res_08c[0x94-0x8c];
+	u32     coredisru;      /* uppper portion for support of 64 cores */
+	u32     coredisrl;      /* lower portion for support of 64 cores */
+	u8      res_09c[0xa0-0x9c];
+	u32     pvr;            /* Processor version */
+	u32     svr;            /* System version */
+	u32     mvr;            /* Manufacturing version */
+	u8	res_0ac[0xb0-0xac];
+	u32	rstcr;		/* Reset control */
+	u32	rstrqpblsr;	/* Reset request preboot loader status */
+	u8	res_0b8[0xc0-0xb8];
+	u32	rstrqmr1;	/* Reset request mask */
+	u8	res_0c4[0xc8-0xc4];
+	u32	rstrqsr1;	/* Reset request status */
+	u8	res_0cc[0xd4-0xcc];
+	u32	rstrqwdtmrl;	/* Reset request WDT mask */
+	u8	res_0d8[0xdc-0xd8];
+	u32	rstrqwdtsrl;	/* Reset request WDT status */
+	u8	res_0e0[0xe4-0xe0];
+	u32	brrl;		/* Boot release */
+	u8      res_0e8[0x100-0xe8];
+	u32     rcwsr[16];      /* Reset control word status */
+#define FSL_CHASSIS2_RCWSR0_SYS_PLL_RAT_SHIFT	25
+#define FSL_CHASSIS2_RCWSR0_SYS_PLL_RAT_MASK	0x1f
+#define FSL_CHASSIS2_RCWSR0_MEM_PLL_RAT_SHIFT	16
+#define FSL_CHASSIS2_RCWSR0_MEM_PLL_RAT_MASK	0x3f
+#define FSL_CHASSIS2_RCWSR4_SRDS1_PRTCL_MASK	0xffff0000
+#define FSL_CHASSIS2_RCWSR4_SRDS1_PRTCL_SHIFT	16
+	u8      res_140[0x200-0x140];
+	u32     scratchrw[4];  /* Scratch Read/Write */
+	u8      res_210[0x300-0x210];
+	u32     scratchw1r[4];  /* Scratch Read (Write once) */
+	u8      res_310[0x400-0x310];
+	u32	crstsr[12];
+	u8	res_430[0x500-0x430];
+
+	/* PCI Express n Logical I/O Device Number register */
+	u32 dcfg_ccsr_pex1liodnr;
+	u32 dcfg_ccsr_pex2liodnr;
+	u32 dcfg_ccsr_pex3liodnr;
+	u32 dcfg_ccsr_pex4liodnr;
+	/* RIO n Logical I/O Device Number register */
+	u32 dcfg_ccsr_rio1liodnr;
+	u32 dcfg_ccsr_rio2liodnr;
+	u32 dcfg_ccsr_rio3liodnr;
+	u32 dcfg_ccsr_rio4liodnr;
+	/* USB Logical I/O Device Number register */
+	u32 dcfg_ccsr_usb1liodnr;
+	u32 dcfg_ccsr_usb2liodnr;
+	u32 dcfg_ccsr_usb3liodnr;
+	u32 dcfg_ccsr_usb4liodnr;
+	/* SD/MMC Logical I/O Device Number register */
+	u32 dcfg_ccsr_sdmmc1liodnr;
+	u32 dcfg_ccsr_sdmmc2liodnr;
+	u32 dcfg_ccsr_sdmmc3liodnr;
+	u32 dcfg_ccsr_sdmmc4liodnr;
+	/* RIO Message Unit Logical I/O Device Number register */
+	u32 dcfg_ccsr_riomaintliodnr;
+
+	u8      res_544[0x550-0x544];
+	u32	sataliodnr[4];
+	u8	res_560[0x570-0x560];
+
+	u32 dcfg_ccsr_misc1liodnr;
+	u32 dcfg_ccsr_misc2liodnr;
+	u32 dcfg_ccsr_misc3liodnr;
+	u32 dcfg_ccsr_misc4liodnr;
+	u32 dcfg_ccsr_dma1liodnr;
+	u32 dcfg_ccsr_dma2liodnr;
+	u32 dcfg_ccsr_dma3liodnr;
+	u32 dcfg_ccsr_dma4liodnr;
+	u32 dcfg_ccsr_spare1liodnr;
+	u32 dcfg_ccsr_spare2liodnr;
+	u32 dcfg_ccsr_spare3liodnr;
+	u32 dcfg_ccsr_spare4liodnr;
+	u8	res_5a0[0x600-0x5a0];
+	u32 dcfg_ccsr_pblsr;
+
+	u32	pamubypenr;
+	u32	dmacr1;
+
+	u8	res_60c[0x610-0x60c];
+	u32 dcfg_ccsr_gensr1;
+	u32 dcfg_ccsr_gensr2;
+	u32 dcfg_ccsr_gensr3;
+	u32 dcfg_ccsr_gensr4;
+	u32 dcfg_ccsr_gencr1;
+	u32 dcfg_ccsr_gencr2;
+	u32 dcfg_ccsr_gencr3;
+	u32 dcfg_ccsr_gencr4;
+	u32 dcfg_ccsr_gencr5;
+	u32 dcfg_ccsr_gencr6;
+	u32 dcfg_ccsr_gencr7;
+	u8	res_63c[0x658-0x63c];
+	u32 dcfg_ccsr_cgensr1;
+	u32 dcfg_ccsr_cgensr0;
+	u8	res_660[0x678-0x660];
+	u32 dcfg_ccsr_cgencr1;
+
+	u32 dcfg_ccsr_cgencr0;
+	u8	res_680[0x700-0x680];
+	u32 dcfg_ccsr_sriopstecr;
+	u32 dcfg_ccsr_dcsrcr;
+
+	u8      res_708[0x740-0x708];   /* add more registers when needed */
+	u32     tp_ityp[64];    /* Topology Initiator Type Register */
+	struct {
+		u32     upper;
+		u32     lower;
+	} tp_cluster[16];
+	u8      res_8c0[0xa00-0x8c0];   /* add more registers when needed */
+	u32 dcfg_ccsr_qmbm_warmrst;
+	u8      res_a04[0xa20-0xa04];   /* add more registers when needed */
+	u32 dcfg_ccsr_reserved0;
+	u32 dcfg_ccsr_reserved1;
+};
+
+#define SCFG_QSPI_CLKSEL		0x40100000
+#define SCFG_USBDRVVBUS_SELCR_USB1	0x00000000
+#define SCFG_USBDRVVBUS_SELCR_USB2	0x00000001
+#define SCFG_USBDRVVBUS_SELCR_USB3	0x00000002
+#define SCFG_USBPWRFAULT_INACTIVE	0x00000000
+#define SCFG_USBPWRFAULT_SHARED		0x00000001
+#define SCFG_USBPWRFAULT_DEDICATED	0x00000002
+#define SCFG_USBPWRFAULT_USB3_SHIFT	4
+#define SCFG_USBPWRFAULT_USB2_SHIFT	2
+#define SCFG_USBPWRFAULT_USB1_SHIFT	0
+
+#define SCFG_SNPCNFGCR_SECRDSNP		0x80000000
+#define SCFG_SNPCNFGCR_SECWRSNP		0x40000000
+
+/* Supplemental Configuration Unit */
+struct ccsr_scfg {
+	u8 res_000[0x100-0x000];
+	u32 usb2_icid;
+	u32 usb3_icid;
+	u8 res_108[0x114-0x108];
+	u32 dma_icid;
+	u32 sata_icid;
+	u32 usb1_icid;
+	u32 qe_icid;
+	u32 sdhc_icid;
+	u32 edma_icid;
+	u32 etr_icid;
+	u32 core_sft_rst[4];
+	u8 res_140[0x158-0x140];
+	u32 altcbar;
+	u32 qspi_cfg;
+	u8 res_160[0x180-0x160];
+	u32 dmamcr;
+	u8 res_184[0x18c-0x184];
+	u32 debug_icid;
+	u8 res_190[0x1a4-0x190];
+	u32 snpcnfgcr;
+	u8 res_1a8[0x1ac-0x1a8];
+	u32 intpcr;
+	u8 res_1b0[0x204-0x1b0];
+	u32 coresrencr;
+	u8 res_208[0x220-0x208];
+	u32 rvbar0_0;
+	u32 rvbar0_1;
+	u32 rvbar1_0;
+	u32 rvbar1_1;
+	u32 rvbar2_0;
+	u32 rvbar2_1;
+	u32 rvbar3_0;
+	u32 rvbar3_1;
+	u32 lpmcsr;
+	u8 res_244[0x400-0x244];
+	u32 qspidqscr;
+	u32 ecgtxcmcr;
+	u32 sdhciovselcr;
+	u32 rcwpmuxcr0;
+	u32 usbdrvvbus_selcr;
+	u32 usbpwrfault_selcr;
+	u32 usb_refclk_selcr1;
+	u32 usb_refclk_selcr2;
+	u32 usb_refclk_selcr3;
+	u8 res_424[0x600-0x424];
+	u32 scratchrw[4];
+	u8 res_610[0x680-0x610];
+	u32 corebcr;
+	u8 res_684[0x1000-0x684];
+	u32 pex1msiir;
+	u32 pex1msir;
+	u8 res_1008[0x2000-0x1008];
+	u32 pex2;
+	u32 pex2msir;
+	u8 res_2008[0x3000-0x2008];
+	u32 pex3msiir;
+	u32 pex3msir;
+};
+
+/* Clocking */
+struct ccsr_clk {
+	struct {
+		u32 clkcncsr;	/* core cluster n clock control status */
+		u8  res_004[0x0c];
+		u32 clkcghwacsr; /* Clock generator n hardware accelerator */
+		u8  res_014[0x0c];
+	} clkcsr[4];
+	u8	res_040[0x780]; /* 0x100 */
+	struct {
+		u32 pllcngsr;
+		u8 res_804[0x1c];
+	} pllcgsr[2];
+	u8	res_840[0x1c0];
+	u32	clkpcsr;	/* 0xa00 Platform clock domain control/status */
+	u8	res_a04[0x1fc];
+	u32	pllpgsr;	/* 0xc00 Platform PLL General Status */
+	u8	res_c04[0x1c];
+	u32	plldgsr;	/* 0xc20 DDR PLL General Status */
+	u8	res_c24[0x3dc];
+};
+
+/* System Counter */
+struct sctr_regs {
+	u32 cntcr;
+	u32 cntsr;
+	u32 cntcv1;
+	u32 cntcv2;
+	u32 resv1[4];
+	u32 cntfid0;
+	u32 cntfid1;
+	u32 resv2[1002];
+	u32 counterid[12];
+};
+
+#define SRDS_MAX_LANES		4
+struct ccsr_serdes {
+	struct {
+		u32	rstctl;	/* Reset Control Register */
+#define SRDS_RSTCTL_RST		0x80000000
+#define SRDS_RSTCTL_RSTDONE	0x40000000
+#define SRDS_RSTCTL_RSTERR	0x20000000
+#define SRDS_RSTCTL_SWRST	0x10000000
+#define SRDS_RSTCTL_SDEN	0x00000020
+#define SRDS_RSTCTL_SDRST_B	0x00000040
+#define SRDS_RSTCTL_PLLRST_B	0x00000080
+		u32	pllcr0; /* PLL Control Register 0 */
+#define SRDS_PLLCR0_POFF		0x80000000
+#define SRDS_PLLCR0_RFCK_SEL_MASK	0x70000000
+#define SRDS_PLLCR0_RFCK_SEL_100	0x00000000
+#define SRDS_PLLCR0_RFCK_SEL_125	0x10000000
+#define SRDS_PLLCR0_RFCK_SEL_156_25	0x20000000
+#define SRDS_PLLCR0_RFCK_SEL_150	0x30000000
+#define SRDS_PLLCR0_RFCK_SEL_161_13	0x40000000
+#define SRDS_PLLCR0_RFCK_SEL_122_88	0x50000000
+#define SRDS_PLLCR0_PLL_LCK		0x00800000
+#define SRDS_PLLCR0_FRATE_SEL_MASK	0x000f0000
+#define SRDS_PLLCR0_FRATE_SEL_5		0x00000000
+#define SRDS_PLLCR0_FRATE_SEL_3_75	0x00050000
+#define SRDS_PLLCR0_FRATE_SEL_5_15	0x00060000
+#define SRDS_PLLCR0_FRATE_SEL_4		0x00070000
+#define SRDS_PLLCR0_FRATE_SEL_3_12	0x00090000
+#define SRDS_PLLCR0_FRATE_SEL_3		0x000a0000
+		u32	pllcr1; /* PLL Control Register 1 */
+#define SRDS_PLLCR1_PLL_BWSEL	0x08000000
+		u32	res_0c;	/* 0x00c */
+		u32	pllcr3;
+		u32	pllcr4;
+		u8	res_18[0x20-0x18];
+	} bank[2];
+	u8	res_40[0x90-0x40];
+	u32	srdstcalcr;	/* 0x90 TX Calibration Control */
+	u8	res_94[0xa0-0x94];
+	u32	srdsrcalcr;	/* 0xa0 RX Calibration Control */
+	u8	res_a4[0xb0-0xa4];
+	u32	srdsgr0;	/* 0xb0 General Register 0 */
+	u8	res_b4[0xe0-0xb4];
+	u32	srdspccr0;	/* 0xe0 Protocol Converter Config 0 */
+	u32	srdspccr1;	/* 0xe4 Protocol Converter Config 1 */
+	u32	srdspccr2;	/* 0xe8 Protocol Converter Config 2 */
+	u32	srdspccr3;	/* 0xec Protocol Converter Config 3 */
+	u32	srdspccr4;	/* 0xf0 Protocol Converter Config 4 */
+	u8	res_f4[0x100-0xf4];
+	struct {
+		u32	lnpssr;	/* 0x100, 0x120, ..., 0x1e0 */
+		u8	res_104[0x120-0x104];
+	} srdslnpssr[4];
+	u8	res_180[0x300-0x180];
+	u32	srdspexeqcr;
+	u32	srdspexeqpcr[11];
+	u8	res_330[0x400-0x330];
+	u32	srdspexapcr;
+	u8	res_404[0x440-0x404];
+	u32	srdspexbpcr;
+	u8	res_444[0x800-0x444];
+	struct {
+		u32	gcr0;	/* 0x800 General Control Register 0 */
+		u32	gcr1;	/* 0x804 General Control Register 1 */
+		u32	gcr2;	/* 0x808 General Control Register 2 */
+		u32	sscr0;
+		u32	recr0;	/* 0x810 Receive Equalization Control */
+		u32	recr1;
+		u32	tecr0;	/* 0x818 Transmit Equalization Control */
+		u32	sscr1;
+		u32	ttlcr0;	/* 0x820 Transition Tracking Loop Ctrl 0 */
+		u8	res_824[0x83c-0x824];
+		u32	tcsr3;
+	} lane[4];	/* Lane A, B, C, D, E, F, G, H */
+	u8	res_a00[0x1000-0xa00];	/* from 0xa00 to 0xfff */
+};
+
+#define CCI400_CTRLORD_TERM_BARRIER	0x00000008
+#define CCI400_CTRLORD_EN_BARRIER	0
+#define CCI400_SHAORD_NON_SHAREABLE	0x00000002
+#define CCI400_DVM_MESSAGE_REQ_EN	0x00000002
+#define CCI400_SNOOP_REQ_EN		0x00000001
+
+/* CCI-400 registers */
+struct ccsr_cci400 {
+	u32 ctrl_ord;			/* Control Override */
+	u32 spec_ctrl;			/* Speculation Control */
+	u32 secure_access;		/* Secure Access */
+	u32 status;			/* Status */
+	u32 impr_err;			/* Imprecise Error */
+	u8 res_14[0x100 - 0x14];
+	u32 pmcr;			/* Performance Monitor Control */
+	u8 res_104[0xfd0 - 0x104];
+	u32 pid[8];			/* Peripheral ID */
+	u32 cid[4];			/* Component ID */
+	struct {
+		u32 snoop_ctrl;		/* Snoop Control */
+		u32 sha_ord;		/* Shareable Override */
+		u8 res_1008[0x1100 - 0x1008];
+		u32 rc_qos_ord;		/* read channel QoS Value Override */
+		u32 wc_qos_ord;		/* read channel QoS Value Override */
+		u8 res_1108[0x110c - 0x1108];
+		u32 qos_ctrl;		/* QoS Control */
+		u32 max_ot;		/* Max OT */
+		u8 res_1114[0x1130 - 0x1114];
+		u32 target_lat;		/* Target Latency */
+		u32 latency_regu;	/* Latency Regulation */
+		u32 qos_range;		/* QoS Range */
+		u8 res_113c[0x2000 - 0x113c];
+	} slave[5];			/* Slave Interface */
+	u8 res_6000[0x9004 - 0x6000];
+	u32 cycle_counter;		/* Cycle counter */
+	u32 count_ctrl;			/* Count Control */
+	u32 overflow_status;		/* Overflow Flag Status */
+	u8 res_9010[0xa000 - 0x9010];
+	struct {
+		u32 event_select;	/* Event Select */
+		u32 event_count;	/* Event Count */
+		u32 counter_ctrl;	/* Counter Control */
+		u32 overflow_status;	/* Overflow Flag Status */
+		u8 res_a010[0xb000 - 0xa010];
+	} pcounter[4];			/* Performance Counter */
+	u8 res_e004[0x10000 - 0xe004];
+};
+
+/* MMU 500 */
+#define SMMU_SCR0			(SMMU_BASE + 0x0)
+#define SMMU_SCR1			(SMMU_BASE + 0x4)
+#define SMMU_SCR2			(SMMU_BASE + 0x8)
+#define SMMU_SACR			(SMMU_BASE + 0x10)
+#define SMMU_IDR0			(SMMU_BASE + 0x20)
+#define SMMU_IDR1			(SMMU_BASE + 0x24)
+
+#define SMMU_NSCR0			(SMMU_BASE + 0x400)
+#define SMMU_NSCR2			(SMMU_BASE + 0x408)
+#define SMMU_NSACR			(SMMU_BASE + 0x410)
+
+#define SCR0_CLIENTPD_MASK		0x00000001
+#define SCR0_USFCFG_MASK		0x00000400
+
+#endif	/* __ARCH_FSL_LSCH2_IMMAP_H__*/
diff --git a/arch/arm/include/asm/arch-fsl-layerscape/ns_access.h b/arch/arm/include/asm/arch-fsl-layerscape/ns_access.h
new file mode 100644
index 0000000..a3ccdb0
--- /dev/null
+++ b/arch/arm/include/asm/arch-fsl-layerscape/ns_access.h
@@ -0,0 +1,158 @@
+/*
+ * Copyright 2015 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __FSL_NS_ACCESS_H_
+#define __FSL_NS_ACCESS_H_
+
+enum csu_cslx_ind {
+	CSU_CSLX_PCIE2_IO = 0,
+	CSU_CSLX_PCIE1_IO,
+	CSU_CSLX_MG2TPR_IP,
+	CSU_CSLX_IFC_MEM,
+	CSU_CSLX_OCRAM,
+	CSU_CSLX_GIC,
+	CSU_CSLX_PCIE1,
+	CSU_CSLX_OCRAM2,
+	CSU_CSLX_QSPI_MEM,
+	CSU_CSLX_PCIE2,
+	CSU_CSLX_SATA,
+	CSU_CSLX_USB1,
+	CSU_CSLX_QM_BM_SWPORTAL,
+	CSU_CSLX_PCIE3 = 16,
+	CSU_CSLX_PCIE3_IO,
+	CSU_CSLX_USB3 = 20,
+	CSU_CSLX_USB2,
+	CSU_CSLX_SERDES = 32,
+	CSU_CSLX_QDMA,
+	CSU_CSLX_LPUART2,
+	CSU_CSLX_LPUART1,
+	CSU_CSLX_LPUART4,
+	CSU_CSLX_LPUART3,
+	CSU_CSLX_LPUART6,
+	CSU_CSLX_LPUART5,
+	CSU_CSLX_DSPI1 = 41,
+	CSU_CSLX_QSPI,
+	CSU_CSLX_ESDHC,
+	CSU_CSLX_IFC = 45,
+	CSU_CSLX_I2C1,
+	CSU_CSLX_I2C3 = 48,
+	CSU_CSLX_I2C2,
+	CSU_CSLX_DUART2 = 50,
+	CSU_CSLX_DUART1,
+	CSU_CSLX_WDT2,
+	CSU_CSLX_WDT1,
+	CSU_CSLX_EDMA,
+	CSU_CSLX_SYS_CNT,
+	CSU_CSLX_DMA_MUX2,
+	CSU_CSLX_DMA_MUX1,
+	CSU_CSLX_DDR,
+	CSU_CSLX_QUICC,
+	CSU_CSLX_DCFG_CCU_RCPM = 60,
+	CSU_CSLX_SECURE_BOOTROM,
+	CSU_CSLX_SFP,
+	CSU_CSLX_TMU,
+	CSU_CSLX_SECURE_MONITOR,
+	CSU_CSLX_SCFG,
+	CSU_CSLX_FM = 66,
+	CSU_CSLX_SEC5_5,
+	CSU_CSLX_BM,
+	CSU_CSLX_QM,
+	CSU_CSLX_GPIO2 = 70,
+	CSU_CSLX_GPIO1,
+	CSU_CSLX_GPIO4,
+	CSU_CSLX_GPIO3,
+	CSU_CSLX_PLATFORM_CONT,
+	CSU_CSLX_CSU,
+	CSU_CSLX_IIC4 = 77,
+	CSU_CSLX_WDT4,
+	CSU_CSLX_WDT3,
+	CSU_CSLX_WDT5 = 81,
+	CSU_CSLX_FTM2 = 86,
+	CSU_CSLX_FTM1,
+	CSU_CSLX_FTM4,
+	CSU_CSLX_FTM3,
+	CSU_CSLX_FTM6 = 90,
+	CSU_CSLX_FTM5,
+	CSU_CSLX_FTM8,
+	CSU_CSLX_FTM7,
+	CSU_CSLX_DSCR = 121,
+};
+
+static struct csu_ns_dev ns_dev[] = {
+	 {CSU_CSLX_PCIE2_IO, CSU_ALL_RW},
+	 {CSU_CSLX_PCIE1_IO, CSU_ALL_RW},
+	 {CSU_CSLX_MG2TPR_IP, CSU_ALL_RW},
+	 {CSU_CSLX_IFC_MEM, CSU_ALL_RW},
+	 {CSU_CSLX_OCRAM, CSU_ALL_RW},
+	 {CSU_CSLX_GIC, CSU_ALL_RW},
+	 {CSU_CSLX_PCIE1, CSU_ALL_RW},
+	 {CSU_CSLX_OCRAM2, CSU_ALL_RW},
+	 {CSU_CSLX_QSPI_MEM, CSU_ALL_RW},
+	 {CSU_CSLX_PCIE2, CSU_ALL_RW},
+	 {CSU_CSLX_SATA, CSU_ALL_RW},
+	 {CSU_CSLX_USB1, CSU_ALL_RW},
+	 {CSU_CSLX_QM_BM_SWPORTAL, CSU_ALL_RW},
+	 {CSU_CSLX_PCIE3, CSU_ALL_RW},
+	 {CSU_CSLX_PCIE3_IO, CSU_ALL_RW},
+	 {CSU_CSLX_USB3, CSU_ALL_RW},
+	 {CSU_CSLX_USB2, CSU_ALL_RW},
+	 {CSU_CSLX_SERDES, CSU_ALL_RW},
+	 {CSU_CSLX_QDMA, CSU_ALL_RW},
+	 {CSU_CSLX_LPUART2, CSU_ALL_RW},
+	 {CSU_CSLX_LPUART1, CSU_ALL_RW},
+	 {CSU_CSLX_LPUART4, CSU_ALL_RW},
+	 {CSU_CSLX_LPUART3, CSU_ALL_RW},
+	 {CSU_CSLX_LPUART6, CSU_ALL_RW},
+	 {CSU_CSLX_LPUART5, CSU_ALL_RW},
+	 {CSU_CSLX_DSPI1, CSU_ALL_RW},
+	 {CSU_CSLX_QSPI, CSU_ALL_RW},
+	 {CSU_CSLX_ESDHC, CSU_ALL_RW},
+	 {CSU_CSLX_IFC, CSU_ALL_RW},
+	 {CSU_CSLX_I2C1, CSU_ALL_RW},
+	 {CSU_CSLX_I2C3, CSU_ALL_RW},
+	 {CSU_CSLX_I2C2, CSU_ALL_RW},
+	 {CSU_CSLX_DUART2, CSU_ALL_RW},
+	 {CSU_CSLX_DUART1, CSU_ALL_RW},
+	 {CSU_CSLX_WDT2, CSU_ALL_RW},
+	 {CSU_CSLX_WDT1, CSU_ALL_RW},
+	 {CSU_CSLX_EDMA, CSU_ALL_RW},
+	 {CSU_CSLX_SYS_CNT, CSU_ALL_RW},
+	 {CSU_CSLX_DMA_MUX2, CSU_ALL_RW},
+	 {CSU_CSLX_DMA_MUX1, CSU_ALL_RW},
+	 {CSU_CSLX_DDR, CSU_ALL_RW},
+	 {CSU_CSLX_QUICC, CSU_ALL_RW},
+	 {CSU_CSLX_DCFG_CCU_RCPM, CSU_ALL_RW},
+	 {CSU_CSLX_SECURE_BOOTROM, CSU_ALL_RW},
+	 {CSU_CSLX_SFP, CSU_ALL_RW},
+	 {CSU_CSLX_TMU, CSU_ALL_RW},
+	 {CSU_CSLX_SECURE_MONITOR, CSU_ALL_RW},
+	 {CSU_CSLX_SCFG, CSU_ALL_RW},
+	 {CSU_CSLX_FM, CSU_ALL_RW},
+	 {CSU_CSLX_SEC5_5, CSU_ALL_RW},
+	 {CSU_CSLX_BM, CSU_ALL_RW},
+	 {CSU_CSLX_QM, CSU_ALL_RW},
+	 {CSU_CSLX_GPIO2, CSU_ALL_RW},
+	 {CSU_CSLX_GPIO1, CSU_ALL_RW},
+	 {CSU_CSLX_GPIO4, CSU_ALL_RW},
+	 {CSU_CSLX_GPIO3, CSU_ALL_RW},
+	 {CSU_CSLX_PLATFORM_CONT, CSU_ALL_RW},
+	 {CSU_CSLX_CSU, CSU_ALL_RW},
+	 {CSU_CSLX_IIC4, CSU_ALL_RW},
+	 {CSU_CSLX_WDT4, CSU_ALL_RW},
+	 {CSU_CSLX_WDT3, CSU_ALL_RW},
+	 {CSU_CSLX_WDT5, CSU_ALL_RW},
+	 {CSU_CSLX_FTM2, CSU_ALL_RW},
+	 {CSU_CSLX_FTM1, CSU_ALL_RW},
+	 {CSU_CSLX_FTM4, CSU_ALL_RW},
+	 {CSU_CSLX_FTM3, CSU_ALL_RW},
+	 {CSU_CSLX_FTM6, CSU_ALL_RW},
+	 {CSU_CSLX_FTM5, CSU_ALL_RW},
+	 {CSU_CSLX_FTM8, CSU_ALL_RW},
+	 {CSU_CSLX_FTM7, CSU_ALL_RW},
+	 {CSU_CSLX_DSCR, CSU_ALL_RW},
+};
+
+#endif
diff --git a/arch/arm/include/asm/arch-fsl-layerscape/soc.h b/arch/arm/include/asm/arch-fsl-layerscape/soc.h
index f131f57..5ed456e 100644
--- a/arch/arm/include/asm/arch-fsl-layerscape/soc.h
+++ b/arch/arm/include/asm/arch-fsl-layerscape/soc.h
@@ -33,6 +33,7 @@ struct cpu_type {
 	{ .name = #n, .soc_ver = SVR_##v, .num_cores = (nc)}
 
 #define SVR_WO_E		0xFFFFFE
+#define SVR_LS1043		0x879204
 #define SVR_LS2045		0x870120
 #define SVR_LS2080		0x870110
 #define SVR_LS2085		0x870100
@@ -42,6 +43,11 @@ struct cpu_type {
 #define SVR_SOC_VER(svr)	(((svr) >> 8) & SVR_WO_E)
 #define IS_E_PROCESSOR(svr)	(!((svr >> 8) & 0x1))
 
+#ifdef CONFIG_FSL_LSCH3
 void fsl_lsch3_early_init_f(void);
+#elif defined(CONFIG_FSL_LSCH2)
+void fsl_lsch2_early_init_f(void);
+#endif
+
 void cpu_name(char *name);
 #endif /* _ASM_ARMV8_FSL_LAYERSCAPE_SOC_H_ */
diff --git a/arch/arm/include/asm/armv8/mmu.h b/arch/arm/include/asm/armv8/mmu.h
index 587ee39..d8d9af4 100644
--- a/arch/arm/include/asm/armv8/mmu.h
+++ b/arch/arm/include/asm/armv8/mmu.h
@@ -65,6 +65,7 @@
 /*
  * Section
  */
+#define PMD_SECT_NS		(1 << 5)
 #define PMD_SECT_NON_SHARE	(0 << 8)
 #define PMD_SECT_OUTER_SHARE	(2 << 8)
 #define PMD_SECT_INNER_SHARE	(3 << 8)
diff --git a/include/common.h b/include/common.h
index 142936b..09a131d 100644
--- a/include/common.h
+++ b/include/common.h
@@ -79,6 +79,9 @@ typedef volatile unsigned char	vu_char;
 #ifdef CONFIG_FSL_LSCH3
 #include <asm/arch/immap_lsch3.h>
 #endif
+#ifdef CONFIG_FSL_LSCH2
+#include <asm/arch/immap_lsch2.h>
+#endif
 
 #include <part.h>
 #include <flash.h>
-- 
2.1.0.27.g96db324

