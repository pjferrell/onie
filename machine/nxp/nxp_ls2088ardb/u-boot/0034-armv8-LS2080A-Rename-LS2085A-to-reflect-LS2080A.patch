From 9cd80802bd6d931c17b1f808c6699ae7e530cfdd Mon Sep 17 00:00:00 2001
From: Prabhakar Kushwaha <prabhakar@freescale.com>
Date: Thu, 21 Apr 2016 16:34:24 +0800
Subject: [PATCH 34/74] armv8: LS2080A: Rename LS2085A to reflect LS2080A
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

commit 449372148f6d9b5b8bded88ed8eee5c581a4bf81
[context adjustment]

LS2080A is a prime personality of Freescaleâ€™s LS2085A. It is a non-AIOP
personality without support of DP-DDR, L2 switch, 1588, PCIe endpoint etc.
So renaming existing LS2085A code base to reflect LS2080A (Prime personality)

Signed-off-by: Pratiyush Mohan Srivastava <pratiyush.srivastava@freescale.com>
Signed-off-by: Prabhakar Kushwaha <prabhakar@freescale.com>
[York Sun: Dropped #ifdef in cpu.c for cpu_type_list]
Reviewed-by: York Sun <yorksun@freescale.com>
Integrated-by: Zhao Qiang <qiang.zhao@nxp.com>
---
 README                                             |   3 +
 arch/arm/Kconfig                                   |  44 +-
 arch/arm/cpu/armv8/fsl-layerscape/Makefile         |   4 +-
 arch/arm/cpu/armv8/fsl-layerscape/README.lsch3     |   4 +-
 arch/arm/cpu/armv8/fsl-layerscape/cpu.c            |   2 +-
 arch/arm/cpu/armv8/fsl-layerscape/fdt.c            |   2 +-
 .../arm/cpu/armv8/fsl-layerscape/fsl_lsch3_speed.c |  11 +
 arch/arm/cpu/armv8/fsl-layerscape/ls2080a_serdes.c | 116 +++
 arch/arm/cpu/armv8/fsl-layerscape/ls2085a_serdes.c | 116 ---
 arch/arm/cpu/armv8/fsl-layerscape/soc.c            |   2 +-
 arch/arm/cpu/armv8/fsl-layerscape/spl.c            |   4 +-
 arch/arm/dts/Makefile                              |   4 +-
 arch/arm/dts/fsl-ls2080a-qds.dts                   |  53 ++
 arch/arm/dts/fsl-ls2080a-rdb.dts                   |  35 +
 arch/arm/dts/fsl-ls2080a.dtsi                      | 129 ++++
 arch/arm/dts/fsl-ls2085a-qds.dts                   |  53 --
 arch/arm/dts/fsl-ls2085a-rdb.dts                   |  35 -
 arch/arm/dts/fsl-ls2085a.dtsi                      | 129 ----
 arch/arm/include/asm/arch-fsl-layerscape/config.h  |   4 +-
 arch/arm/include/asm/arch-fsl-layerscape/cpu.h     |   4 +-
 .../include/asm/arch-fsl-layerscape/fsl_serdes.h   |   2 +-
 .../include/asm/arch-fsl-layerscape/immap_lsch3.h  |   6 +-
 .../asm/arch-fsl-layerscape/ls2080a_stream_id.h    |  64 ++
 .../asm/arch-fsl-layerscape/ls2085a_stream_id.h    |  64 --
 arch/arm/include/asm/global_data.h                 |   2 +-
 board/freescale/ls2080a/Kconfig                    |  31 +
 board/freescale/ls2080a/MAINTAINERS                |   8 +
 board/freescale/ls2080a/Makefile                   |   8 +
 board/freescale/ls2080a/README                     |  27 +
 board/freescale/ls2080a/ddr.c                      | 207 ++++++
 board/freescale/ls2080a/ddr.h                      |  86 +++
 board/freescale/ls2080a/ls2080a.c                  | 152 ++++
 board/freescale/ls2080aqds/Kconfig                 |  16 +
 board/freescale/ls2080aqds/MAINTAINERS             |   8 +
 board/freescale/ls2080aqds/Makefile                |   9 +
 board/freescale/ls2080aqds/README                  | 229 ++++++
 board/freescale/ls2080aqds/ddr.c                   | 199 +++++
 board/freescale/ls2080aqds/ddr.h                   |  92 +++
 board/freescale/ls2080aqds/eth.c                   | 825 +++++++++++++++++++++
 board/freescale/ls2080aqds/ls2080aqds.c            | 336 +++++++++
 board/freescale/ls2080aqds/ls2080aqds_qixis.h      |  30 +
 board/freescale/ls2080ardb/Kconfig                 |  16 +
 board/freescale/ls2080ardb/MAINTAINERS             |   8 +
 board/freescale/ls2080ardb/Makefile                |   8 +
 board/freescale/ls2080ardb/README                  | 120 +++
 board/freescale/ls2080ardb/ddr.c                   | 199 +++++
 board/freescale/ls2080ardb/ddr.h                   |  92 +++
 board/freescale/ls2080ardb/eth_ls2080rdb.c         | 147 ++++
 board/freescale/ls2080ardb/ls2080ardb.c            | 321 ++++++++
 board/freescale/ls2080ardb/ls2080ardb_qixis.h      |  20 +
 board/freescale/ls2085a/Kconfig                    |  31 -
 board/freescale/ls2085a/MAINTAINERS                |   8 -
 board/freescale/ls2085a/Makefile                   |   8 -
 board/freescale/ls2085a/README                     |  27 -
 board/freescale/ls2085a/ddr.c                      | 206 -----
 board/freescale/ls2085a/ddr.h                      |  86 ---
 board/freescale/ls2085a/ls2085a.c                  | 150 ----
 board/freescale/ls2085aqds/Kconfig                 |  16 -
 board/freescale/ls2085aqds/MAINTAINERS             |   8 -
 board/freescale/ls2085aqds/Makefile                |   9 -
 board/freescale/ls2085aqds/README                  | 229 ------
 board/freescale/ls2085aqds/ddr.c                   | 196 -----
 board/freescale/ls2085aqds/ddr.h                   |  92 ---
 board/freescale/ls2085aqds/eth.c                   | 825 ---------------------
 board/freescale/ls2085aqds/ls2085aqds.c            | 334 ---------
 board/freescale/ls2085aqds/ls2085aqds_qixis.h      |  30 -
 board/freescale/ls2085ardb/Kconfig                 |  16 -
 board/freescale/ls2085ardb/MAINTAINERS             |   8 -
 board/freescale/ls2085ardb/Makefile                |   8 -
 board/freescale/ls2085ardb/README                  | 120 ---
 board/freescale/ls2085ardb/ddr.c                   | 196 -----
 board/freescale/ls2085ardb/ddr.h                   |  92 ---
 board/freescale/ls2085ardb/eth_ls2085rdb.c         | 147 ----
 board/freescale/ls2085ardb/ls2085ardb.c            | 319 --------
 board/freescale/ls2085ardb/ls2085ardb_qixis.h      |  20 -
 configs/ls2080a_emu_defconfig                      |  14 +
 configs/ls2080a_simu_defconfig                     |  15 +
 configs/ls2080aqds_defconfig                       |  14 +
 configs/ls2080aqds_nand_defconfig                  |   8 +
 configs/ls2080ardb_defconfig                       |  14 +
 configs/ls2080ardb_nand_defconfig                  |   8 +
 configs/ls2085a_emu_defconfig                      |  14 -
 configs/ls2085a_simu_defconfig                     |  15 -
 configs/ls2085aqds_defconfig                       |  14 -
 configs/ls2085aqds_nand_defconfig                  |   8 -
 configs/ls2085ardb_defconfig                       |  14 -
 configs/ls2085ardb_nand_defconfig                  |   8 -
 doc/README.fsl-trustzone-components                |   4 +-
 drivers/ddr/fsl/fsl_ddr_gen4.c                     |   4 +-
 drivers/net/fsl-mc/mc.c                            |   5 +-
 drivers/net/ldpaa_eth/Makefile                     |   2 +-
 drivers/net/ldpaa_eth/ls2080a.c                    |  81 ++
 drivers/net/ldpaa_eth/ls2085a.c                    |  81 --
 drivers/pci/pcie_layerscape.c                      |   2 +-
 include/configs/ls2080a_common.h                   | 317 ++++++++
 include/configs/ls2080a_emu.h                      |  91 +++
 include/configs/ls2080a_simu.h                     | 163 ++++
 include/configs/ls2080aqds.h                       | 384 ++++++++++
 include/configs/ls2080ardb.h                       | 345 +++++++++
 include/configs/ls2085a_common.h                   | 313 --------
 include/configs/ls2085a_emu.h                      |  89 ---
 include/configs/ls2085a_simu.h                     | 161 ----
 include/configs/ls2085aqds.h                       | 382 ----------
 include/configs/ls2085ardb.h                       | 343 ---------
 include/linux/usb/xhci-fsl.h                       |   6 +-
 105 files changed, 5120 insertions(+), 5066 deletions(-)
 create mode 100644 arch/arm/cpu/armv8/fsl-layerscape/ls2080a_serdes.c
 delete mode 100644 arch/arm/cpu/armv8/fsl-layerscape/ls2085a_serdes.c
 create mode 100644 arch/arm/dts/fsl-ls2080a-qds.dts
 create mode 100644 arch/arm/dts/fsl-ls2080a-rdb.dts
 create mode 100644 arch/arm/dts/fsl-ls2080a.dtsi
 delete mode 100644 arch/arm/dts/fsl-ls2085a-qds.dts
 delete mode 100644 arch/arm/dts/fsl-ls2085a-rdb.dts
 delete mode 100644 arch/arm/dts/fsl-ls2085a.dtsi
 create mode 100644 arch/arm/include/asm/arch-fsl-layerscape/ls2080a_stream_id.h
 delete mode 100644 arch/arm/include/asm/arch-fsl-layerscape/ls2085a_stream_id.h
 create mode 100644 board/freescale/ls2080a/Kconfig
 create mode 100644 board/freescale/ls2080a/MAINTAINERS
 create mode 100644 board/freescale/ls2080a/Makefile
 create mode 100644 board/freescale/ls2080a/README
 create mode 100644 board/freescale/ls2080a/ddr.c
 create mode 100644 board/freescale/ls2080a/ddr.h
 create mode 100644 board/freescale/ls2080a/ls2080a.c
 create mode 100644 board/freescale/ls2080aqds/Kconfig
 create mode 100644 board/freescale/ls2080aqds/MAINTAINERS
 create mode 100644 board/freescale/ls2080aqds/Makefile
 create mode 100644 board/freescale/ls2080aqds/README
 create mode 100644 board/freescale/ls2080aqds/ddr.c
 create mode 100644 board/freescale/ls2080aqds/ddr.h
 create mode 100644 board/freescale/ls2080aqds/eth.c
 create mode 100644 board/freescale/ls2080aqds/ls2080aqds.c
 create mode 100644 board/freescale/ls2080aqds/ls2080aqds_qixis.h
 create mode 100644 board/freescale/ls2080ardb/Kconfig
 create mode 100644 board/freescale/ls2080ardb/MAINTAINERS
 create mode 100644 board/freescale/ls2080ardb/Makefile
 create mode 100644 board/freescale/ls2080ardb/README
 create mode 100644 board/freescale/ls2080ardb/ddr.c
 create mode 100644 board/freescale/ls2080ardb/ddr.h
 create mode 100644 board/freescale/ls2080ardb/eth_ls2080rdb.c
 create mode 100644 board/freescale/ls2080ardb/ls2080ardb.c
 create mode 100644 board/freescale/ls2080ardb/ls2080ardb_qixis.h
 delete mode 100644 board/freescale/ls2085a/Kconfig
 delete mode 100644 board/freescale/ls2085a/MAINTAINERS
 delete mode 100644 board/freescale/ls2085a/Makefile
 delete mode 100644 board/freescale/ls2085a/README
 delete mode 100644 board/freescale/ls2085a/ddr.c
 delete mode 100644 board/freescale/ls2085a/ddr.h
 delete mode 100644 board/freescale/ls2085a/ls2085a.c
 delete mode 100644 board/freescale/ls2085aqds/Kconfig
 delete mode 100644 board/freescale/ls2085aqds/MAINTAINERS
 delete mode 100644 board/freescale/ls2085aqds/Makefile
 delete mode 100644 board/freescale/ls2085aqds/README
 delete mode 100644 board/freescale/ls2085aqds/ddr.c
 delete mode 100644 board/freescale/ls2085aqds/ddr.h
 delete mode 100644 board/freescale/ls2085aqds/eth.c
 delete mode 100644 board/freescale/ls2085aqds/ls2085aqds.c
 delete mode 100644 board/freescale/ls2085aqds/ls2085aqds_qixis.h
 delete mode 100644 board/freescale/ls2085ardb/Kconfig
 delete mode 100644 board/freescale/ls2085ardb/MAINTAINERS
 delete mode 100644 board/freescale/ls2085ardb/Makefile
 delete mode 100644 board/freescale/ls2085ardb/README
 delete mode 100644 board/freescale/ls2085ardb/ddr.c
 delete mode 100644 board/freescale/ls2085ardb/ddr.h
 delete mode 100644 board/freescale/ls2085ardb/eth_ls2085rdb.c
 delete mode 100644 board/freescale/ls2085ardb/ls2085ardb.c
 delete mode 100644 board/freescale/ls2085ardb/ls2085ardb_qixis.h
 create mode 100644 configs/ls2080a_emu_defconfig
 create mode 100644 configs/ls2080a_simu_defconfig
 create mode 100644 configs/ls2080aqds_defconfig
 create mode 100644 configs/ls2080aqds_nand_defconfig
 create mode 100644 configs/ls2080ardb_defconfig
 create mode 100644 configs/ls2080ardb_nand_defconfig
 delete mode 100644 configs/ls2085a_emu_defconfig
 delete mode 100644 configs/ls2085a_simu_defconfig
 delete mode 100644 configs/ls2085aqds_defconfig
 delete mode 100644 configs/ls2085aqds_nand_defconfig
 delete mode 100644 configs/ls2085ardb_defconfig
 delete mode 100644 configs/ls2085ardb_nand_defconfig
 create mode 100644 drivers/net/ldpaa_eth/ls2080a.c
 delete mode 100644 drivers/net/ldpaa_eth/ls2085a.c
 create mode 100644 include/configs/ls2080a_common.h
 create mode 100644 include/configs/ls2080a_emu.h
 create mode 100644 include/configs/ls2080a_simu.h
 create mode 100644 include/configs/ls2080aqds.h
 create mode 100644 include/configs/ls2080ardb.h
 delete mode 100644 include/configs/ls2085a_common.h
 delete mode 100644 include/configs/ls2085a_emu.h
 delete mode 100644 include/configs/ls2085a_simu.h
 delete mode 100644 include/configs/ls2085aqds.h
 delete mode 100644 include/configs/ls2085ardb.h

diff --git a/README b/README
index 0dc657d..ac5371f 100644
--- a/README
+++ b/README
@@ -611,6 +611,9 @@ The following options need to be configured:
 		CONFIG_SYS_FSL_OTHER_DDR_NUM_CTRLS
 		Number of controllers used for other than main memory.
 
+		CONFIG_SYS_FSL_HAS_DP_DDR
+		Defines the SoC has DP-DDR used for DPAA.
+
 		CONFIG_SYS_FSL_SEC_BE
 		Defines the SEC controller register space as Big Endian
 
diff --git a/arch/arm/Kconfig b/arch/arm/Kconfig
index 8f2229d..bbc8f36 100644
--- a/arch/arm/Kconfig
+++ b/arch/arm/Kconfig
@@ -580,36 +580,46 @@ config TARGET_VEXPRESS64_JUNO
 	bool "Support Versatile Express Juno Development Platform"
 	select ARM64
 
-config TARGET_LS2085A_EMU
-	bool "Support ls2085a_emu"
+config TARGET_LS2080A_EMU
+	bool "Support ls2080a_emu"
 	select ARM64
 	select ARMV8_MULTIENTRY
+	help
+	  Support for Freescale LS2080A_EMU platform
+	  The LS2080A Development System (EMULATOR) is a pre silicon
+	  development platform that supports the QorIQ LS2080A
+	  Layerscape Architecture processor.
 
-config TARGET_LS2085A_SIMU
-	bool "Support ls2085a_simu"
+config TARGET_LS2080A_SIMU
+	bool "Support ls2080a_simu"
 	select ARM64
 	select ARMV8_MULTIENTRY
+	help
+	  Support for Freescale LS2080A_SIMU platform
+	  The LS2080A Development System (QDS) is a pre silicon
+	  development platform that supports the QorIQ LS2080A
+	  Layerscape Architecture processor.
 
-config TARGET_LS2085AQDS
-	bool "Support ls2085aqds"
+config TARGET_LS2080AQDS
+	bool "Support ls2080aqds"
 	select ARM64
 	select ARMV8_MULTIENTRY
 	select SUPPORT_SPL
 	help
-	  Support for Freescale LS2085AQDS platform
-	  The LS2085A Development System (QDS) is a high-performance
-	  development platform that supports the QorIQ LS2085A
+	  Support for Freescale LS2080AQDS platform
+	  The LS2080A Development System (QDS) is a high-performance
+	  development platform that supports the QorIQ LS2080A
 	  Layerscape Architecture processor.
 
-config TARGET_LS2085ARDB
-	bool "Support ls2085ardb"
+config TARGET_LS2080ARDB
+	bool "Support ls2080ardb"
 	select ARM64
 	select ARMV8_MULTIENTRY
 	select SUPPORT_SPL
 	help
-	  Support for Freescale LS2085ARDB platform.
-	  The LS2085A Reference design board (RDB) is a high-performance
-	  development platform that supports the QorIQ LS2085A
+	  Support for Freescale LS2080ARDB platform.
+	  The LS2080A Reference design board (RDB) is a high-performance
+	  development platform that supports the QorIQ LS2080A
 	  Layerscape Architecture processor.
 
 config TARGET_HIKEY
@@ -747,9 +757,9 @@ source "board/compulab/cm_t43/Kconfig"
 source "board/creative/xfi3/Kconfig"
 source "board/denx/m28evk/Kconfig"
 source "board/denx/m53evk/Kconfig"
-source "board/freescale/ls2085a/Kconfig"
-source "board/freescale/ls2085aqds/Kconfig"
-source "board/freescale/ls2085ardb/Kconfig"
+source "board/freescale/ls2080a/Kconfig"
+source "board/freescale/ls2080aqds/Kconfig"
+source "board/freescale/ls2080ardb/Kconfig"
 source "board/freescale/ls1021aqds/Kconfig"
 source "board/freescale/ls1021atwr/Kconfig"
 source "board/freescale/ls1043ardb/Kconfig"
diff --git a/arch/arm/cpu/armv8/fsl-layerscape/Makefile b/arch/arm/cpu/armv8/fsl-layerscape/Makefile
index 6fa08c8..1beb426 100644
--- a/arch/arm/cpu/armv8/fsl-layerscape/Makefile
+++ b/arch/arm/cpu/armv8/fsl-layerscape/Makefile
@@ -21,8 +21,8 @@ obj-$(CONFIG_SYS_HAS_SERDES) += fsl_lsch2_serdes.o
 endif
 endif
 
-ifneq ($(CONFIG_LS2085A),)
-obj-$(CONFIG_SYS_HAS_SERDES) += ls2085a_serdes.o
+ifneq ($(CONFIG_LS2080A),)
+obj-$(CONFIG_SYS_HAS_SERDES) += ls2080a_serdes.o
 else
 ifneq ($(CONFIG_LS1043A),)
 obj-$(CONFIG_SYS_HAS_SERDES) += ls1043a_serdes.o
diff --git a/arch/arm/cpu/armv8/fsl-layerscape/README.lsch3 b/arch/arm/cpu/armv8/fsl-layerscape/README.lsch3
index 417cf6d..db9359d 100644
--- a/arch/arm/cpu/armv8/fsl-layerscape/README.lsch3
+++ b/arch/arm/cpu/armv8/fsl-layerscape/README.lsch3
@@ -7,7 +7,7 @@
 Freescale LayerScape with Chassis Generation 3
 
 This architecture supports Freescale ARMv8 SoCs with Chassis generation 3,
-for example LS2085A.
+for example LS2080A.
 
 DDR Layout
 ============
@@ -152,7 +152,7 @@ u-boot command
 nand write <rcw image in memory> 0 <size of rcw image>
 
 To form the NAND image, build u-boot with NAND config, for example,
-ls2085aqds_nand_defconfig. The image needed is u-boot-with-spl.bin.
+ls2080aqds_nand_defconfig. The image needed is u-boot-with-spl.bin.
 The u-boot image should be written to match SRC_ADDR, in above example 0x20000.
 
 nand write <u-boot image in memory> 200000 <size of u-boot image>
diff --git a/arch/arm/cpu/armv8/fsl-layerscape/cpu.c b/arch/arm/cpu/armv8/fsl-layerscape/cpu.c
index 0cb0afa..c6e00b8 100644
--- a/arch/arm/cpu/armv8/fsl-layerscape/cpu.c
+++ b/arch/arm/cpu/armv8/fsl-layerscape/cpu.c
@@ -438,7 +438,7 @@ int print_cpuinfo(void)
 #ifdef CONFIG_SYS_DPAA_FMAN
 	printf("  FMAN:     %-4s MHz", strmhz(buf, sysinfo.freq_fman[0]));
 #endif
-#ifdef CONFIG_FSL_LSCH3
+#ifdef CONFIG_SYS_FSL_HAS_DP_DDR
 	printf("     DP-DDR:   %-4s MT/s", strmhz(buf, sysinfo.freq_ddrbus2));
 #endif
 	puts("\n");
diff --git a/arch/arm/cpu/armv8/fsl-layerscape/fdt.c b/arch/arm/cpu/armv8/fsl-layerscape/fdt.c
index dfde433..fe451a6 100644
--- a/arch/arm/cpu/armv8/fsl-layerscape/fdt.c
+++ b/arch/arm/cpu/armv8/fsl-layerscape/fdt.c
@@ -144,7 +144,7 @@ void append_mmu_masters(void *blob, const char *smmu_path,
 
 /*
  * The info below summarizes how streamID partitioning works
- * for ls2085a and how it is conveyed to the OS via the device tree.
+ * for ls2080a and how it is conveyed to the OS via the device tree.
  *
  *  -non-PCI legacy, platform devices (USB, SD/MMC, SATA, DMA)
  *     -all legacy devices get a unique ICID assigned and programmed in
diff --git a/arch/arm/cpu/armv8/fsl-layerscape/fsl_lsch3_speed.c b/arch/arm/cpu/armv8/fsl-layerscape/fsl_lsch3_speed.c
index 4054c3c..81cf470 100644
--- a/arch/arm/cpu/armv8/fsl-layerscape/fsl_lsch3_speed.c
+++ b/arch/arm/cpu/armv8/fsl-layerscape/fsl_lsch3_speed.c
@@ -11,6 +11,7 @@
 #include <fsl_ifc.h>
 #include <asm/processor.h>
 #include <asm/io.h>
+#include <asm/arch-fsl-layerscape/immap_lsch3.h>
 #include <asm/arch/clock.h>
 #include <asm/arch/soc.h>
 #include "cpu.h"
@@ -77,11 +78,15 @@ void get_sys_info(struct sys_info *sys_info)
 	sys_info->freq_systembus = sysclk;
 #ifdef CONFIG_DDR_CLK_FREQ
 	sys_info->freq_ddrbus = CONFIG_DDR_CLK_FREQ;
+#ifdef CONFIG_SYS_FSL_HAS_DP_DDR
 	sys_info->freq_ddrbus2 = CONFIG_DDR_CLK_FREQ;
+#endif
 #else
 	sys_info->freq_ddrbus = sysclk;
+#ifdef CONFIG_SYS_FSL_HAS_DP_DDR
 	sys_info->freq_ddrbus2 = sysclk;
 #endif
+#endif
 
 	sys_info->freq_systembus *= (gur_in32(&gur->rcwsr[0]) >>
 			FSL_CHASSIS3_RCWSR0_SYS_PLL_RAT_SHIFT) &
@@ -91,9 +96,11 @@ void get_sys_info(struct sys_info *sys_info)
 	sys_info->freq_ddrbus *= (gur_in32(&gur->rcwsr[0]) >>
 			FSL_CHASSIS3_RCWSR0_MEM_PLL_RAT_SHIFT) &
 			FSL_CHASSIS3_RCWSR0_MEM_PLL_RAT_MASK;
+#ifdef CONFIG_SYS_FSL_HAS_DP_DDR
 	sys_info->freq_ddrbus2 *= (gur_in32(&gur->rcwsr[0]) >>
 			FSL_CHASSIS3_RCWSR0_MEM2_PLL_RAT_SHIFT) &
 			FSL_CHASSIS3_RCWSR0_MEM2_PLL_RAT_MASK;
+#endif
 
 	for (i = 0; i < CONFIG_SYS_FSL_NUM_CC_PLLS; i++) {
 		/*
@@ -133,7 +140,9 @@ int get_clocks(void)
 	gd->cpu_clk = sys_info.freq_processor[0];
 	gd->bus_clk = sys_info.freq_systembus;
 	gd->mem_clk = sys_info.freq_ddrbus;
+#ifdef CONFIG_SYS_FSL_HAS_DP_DDR
 	gd->arch.mem2_clk = sys_info.freq_ddrbus2;
+#endif
 #if defined(CONFIG_FSL_ESDHC)
 	gd->arch.sdhc_clk = gd->bus_clk / 2;
 #endif /* defined(CONFIG_FSL_ESDHC) */
@@ -169,8 +178,10 @@ ulong get_ddr_freq(ulong ctrl_num)
 	 * DDR controller 0 & 1 are on memory complex 0
 	 * DDR controler 2 is on memory complext 1
 	 */
+#ifdef CONFIG_SYS_FSL_HAS_DP_DDR
 	if (ctrl_num >= 2)
 		return gd->arch.mem2_clk;
+#endif
 
 	return gd->mem_clk;
 }
diff --git a/arch/arm/cpu/armv8/fsl-layerscape/ls2080a_serdes.c b/arch/arm/cpu/armv8/fsl-layerscape/ls2080a_serdes.c
new file mode 100644
index 0000000..ea3114c
--- /dev/null
+++ b/arch/arm/cpu/armv8/fsl-layerscape/ls2080a_serdes.c
@@ -0,0 +1,116 @@
+/*
+ * Copyright 2014-2015 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <asm/arch/fsl_serdes.h>
+
+struct serdes_config {
+	u8 protocol;
+	u8 lanes[SRDS_MAX_LANES];
+};
+
+static struct serdes_config serdes1_cfg_tbl[] = {
+	/* SerDes 1 */
+	{0x03, {PCIE1, PCIE1, PCIE1, PCIE1, PCIE2, PCIE2, PCIE2, PCIE2 } },
+	{0x05, {PCIE2, PCIE2, PCIE2, PCIE2, SGMII4, SGMII3, SGMII2, SGMII1 } },
+	{0x07, {SGMII8, SGMII7, SGMII6, SGMII5, SGMII4, SGMII3, SGMII2,
+		SGMII1 } },
+	{0x09, {SGMII8, SGMII7, SGMII6, SGMII5, SGMII4, SGMII3, SGMII2,
+		SGMII1 } },
+	{0x0A, {SGMII8, SGMII7, SGMII6, SGMII5, SGMII4, SGMII3, SGMII2,
+		SGMII1 } },
+	{0x0C, {SGMII8, SGMII7, SGMII6, SGMII5, SGMII4, SGMII3, SGMII2,
+		SGMII1 } },
+	{0x0E, {SGMII8, SGMII7, SGMII6, SGMII5, SGMII4, SGMII3, SGMII2,
+		SGMII1 } },
+	{0x26, {SGMII8, SGMII7, SGMII6, SGMII5, SGMII4, SGMII3, XFI2, XFI1 } },
+	{0x28, {SGMII8, SGMII7, SGMII6, SGMII5, XFI4, XFI3, XFI2, XFI1 } },
+	{0x2A, {XFI8, XFI7, XFI6, XFI5, XFI4, XFI3, XFI2, XFI1 } },
+	{0x2B, {SGMII8, SGMII7, SGMII6, SGMII5, XAUI1, XAUI1, XAUI1, XAUI1  } },
+	{0x32, {XAUI2, XAUI2, XAUI2, XAUI2, XAUI1, XAUI1, XAUI1, XAUI1  } },
+	{0x33, {PCIE2, PCIE2, PCIE2, PCIE2, QSGMII_C, QSGMII_D, QSGMII_A,
+		QSGMII_B} },
+	{0x35, {QSGMII_C, QSGMII_D, QSGMII_A, PCIE2, XFI4, XFI3, XFI2, XFI1 } },
+		{}
+};
+static struct serdes_config serdes2_cfg_tbl[] = {
+	/* SerDes 2 */
+	{0x07, {SGMII9, SGMII10, SGMII11, SGMII12, SGMII13, SGMII14, SGMII15,
+		SGMII16 } },
+	{0x09, {SGMII9, SGMII10, SGMII11, SGMII12, SGMII13, SGMII14, SGMII15,
+		SGMII16 } },
+	{0x0A, {SGMII9, SGMII10, SGMII11, SGMII12, SGMII13, SGMII14, SGMII15,
+		SGMII16 } },
+	{0x0C, {SGMII9, SGMII10, SGMII11, SGMII12, SGMII13, SGMII14, SGMII15,
+		SGMII16 } },
+	{0x0E, {SGMII9, SGMII10, SGMII11, SGMII12, SGMII13, SGMII14, SGMII15,
+		SGMII16 } },
+	{0x3D, {PCIE3, PCIE3, PCIE3, PCIE3, PCIE3, PCIE3, PCIE3, PCIE3 } },
+	{0x3E, {PCIE3, PCIE3, PCIE3, PCIE3, PCIE3, PCIE3, PCIE3, PCIE3 } },
+	{0x3F, {PCIE3, PCIE3, PCIE3, PCIE3, PCIE4, PCIE4, PCIE4, PCIE4 } },
+	{0x40, {PCIE3, PCIE3, PCIE3, PCIE3, PCIE4, PCIE4, PCIE4, PCIE4 } },
+	{0x41, {PCIE3, PCIE3, PCIE3, PCIE3, PCIE4, PCIE4, SATA1, SATA2 } },
+	{0x42, {PCIE3, PCIE3, PCIE3, PCIE3, PCIE4, PCIE4, SATA1, SATA2 } },
+	{0x43, {PCIE3, PCIE3, PCIE3, PCIE3, NONE, NONE, SATA1, SATA2 } },
+	{0x44, {PCIE3, PCIE3, PCIE3, PCIE3, NONE, NONE, SATA1, SATA2 } },
+	{0x45, {PCIE3, SGMII10, SGMII11, SGMII12, PCIE4, SGMII14, SGMII15,
+		SGMII16 } },
+	{0x47, {SGMII9, SGMII10, SGMII11, SGMII12, PCIE4, PCIE4, PCIE4,
+		PCIE4 } },
+	{0x49, {SGMII9, SGMII10, SGMII11, SGMII12, PCIE4, PCIE4, SATA1,
+		SATA2 } },
+	{0x4A, {SGMII9, SGMII10, SGMII11, SGMII12, PCIE4, PCIE4, SATA1,
+		SATA2 } },
+	{}
+};
+
+static struct serdes_config *serdes_cfg_tbl[] = {
+	serdes1_cfg_tbl,
+	serdes2_cfg_tbl,
+};
+
+enum srds_prtcl serdes_get_prtcl(int serdes, int cfg, int lane)
+{
+	struct serdes_config *ptr;
+
+	if (serdes >= ARRAY_SIZE(serdes_cfg_tbl))
+		return 0;
+
+	ptr = serdes_cfg_tbl[serdes];
+	while (ptr->protocol) {
+		if (ptr->protocol == cfg)
+			return ptr->lanes[lane];
+		ptr++;
+	}
+
+	return 0;
+}
+
+int is_serdes_prtcl_valid(int serdes, u32 prtcl)
+{
+	int i;
+	struct serdes_config *ptr;
+
+	if (serdes >= ARRAY_SIZE(serdes_cfg_tbl))
+		return 0;
+
+	ptr = serdes_cfg_tbl[serdes];
+	while (ptr->protocol) {
+		if (ptr->protocol == prtcl)
+			break;
+		ptr++;
+	}
+
+	if (!ptr->protocol)
+		return 0;
+
+	for (i = 0; i < SRDS_MAX_LANES; i++) {
+		if (ptr->lanes[i] != NONE)
+			return 1;
+	}
+
+	return 0;
+}
diff --git a/arch/arm/cpu/armv8/fsl-layerscape/ls2085a_serdes.c b/arch/arm/cpu/armv8/fsl-layerscape/ls2085a_serdes.c
deleted file mode 100644
index ea3114c..0000000
--- a/arch/arm/cpu/armv8/fsl-layerscape/ls2085a_serdes.c
+++ /dev/null
@@ -1,116 +0,0 @@
-/*
- * Copyright 2014-2015 Freescale Semiconductor, Inc.
- *
- * SPDX-License-Identifier:	GPL-2.0+
- */
-
-#include <common.h>
-#include <asm/arch/fsl_serdes.h>
-
-struct serdes_config {
-	u8 protocol;
-	u8 lanes[SRDS_MAX_LANES];
-};
-
-static struct serdes_config serdes1_cfg_tbl[] = {
-	/* SerDes 1 */
-	{0x03, {PCIE1, PCIE1, PCIE1, PCIE1, PCIE2, PCIE2, PCIE2, PCIE2 } },
-	{0x05, {PCIE2, PCIE2, PCIE2, PCIE2, SGMII4, SGMII3, SGMII2, SGMII1 } },
-	{0x07, {SGMII8, SGMII7, SGMII6, SGMII5, SGMII4, SGMII3, SGMII2,
-		SGMII1 } },
-	{0x09, {SGMII8, SGMII7, SGMII6, SGMII5, SGMII4, SGMII3, SGMII2,
-		SGMII1 } },
-	{0x0A, {SGMII8, SGMII7, SGMII6, SGMII5, SGMII4, SGMII3, SGMII2,
-		SGMII1 } },
-	{0x0C, {SGMII8, SGMII7, SGMII6, SGMII5, SGMII4, SGMII3, SGMII2,
-		SGMII1 } },
-	{0x0E, {SGMII8, SGMII7, SGMII6, SGMII5, SGMII4, SGMII3, SGMII2,
-		SGMII1 } },
-	{0x26, {SGMII8, SGMII7, SGMII6, SGMII5, SGMII4, SGMII3, XFI2, XFI1 } },
-	{0x28, {SGMII8, SGMII7, SGMII6, SGMII5, XFI4, XFI3, XFI2, XFI1 } },
-	{0x2A, {XFI8, XFI7, XFI6, XFI5, XFI4, XFI3, XFI2, XFI1 } },
-	{0x2B, {SGMII8, SGMII7, SGMII6, SGMII5, XAUI1, XAUI1, XAUI1, XAUI1  } },
-	{0x32, {XAUI2, XAUI2, XAUI2, XAUI2, XAUI1, XAUI1, XAUI1, XAUI1  } },
-	{0x33, {PCIE2, PCIE2, PCIE2, PCIE2, QSGMII_C, QSGMII_D, QSGMII_A,
-		QSGMII_B} },
-	{0x35, {QSGMII_C, QSGMII_D, QSGMII_A, PCIE2, XFI4, XFI3, XFI2, XFI1 } },
-		{}
-};
-static struct serdes_config serdes2_cfg_tbl[] = {
-	/* SerDes 2 */
-	{0x07, {SGMII9, SGMII10, SGMII11, SGMII12, SGMII13, SGMII14, SGMII15,
-		SGMII16 } },
-	{0x09, {SGMII9, SGMII10, SGMII11, SGMII12, SGMII13, SGMII14, SGMII15,
-		SGMII16 } },
-	{0x0A, {SGMII9, SGMII10, SGMII11, SGMII12, SGMII13, SGMII14, SGMII15,
-		SGMII16 } },
-	{0x0C, {SGMII9, SGMII10, SGMII11, SGMII12, SGMII13, SGMII14, SGMII15,
-		SGMII16 } },
-	{0x0E, {SGMII9, SGMII10, SGMII11, SGMII12, SGMII13, SGMII14, SGMII15,
-		SGMII16 } },
-	{0x3D, {PCIE3, PCIE3, PCIE3, PCIE3, PCIE3, PCIE3, PCIE3, PCIE3 } },
-	{0x3E, {PCIE3, PCIE3, PCIE3, PCIE3, PCIE3, PCIE3, PCIE3, PCIE3 } },
-	{0x3F, {PCIE3, PCIE3, PCIE3, PCIE3, PCIE4, PCIE4, PCIE4, PCIE4 } },
-	{0x40, {PCIE3, PCIE3, PCIE3, PCIE3, PCIE4, PCIE4, PCIE4, PCIE4 } },
-	{0x41, {PCIE3, PCIE3, PCIE3, PCIE3, PCIE4, PCIE4, SATA1, SATA2 } },
-	{0x42, {PCIE3, PCIE3, PCIE3, PCIE3, PCIE4, PCIE4, SATA1, SATA2 } },
-	{0x43, {PCIE3, PCIE3, PCIE3, PCIE3, NONE, NONE, SATA1, SATA2 } },
-	{0x44, {PCIE3, PCIE3, PCIE3, PCIE3, NONE, NONE, SATA1, SATA2 } },
-	{0x45, {PCIE3, SGMII10, SGMII11, SGMII12, PCIE4, SGMII14, SGMII15,
-		SGMII16 } },
-	{0x47, {SGMII9, SGMII10, SGMII11, SGMII12, PCIE4, PCIE4, PCIE4,
-		PCIE4 } },
-	{0x49, {SGMII9, SGMII10, SGMII11, SGMII12, PCIE4, PCIE4, SATA1,
-		SATA2 } },
-	{0x4A, {SGMII9, SGMII10, SGMII11, SGMII12, PCIE4, PCIE4, SATA1,
-		SATA2 } },
-	{}
-};
-
-static struct serdes_config *serdes_cfg_tbl[] = {
-	serdes1_cfg_tbl,
-	serdes2_cfg_tbl,
-};
-
-enum srds_prtcl serdes_get_prtcl(int serdes, int cfg, int lane)
-{
-	struct serdes_config *ptr;
-
-	if (serdes >= ARRAY_SIZE(serdes_cfg_tbl))
-		return 0;
-
-	ptr = serdes_cfg_tbl[serdes];
-	while (ptr->protocol) {
-		if (ptr->protocol == cfg)
-			return ptr->lanes[lane];
-		ptr++;
-	}
-
-	return 0;
-}
-
-int is_serdes_prtcl_valid(int serdes, u32 prtcl)
-{
-	int i;
-	struct serdes_config *ptr;
-
-	if (serdes >= ARRAY_SIZE(serdes_cfg_tbl))
-		return 0;
-
-	ptr = serdes_cfg_tbl[serdes];
-	while (ptr->protocol) {
-		if (ptr->protocol == prtcl)
-			break;
-		ptr++;
-	}
-
-	if (!ptr->protocol)
-		return 0;
-
-	for (i = 0; i < SRDS_MAX_LANES; i++) {
-		if (ptr->lanes[i] != NONE)
-			return 1;
-	}
-
-	return 0;
-}
diff --git a/arch/arm/cpu/armv8/fsl-layerscape/soc.c b/arch/arm/cpu/armv8/fsl-layerscape/soc.c
index 637853d..b02e28a 100644
--- a/arch/arm/cpu/armv8/fsl-layerscape/soc.c
+++ b/arch/arm/cpu/armv8/fsl-layerscape/soc.c
@@ -12,7 +12,7 @@
 
 DECLARE_GLOBAL_DATA_PTR;
 
-#ifdef CONFIG_LS2085A
+#ifdef CONFIG_LS2080A
 static void erratum_a008751(void)
 {
 #ifdef CONFIG_SYS_FSL_ERRATUM_A008751
diff --git a/arch/arm/cpu/armv8/fsl-layerscape/spl.c b/arch/arm/cpu/armv8/fsl-layerscape/spl.c
index 2f30d4b..fd895ff 100644
--- a/arch/arm/cpu/armv8/fsl-layerscape/spl.c
+++ b/arch/arm/cpu/armv8/fsl-layerscape/spl.c
@@ -48,7 +48,7 @@ void board_init_f(ulong dummy)
 	gd = &gdata;
 	/* Clear global data */
 	memset((void *)gd, 0, sizeof(gd_t));
-#ifdef CONFIG_LS2085A
+#ifdef CONFIG_LS2080A
 	arch_cpu_init();
 #endif
 #ifdef CONFIG_FSL_IFC
@@ -56,7 +56,7 @@ void board_init_f(ulong dummy)
 #endif
 	board_early_init_f();
 	timer_init();
-#ifdef CONFIG_LS2085A
+#ifdef CONFIG_LS2080A
 	env_init();
 #endif
 	get_clocks();
diff --git a/arch/arm/dts/Makefile b/arch/arm/dts/Makefile
index 53fecb5..3066fa4 100644
--- a/arch/arm/dts/Makefile
+++ b/arch/arm/dts/Makefile
@@ -74,8 +74,8 @@ dtb-$(CONFIG_TARGET_STV0991) += stv0991.dtb
 
 dtb-$(CONFIG_LS102XA) += ls1021a-qds.dtb \
 	ls1021a-twr.dtb
-dtb-$(CONFIG_FSL_LSCH3) += fsl-ls2085a-qds.dtb \
-	fsl-ls2085a-rdb.dtb
+dtb-$(CONFIG_FSL_LSCH3) += fsl-ls2080a-qds.dtb \
+	fsl-ls2080a-rdb.dtb
 dtb-$(CONFIG_FSL_LSCH2) += fsl-ls1043a-rdb.dtb
 
 dtb-$(CONFIG_MACH_SUN4I) += \
diff --git a/arch/arm/dts/fsl-ls2080a-qds.dts b/arch/arm/dts/fsl-ls2080a-qds.dts
new file mode 100644
index 0000000..547ec27
--- /dev/null
+++ b/arch/arm/dts/fsl-ls2080a-qds.dts
@@ -0,0 +1,53 @@
+/*
+ * Freescale ls2080a QDS board device tree source
+ *
+ * Copyright 2013-2015 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+/dts-v1/;
+
+#include "fsl-ls2080a.dtsi"
+
+/ {
+	model = "Freescale Layerscape 2080a QDS Board";
+	compatible = "fsl,ls2080a-qds", "fsl,ls2080a";
+
+	aliases {
+		spi1 = &dspi;
+	};
+};
+
+&dspi {
+	bus-num = <0>;
+	status = "okay";
+
+	dflash0: n25q128a {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		compatible = "spi-flash";
+		spi-max-frequency = <3000000>;
+		spi-cpol;
+		spi-cpha;
+		reg = <0>;
+	};
+	dflash1: sst25wf040b {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		compatible = "spi-flash";
+		spi-max-frequency = <3000000>;
+		spi-cpol;
+		spi-cpha;
+		reg = <1>;
+	};
+	dflash2: en25s64 {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		compatible = "spi-flash";
+		spi-max-frequency = <3000000>;
+		spi-cpol;
+		spi-cpha;
+		reg = <2>;
+	};
+};
diff --git a/arch/arm/dts/fsl-ls2080a-rdb.dts b/arch/arm/dts/fsl-ls2080a-rdb.dts
new file mode 100644
index 0000000..1a1813b
--- /dev/null
+++ b/arch/arm/dts/fsl-ls2080a-rdb.dts
@@ -0,0 +1,35 @@
+/*
+ * Freescale ls2080a RDB board device tree source
+ *
+ * Copyright 2013-2015 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+/dts-v1/;
+
+#include "fsl-ls2080a.dtsi"
+
+/ {
+	model = "Freescale Layerscape 2080a RDB Board";
+	compatible = "fsl,ls2080a-rdb", "fsl,ls2080a";
+
+	aliases {
+		spi1 = &dspi;
+	};
+};
+
+&dspi {
+	bus-num = <0>;
+	status = "okay";
+
+	dflash0: n25q512a {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		compatible = "spi-flash";
+		spi-max-frequency = <3000000>;
+		spi-cpol;
+		spi-cpha;
+		reg = <0>;
+	};
+};
diff --git a/arch/arm/dts/fsl-ls2080a.dtsi b/arch/arm/dts/fsl-ls2080a.dtsi
new file mode 100644
index 0000000..a5c579c
--- /dev/null
+++ b/arch/arm/dts/fsl-ls2080a.dtsi
@@ -0,0 +1,129 @@
+/*
+ * Freescale ls2080a SOC common device tree source
+ *
+ * Copyright 2013-2015 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+/ {
+	compatible = "fsl,ls2080a";
+	interrupt-parent = <&gic>;
+	#address-cells = <2>;
+	#size-cells = <2>;
+
+	cpus {
+		#address-cells = <2>;
+		#size-cells = <0>;
+
+		/*
+		 * We expect the enable-method for cpu's to be "psci", but this
+		 * is dependent on the SoC FW, which will fill this in.
+		 *
+		 * Currently supported enable-method is psci v0.2
+		 */
+
+		/* We have 4 clusters having 2 Cortex-A57 cores each */
+		cpu@0 {
+			device_type = "cpu";
+			compatible = "arm,cortex-a57";
+			reg = <0x0 0x0>;
+		};
+
+		cpu@1 {
+			device_type = "cpu";
+			compatible = "arm,cortex-a57";
+			reg = <0x0 0x1>;
+		};
+
+		cpu@100 {
+			device_type = "cpu";
+			compatible = "arm,cortex-a57";
+			reg = <0x0 0x100>;
+		};
+
+		cpu@101 {
+			device_type = "cpu";
+			compatible = "arm,cortex-a57";
+			reg = <0x0 0x101>;
+		};
+
+		cpu@200 {
+			device_type = "cpu";
+			compatible = "arm,cortex-a57";
+			reg = <0x0 0x200>;
+		};
+
+		cpu@201 {
+			device_type = "cpu";
+			compatible = "arm,cortex-a57";
+			reg = <0x0 0x201>;
+		};
+
+		cpu@300 {
+			device_type = "cpu";
+			compatible = "arm,cortex-a57";
+			reg = <0x0 0x300>;
+		};
+
+		cpu@301 {
+			device_type = "cpu";
+			compatible = "arm,cortex-a57";
+			reg = <0x0 0x301>;
+		};
+	};
+
+	memory@80000000 {
+		device_type = "memory";
+		reg = <0x00000000 0x80000000 0 0x80000000>;
+		      /* DRAM space - 1, size : 2 GB DRAM */
+	};
+
+	gic: interrupt-controller@6000000 {
+		compatible = "arm,gic-v3";
+		reg = <0x0 0x06000000 0 0x10000>, /* GIC Dist */
+		      <0x0 0x06100000 0 0x100000>; /* GICR (RD_base + SGI_base) */
+		#interrupt-cells = <3>;
+		interrupt-controller;
+		interrupts = <1 9 0x4>;
+	};
+
+	timer {
+		compatible = "arm,armv8-timer";
+		interrupts = <1 13 0x8>, /* Physical Secure PPI, active-low */
+			     <1 14 0x8>, /* Physical Non-Secure PPI, active-low */
+			     <1 11 0x8>, /* Virtual PPI, active-low */
+			     <1 10 0x8>; /* Hypervisor PPI, active-low */
+	};
+
+	serial0: serial@21c0500 {
+		device_type = "serial";
+		compatible = "fsl,ns16550", "ns16550a";
+		reg = <0x0 0x21c0500 0x0 0x100>;
+		clock-frequency = <0>;	/* Updated by bootloader */
+		interrupts = <0 32 0x1>; /* edge triggered */
+	};
+
+	serial1: serial@21c0600 {
+		device_type = "serial";
+		compatible = "fsl,ns16550", "ns16550a";
+		reg = <0x0 0x21c0600 0x0 0x100>;
+		clock-frequency = <0>; 	/* Updated by bootloader */
+		interrupts = <0 32 0x1>; /* edge triggered */
+	};
+
+	fsl_mc: fsl-mc@80c000000 {
+		compatible = "fsl,qoriq-mc";
+		reg = <0x00000008 0x0c000000 0 0x40>,	 /* MC portal base */
+		      <0x00000000 0x08340000 0 0x40000>; /* MC control reg */
+	};
+
+	dspi: dspi@2100000 {
+		compatible = "fsl,vf610-dspi";
+		#address-cells = <1>;
+		#size-cells = <0>;
+		reg = <0x0 0x2100000 0x0 0x10000>;
+		interrupts = <0 26 0x4>; /* Level high type */
+		num-cs = <6>;
+	};
+};
diff --git a/arch/arm/dts/fsl-ls2085a-qds.dts b/arch/arm/dts/fsl-ls2085a-qds.dts
deleted file mode 100644
index 4477e54..0000000
--- a/arch/arm/dts/fsl-ls2085a-qds.dts
+++ /dev/null
@@ -1,53 +0,0 @@
-/*
- * Freescale ls2085a QDS board device tree source
- *
- * Copyright 2013-2015 Freescale Semiconductor, Inc.
- *
- * SPDX-License-Identifier:	GPL-2.0+
- */
-
-/dts-v1/;
-
-#include "fsl-ls2085a.dtsi"
-
-/ {
-	model = "Freescale Layerscape 2085a QDS Board";
-	compatible = "fsl,ls2085a-qds", "fsl,ls2085a";
-
-	aliases {
-		spi1 = &dspi;
-	};
-};
-
-&dspi {
-	bus-num = <0>;
-	status = "okay";
-
-	dflash0: n25q128a {
-		#address-cells = <1>;
-		#size-cells = <1>;
-		compatible = "spi-flash";
-		spi-max-frequency = <3000000>;
-		spi-cpol;
-		spi-cpha;
-		reg = <0>;
-	};
-	dflash1: sst25wf040b {
-		#address-cells = <1>;
-		#size-cells = <1>;
-		compatible = "spi-flash";
-		spi-max-frequency = <3000000>;
-		spi-cpol;
-		spi-cpha;
-		reg = <1>;
-	};
-	dflash2: en25s64 {
-		#address-cells = <1>;
-		#size-cells = <1>;
-		compatible = "spi-flash";
-		spi-max-frequency = <3000000>;
-		spi-cpol;
-		spi-cpha;
-		reg = <2>;
-	};
-};
diff --git a/arch/arm/dts/fsl-ls2085a-rdb.dts b/arch/arm/dts/fsl-ls2085a-rdb.dts
deleted file mode 100644
index 25278df..0000000
--- a/arch/arm/dts/fsl-ls2085a-rdb.dts
+++ /dev/null
@@ -1,35 +0,0 @@
-/*
- * Freescale ls2085a RDB board device tree source
- *
- * Copyright 2013-2015 Freescale Semiconductor, Inc.
- *
- * SPDX-License-Identifier:	GPL-2.0+
- */
-
-/dts-v1/;
-
-#include "fsl-ls2085a.dtsi"
-
-/ {
-	model = "Freescale Layerscape 2085a RDB Board";
-	compatible = "fsl,ls2085a-rdb", "fsl,ls2085a";
-
-	aliases {
-		spi1 = &dspi;
-	};
-};
-
-&dspi {
-	bus-num = <0>;
-	status = "okay";
-
-	dflash0: n25q512a {
-		#address-cells = <1>;
-		#size-cells = <1>;
-		compatible = "spi-flash";
-		spi-max-frequency = <3000000>;
-		spi-cpol;
-		spi-cpha;
-		reg = <0>;
-	};
-};
diff --git a/arch/arm/dts/fsl-ls2085a.dtsi b/arch/arm/dts/fsl-ls2085a.dtsi
deleted file mode 100644
index 96404c5..0000000
--- a/arch/arm/dts/fsl-ls2085a.dtsi
+++ /dev/null
@@ -1,129 +0,0 @@
-/*
- * Freescale ls2085a SOC common device tree source
- *
- * Copyright 2013-2015 Freescale Semiconductor, Inc.
- *
- * SPDX-License-Identifier:	GPL-2.0+
- */
-
-/ {
-	compatible = "fsl,ls2085a";
-	interrupt-parent = <&gic>;
-	#address-cells = <2>;
-	#size-cells = <2>;
-
-	cpus {
-		#address-cells = <2>;
-		#size-cells = <0>;
-
-		/*
-		 * We expect the enable-method for cpu's to be "psci", but this
-		 * is dependent on the SoC FW, which will fill this in.
-		 *
-		 * Currently supported enable-method is psci v0.2
-		 */
-
-		/* We have 4 clusters having 2 Cortex-A57 cores each */
-		cpu@0 {
-			device_type = "cpu";
-			compatible = "arm,cortex-a57";
-			reg = <0x0 0x0>;
-		};
-
-		cpu@1 {
-			device_type = "cpu";
-			compatible = "arm,cortex-a57";
-			reg = <0x0 0x1>;
-		};
-
-		cpu@100 {
-			device_type = "cpu";
-			compatible = "arm,cortex-a57";
-			reg = <0x0 0x100>;
-		};
-
-		cpu@101 {
-			device_type = "cpu";
-			compatible = "arm,cortex-a57";
-			reg = <0x0 0x101>;
-		};
-
-		cpu@200 {
-			device_type = "cpu";
-			compatible = "arm,cortex-a57";
-			reg = <0x0 0x200>;
-		};
-
-		cpu@201 {
-			device_type = "cpu";
-			compatible = "arm,cortex-a57";
-			reg = <0x0 0x201>;
-		};
-
-		cpu@300 {
-			device_type = "cpu";
-			compatible = "arm,cortex-a57";
-			reg = <0x0 0x300>;
-		};
-
-		cpu@301 {
-			device_type = "cpu";
-			compatible = "arm,cortex-a57";
-			reg = <0x0 0x301>;
-		};
-	};
-
-	memory@80000000 {
-		device_type = "memory";
-		reg = <0x00000000 0x80000000 0 0x80000000>;
-		      /* DRAM space - 1, size : 2 GB DRAM */
-	};
-
-	gic: interrupt-controller@6000000 {
-		compatible = "arm,gic-v3";
-		reg = <0x0 0x06000000 0 0x10000>, /* GIC Dist */
-		      <0x0 0x06100000 0 0x100000>; /* GICR (RD_base + SGI_base) */
-		#interrupt-cells = <3>;
-		interrupt-controller;
-		interrupts = <1 9 0x4>;
-	};
-
-	timer {
-		compatible = "arm,armv8-timer";
-		interrupts = <1 13 0x8>, /* Physical Secure PPI, active-low */
-			     <1 14 0x8>, /* Physical Non-Secure PPI, active-low */
-			     <1 11 0x8>, /* Virtual PPI, active-low */
-			     <1 10 0x8>; /* Hypervisor PPI, active-low */
-	};
-
-	serial0: serial@21c0500 {
-		device_type = "serial";
-		compatible = "fsl,ns16550", "ns16550a";
-		reg = <0x0 0x21c0500 0x0 0x100>;
-		clock-frequency = <0>;	/* Updated by bootloader */
-		interrupts = <0 32 0x1>; /* edge triggered */
-	};
-
-	serial1: serial@21c0600 {
-		device_type = "serial";
-		compatible = "fsl,ns16550", "ns16550a";
-		reg = <0x0 0x21c0600 0x0 0x100>;
-		clock-frequency = <0>; 	/* Updated by bootloader */
-		interrupts = <0 32 0x1>; /* edge triggered */
-	};
-
-	fsl_mc: fsl-mc@80c000000 {
-		compatible = "fsl,qoriq-mc";
-		reg = <0x00000008 0x0c000000 0 0x40>,	 /* MC portal base */
-		      <0x00000000 0x08340000 0 0x40000>; /* MC control reg */
-	};
-
-	dspi: dspi@2100000 {
-		compatible = "fsl,vf610-dspi";
-		#address-cells = <1>;
-		#size-cells = <0>;
-		reg = <0x0 0x2100000 0x0 0x10000>;
-		interrupts = <0 26 0x4>; /* Level high type */
-		num-cs = <6>;
-	};
-};
diff --git a/arch/arm/include/asm/arch-fsl-layerscape/config.h b/arch/arm/include/asm/arch-fsl-layerscape/config.h
index 87bb937..f79a0e8 100644
--- a/arch/arm/include/asm/arch-fsl-layerscape/config.h
+++ b/arch/arm/include/asm/arch-fsl-layerscape/config.h
@@ -17,10 +17,10 @@
 #define CONFIG_SYS_FSL_DDR		/* Freescale DDR driver */
 #define CONFIG_SYS_FSL_DDR_VER		FSL_DDR_VER_5_0
 
-#if defined(CONFIG_LS2085A)
+#if defined(CONFIG_LS2080A)
 #define CONFIG_MAX_CPUS				16
 #define CONFIG_SYS_FSL_IFC_BANK_COUNT		8
-#define CONFIG_NUM_DDR_CONTROLLERS		3
+#define CONFIG_NUM_DDR_CONTROLLERS		2
 #define CONFIG_SYS_FSL_CLUSTER_CLOCKS		{ 1, 1, 4, 4 }
 #define	SRDS_MAX_LANES	8
 #define CONFIG_SYS_FSL_SRDS_1
diff --git a/arch/arm/include/asm/arch-fsl-layerscape/cpu.h b/arch/arm/include/asm/arch-fsl-layerscape/cpu.h
index 2903996..0923f4d 100644
--- a/arch/arm/include/asm/arch-fsl-layerscape/cpu.h
+++ b/arch/arm/include/asm/arch-fsl-layerscape/cpu.h
@@ -8,8 +8,8 @@
 #define _FSL_LAYERSCAPE_CPU_H
 
 static struct cpu_type cpu_type_list[] = {
-	CPU_TYPE_ENTRY(LS2085, LS2085, 8),
 	CPU_TYPE_ENTRY(LS2080, LS2080, 8),
+	CPU_TYPE_ENTRY(LS2085, LS2085, 8),
 	CPU_TYPE_ENTRY(LS2045, LS2045, 4),
 	CPU_TYPE_ENTRY(LS1043, LS1043, 4),
 };
@@ -180,7 +180,7 @@ static const struct sys_mmu_table final_mmu_table[] = {
 	  CONFIG_SYS_PCIE2_PHYS_SIZE, MT_DEVICE_NGNRNE, PMD_SECT_NON_SHARE },
 	{ CONFIG_SYS_PCIE3_PHYS_ADDR, CONFIG_SYS_PCIE3_PHYS_ADDR,
 	  CONFIG_SYS_PCIE3_PHYS_SIZE, MT_DEVICE_NGNRNE, PMD_SECT_NON_SHARE },
-#ifdef CONFIG_LS2085A
+#ifdef CONFIG_LS2080A
 	{ CONFIG_SYS_PCIE4_PHYS_ADDR, CONFIG_SYS_PCIE4_PHYS_ADDR,
 	  CONFIG_SYS_PCIE4_PHYS_SIZE, MT_DEVICE_NGNRNE, PMD_SECT_NON_SHARE },
 #endif
diff --git a/arch/arm/include/asm/arch-fsl-layerscape/fsl_serdes.h b/arch/arm/include/asm/arch-fsl-layerscape/fsl_serdes.h
index e1043b5..4787eec 100644
--- a/arch/arm/include/asm/arch-fsl-layerscape/fsl_serdes.h
+++ b/arch/arm/include/asm/arch-fsl-layerscape/fsl_serdes.h
@@ -9,7 +9,7 @@
 
 #include <config.h>
 
-#if defined(CONFIG_LS2085A)
+#if defined(CONFIG_LS2080A)
 enum srds_prtcl {
 	NONE = 0,
 	PCIE1,
diff --git a/arch/arm/include/asm/arch-fsl-layerscape/immap_lsch3.h b/arch/arm/include/asm/arch-fsl-layerscape/immap_lsch3.h
index 6a70d44..134061c 100644
--- a/arch/arm/include/asm/arch-fsl-layerscape/immap_lsch3.h
+++ b/arch/arm/include/asm/arch-fsl-layerscape/immap_lsch3.h
@@ -51,8 +51,8 @@
 #define I2C3_BASE_ADDR				(CONFIG_SYS_IMMR + 0x01020000)
 #define I2C4_BASE_ADDR				(CONFIG_SYS_IMMR + 0x01030000)
 
-#define CONFIG_SYS_LS2085A_XHCI_USB1_ADDR	(CONFIG_SYS_IMMR + 0x02100000)
-#define CONFIG_SYS_LS2085A_XHCI_USB2_ADDR	(CONFIG_SYS_IMMR + 0x02110000)
+#define CONFIG_SYS_LS2080A_XHCI_USB1_ADDR	(CONFIG_SYS_IMMR + 0x02100000)
+#define CONFIG_SYS_LS2080A_XHCI_USB2_ADDR	(CONFIG_SYS_IMMR + 0x02110000)
 
 /* TZ Address Space Controller Definitions */
 #define TZASC1_BASE			0x01100000	/* as per CCSR map. */
@@ -115,7 +115,9 @@ struct sys_info {
 	unsigned long freq_processor[CONFIG_MAX_CPUS];
 	unsigned long freq_systembus;
 	unsigned long freq_ddrbus;
+#ifdef CONFIG_SYS_FSL_HAS_DP_DDR
 	unsigned long freq_ddrbus2;
+#endif
 	unsigned long freq_localbus;
 	unsigned long freq_qe;
 #ifdef CONFIG_SYS_DPAA_FMAN
diff --git a/arch/arm/include/asm/arch-fsl-layerscape/ls2080a_stream_id.h b/arch/arm/include/asm/arch-fsl-layerscape/ls2080a_stream_id.h
new file mode 100644
index 0000000..954104b
--- /dev/null
+++ b/arch/arm/include/asm/arch-fsl-layerscape/ls2080a_stream_id.h
@@ -0,0 +1,64 @@
+/*
+ * Copyright 2014 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ *
+ */
+#ifndef __FSL_STREAM_ID_H
+#define __FSL_STREAM_ID_H
+
+/* Stream IDs on ls2080a devices are not hardwired and are
+ * programmed by sw.  There are a limited number of stream IDs
+ * available, and the partitioning of them is scenario dependent.
+ * This header defines the partitioning between legacy, PCI,
+ * and DPAA2 devices.
+ *
+ * This partitiong can be customized in this file depending
+ * on the specific hardware config-- e.g. perhaps not all
+ * PEX controllers are in use.
+ *
+ * On LS2080 stream IDs are programmed in AMQ registers (32-bits) for
+ * each of the different bus masters.  The relationship between
+ * the AMQ registers and stream IDs is defined in the table below:
+ *          AMQ bit    streamID bit
+ *      ---------------------------
+ *           PL[18]         9
+ *          BMT[17]         8
+ *           VA[16]         7
+ *             [15]         -
+ *         ICID[14:7]       -
+ *         ICID[6:0]        6-0
+ *     ----------------------------
+ */
+
+#define AMQ_PL_MASK			(0x1 << 18)   /* priviledge bit */
+#define AMQ_BMT_MASK			(0x1 << 17)   /* bypass bit */
+
+#define FSL_INVALID_STREAM_ID		0
+
+#define FSL_BYPASS_AMQ			(AMQ_PL_MASK | AMQ_BMT_MASK)
+
+/* legacy devices */
+#define FSL_USB1_STREAM_ID		1
+#define FSL_USB2_STREAM_ID		2
+#define FSL_SDMMC_STREAM_ID		3
+#define FSL_SATA1_STREAM_ID		4
+#define FSL_SATA2_STREAM_ID		5
+#define FSL_DMA_STREAM_ID		6
+
+/* PCI - programmed in PEXn_LUT by OS */
+/*   4 IDs per controller */
+#define FSL_PEX1_STREAM_ID_START	7
+#define FSL_PEX1_STREAM_ID_END		10
+#define FSL_PEX2_STREAM_ID_START	11
+#define FSL_PEX2_STREAM_ID_END		14
+#define FSL_PEX3_STREAM_ID_START	15
+#define FSL_PEX3_STREAM_ID_END		18
+#define FSL_PEX4_STREAM_ID_START	19
+#define FSL_PEX4_STREAM_ID_END		22
+
+/* DPAA2 - set in MC DPC and alloced by MC */
+#define FSL_DPAA2_STREAM_ID_START	23
+#define FSL_DPAA2_STREAM_ID_END		63
+
+#endif
diff --git a/arch/arm/include/asm/arch-fsl-layerscape/ls2085a_stream_id.h b/arch/arm/include/asm/arch-fsl-layerscape/ls2085a_stream_id.h
deleted file mode 100644
index 5c94530..0000000
--- a/arch/arm/include/asm/arch-fsl-layerscape/ls2085a_stream_id.h
+++ /dev/null
@@ -1,64 +0,0 @@
-/*
- * Copyright 2014 Freescale Semiconductor, Inc.
- *
- * SPDX-License-Identifier:	GPL-2.0+
- *
- */
-#ifndef __FSL_STREAM_ID_H
-#define __FSL_STREAM_ID_H
-
-/* Stream IDs on ls2085a devices are not hardwired and are
- * programmed by sw.  There are a limited number of stream IDs
- * available, and the partitioning of them is scenario dependent.
- * This header defines the partitioning between legacy, PCI,
- * and DPAA2 devices.
- *
- * This partitiong can be customized in this file depending
- * on the specific hardware config-- e.g. perhaps not all
- * PEX controllers are in use.
- *
- * On LS2085 stream IDs are programmed in AMQ registers (32-bits) for
- * each of the different bus masters.  The relationship between
- * the AMQ registers and stream IDs is defined in the table below:
- *          AMQ bit    streamID bit
- *      ---------------------------
- *           PL[18]         9
- *          BMT[17]         8
- *           VA[16]         7
- *             [15]         -
- *         ICID[14:7]       -
- *         ICID[6:0]        6-0
- *     ----------------------------
- */
-
-#define AMQ_PL_MASK			(0x1 << 18)   /* priviledge bit */
-#define AMQ_BMT_MASK			(0x1 << 17)   /* bypass bit */
-
-#define FSL_INVALID_STREAM_ID		0
-
-#define FSL_BYPASS_AMQ			(AMQ_PL_MASK | AMQ_BMT_MASK)
-
-/* legacy devices */
-#define FSL_USB1_STREAM_ID		1
-#define FSL_USB2_STREAM_ID		2
-#define FSL_SDMMC_STREAM_ID		3
-#define FSL_SATA1_STREAM_ID		4
-#define FSL_SATA2_STREAM_ID		5
-#define FSL_DMA_STREAM_ID		6
-
-/* PCI - programmed in PEXn_LUT by OS */
-/*   4 IDs per controller */
-#define FSL_PEX1_STREAM_ID_START	7
-#define FSL_PEX1_STREAM_ID_END		10
-#define FSL_PEX2_STREAM_ID_START	11
-#define FSL_PEX2_STREAM_ID_END		14
-#define FSL_PEX3_STREAM_ID_START	15
-#define FSL_PEX3_STREAM_ID_END		18
-#define FSL_PEX4_STREAM_ID_START	19
-#define FSL_PEX4_STREAM_ID_END		22
-
-/* DPAA2 - set in MC DPC and alloced by MC */
-#define FSL_DPAA2_STREAM_ID_START	23
-#define FSL_DPAA2_STREAM_ID_END		63
-
-#endif
diff --git a/arch/arm/include/asm/global_data.h b/arch/arm/include/asm/global_data.h
index 4e3ea55..bd27281 100644
--- a/arch/arm/include/asm/global_data.h
+++ b/arch/arm/include/asm/global_data.h
@@ -46,7 +46,7 @@ struct arch_global_data {
 	u32 omap_boot_mode;
 	u8 omap_ch_flags;
 #endif
-#ifdef CONFIG_FSL_LSCH3
+#if defined(CONFIG_FSL_LSCH3) && defined(CONFIG_SYS_FSL_HAS_DP_DDR)
 	unsigned long mem2_clk;
 #endif
 };
diff --git a/board/freescale/ls2080a/Kconfig b/board/freescale/ls2080a/Kconfig
new file mode 100644
index 0000000..0b938ff
--- /dev/null
+++ b/board/freescale/ls2080a/Kconfig
@@ -0,0 +1,31 @@
+if TARGET_LS2080A_EMU
+
+config SYS_BOARD
+	default "ls2080a"
+
+config SYS_VENDOR
+	default "freescale"
+
+config SYS_SOC
+	default "fsl-layerscape"
+
+config SYS_CONFIG_NAME
+	default "ls2080a_emu"
+
+endif
+
+if TARGET_LS2080A_SIMU
+
+config SYS_BOARD
+	default "ls2080a"
+
+config SYS_VENDOR
+	default "freescale"
+
+config SYS_SOC
+	default "fsl-layerscape"
+
+config SYS_CONFIG_NAME
+	default "ls2080a_simu"
+
+endif
diff --git a/board/freescale/ls2080a/MAINTAINERS b/board/freescale/ls2080a/MAINTAINERS
new file mode 100644
index 0000000..bb25084
--- /dev/null
+++ b/board/freescale/ls2080a/MAINTAINERS
@@ -0,0 +1,8 @@
+LS2080A BOARD
+M:	York Sun <yorksun@freescale.com>
+S:	Maintained
+F:	board/freescale/ls2080a/
+F:	include/configs/ls2080a_emu.h
+F:	configs/ls2080a_emu_defconfig
+F:	include/configs/ls2080a_simu.h
+F:	configs/ls2080a_simu_defconfig
diff --git a/board/freescale/ls2080a/Makefile b/board/freescale/ls2080a/Makefile
new file mode 100644
index 0000000..47c7c74
--- /dev/null
+++ b/board/freescale/ls2080a/Makefile
@@ -0,0 +1,8 @@
+#
+# Copyright 2014-15 Freescale Semiconductor
+#
+# SPDX-License-Identifier:	GPL-2.0+
+#
+
+obj-y += ls2080a.o
+obj-y += ddr.o
diff --git a/board/freescale/ls2080a/README b/board/freescale/ls2080a/README
new file mode 100644
index 0000000..7e53f1f
--- /dev/null
+++ b/board/freescale/ls2080a/README
@@ -0,0 +1,27 @@
+Freescale ls2080a_emu
+
+This is a emulator target with limited peripherals.
+
+Memory map from core's view
+
+0x00_0000_0000 .. 0x00_000F_FFFF	Boot Rom
+0x00_0100_0000 .. 0x00_0FFF_FFFF	CCSR
+0x00_1800_0000 .. 0x00_181F_FFFF	OCRAM
+0x00_3000_0000 .. 0x00_3FFF_FFFF	IFC region #1
+0x00_8000_0000 .. 0x00_FFFF_FFFF	DDR region #1
+0x05_1000_0000 .. 0x05_FFFF_FFFF	IFC region #2
+0x80_8000_0000 .. 0xFF_FFFF_FFFF	DDR region #2
+
+Other addresses are either reserved, or not used directly by u-boot.
+This list should be updated when more addresses are used.
+
+Booting Linux flavors which do not support 48-bit VA (< Linux 3.18)
+-------------------------------------------------------------------
+One needs to use appropriate bootargs to boot Linux flavors which do
+not support 48-bit VA (for e.g. < Linux 3.18) by appending mem=2048M, as shown
+below:
+
+=> setenv bootargs 'console=ttyS1,115200 root=/dev/ram
+   earlycon=uart8250,mmio,0x21c0600,115200 default_hugepagesz=2m hugepagesz=2m
+   hugepages=16 mem=2048M'
+
diff --git a/board/freescale/ls2080a/ddr.c b/board/freescale/ls2080a/ddr.c
new file mode 100644
index 0000000..47d73ef
--- /dev/null
+++ b/board/freescale/ls2080a/ddr.c
@@ -0,0 +1,207 @@
+/*
+ * Copyright 2014 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <fsl_ddr_sdram.h>
+#include <fsl_ddr_dimm_params.h>
+#include "ddr.h"
+
+DECLARE_GLOBAL_DATA_PTR;
+
+void fsl_ddr_board_options(memctl_options_t *popts,
+				dimm_params_t *pdimm,
+				unsigned int ctrl_num)
+{
+	const struct board_specific_parameters *pbsp, *pbsp_highest = NULL;
+	ulong ddr_freq;
+
+	if (ctrl_num > 3) {
+		printf("Not supported controller number %d\n", ctrl_num);
+		return;
+	}
+	if (!pdimm->n_ranks)
+		return;
+
+	/*
+	 * we use identical timing for all slots. If needed, change the code
+	 * to  pbsp = rdimms[ctrl_num] or pbsp = udimms[ctrl_num];
+	 */
+	if (popts->registered_dimm_en)
+		pbsp = rdimms[ctrl_num];
+	else
+		pbsp = udimms[ctrl_num];
+
+
+	/* Get clk_adjust, wrlvl_start, wrlvl_ctl, according to the board ddr
+	 * freqency and n_banks specified in board_specific_parameters table.
+	 */
+	ddr_freq = get_ddr_freq(0) / 1000000;
+	while (pbsp->datarate_mhz_high) {
+		if (pbsp->n_ranks == pdimm->n_ranks &&
+		    (pdimm->rank_density >> 30) >= pbsp->rank_gb) {
+			if (ddr_freq <= pbsp->datarate_mhz_high) {
+				popts->clk_adjust = pbsp->clk_adjust;
+				popts->wrlvl_start = pbsp->wrlvl_start;
+				popts->wrlvl_ctl_2 = pbsp->wrlvl_ctl_2;
+				popts->wrlvl_ctl_3 = pbsp->wrlvl_ctl_3;
+				goto found;
+			}
+			pbsp_highest = pbsp;
+		}
+		pbsp++;
+	}
+
+	if (pbsp_highest) {
+		printf("Error: board specific timing not found for data rate %lu MT/s\n"
+			"Trying to use the highest speed (%u) parameters\n",
+			ddr_freq, pbsp_highest->datarate_mhz_high);
+		popts->clk_adjust = pbsp_highest->clk_adjust;
+		popts->wrlvl_start = pbsp_highest->wrlvl_start;
+		popts->wrlvl_ctl_2 = pbsp->wrlvl_ctl_2;
+		popts->wrlvl_ctl_3 = pbsp->wrlvl_ctl_3;
+	} else {
+		panic("DIMM is not supported by this board");
+	}
+found:
+	debug("Found timing match: n_ranks %d, data rate %d, rank_gb %d\n"
+		"\tclk_adjust %d, wrlvl_start %d, wrlvl_ctrl_2 0x%x, wrlvl_ctrl_3 0x%x\n",
+		pbsp->n_ranks, pbsp->datarate_mhz_high, pbsp->rank_gb,
+		pbsp->clk_adjust, pbsp->wrlvl_start, pbsp->wrlvl_ctl_2,
+		pbsp->wrlvl_ctl_3);
+#ifdef CONFIG_SYS_FSL_HAS_DP_DDR
+	if (ctrl_num == CONFIG_DP_DDR_CTRL) {
+		/* force DDR bus width to 32 bits */
+		popts->data_bus_width = 1;
+		popts->otf_burst_chop_en = 0;
+		popts->burst_length = DDR_BL8;
+		popts->bstopre = 0;	/* enable auto precharge */
+	}
+#endif
+	/*
+	 * Factors to consider for half-strength driver enable:
+	 *	- number of DIMMs installed
+	 */
+	popts->half_strength_driver_enable = 1;
+	/*
+	 * Write leveling override
+	 */
+	popts->wrlvl_override = 1;
+	popts->wrlvl_sample = 0xf;
+
+	/*
+	 * Rtt and Rtt_WR override
+	 */
+	popts->rtt_override = 0;
+
+	/* Enable ZQ calibration */
+	popts->zq_en = 1;
+
+#ifdef CONFIG_SYS_FSL_DDR4
+	popts->ddr_cdr1 = DDR_CDR1_DHC_EN | DDR_CDR1_ODT(DDR_CDR_ODT_80ohm);
+	popts->ddr_cdr2 = DDR_CDR2_ODT(DDR_CDR_ODT_80ohm) |
+			  DDR_CDR2_VREF_OVRD(70);	/* Vref = 70% */
+#else
+	/* DHC_EN =1, ODT = 75 Ohm */
+	popts->ddr_cdr1 = DDR_CDR1_DHC_EN | DDR_CDR1_ODT(DDR_CDR_ODT_75ohm);
+	popts->ddr_cdr2 = DDR_CDR2_ODT(DDR_CDR_ODT_75ohm);
+#endif
+}
+
+#ifdef CONFIG_SYS_DDR_RAW_TIMING
+dimm_params_t ddr_raw_timing = {
+	.n_ranks = 2,
+	.rank_density = 1073741824u,
+	.capacity = 2147483648,
+	.primary_sdram_width = 64,
+	.ec_sdram_width = 0,
+	.registered_dimm = 0,
+	.mirrored_dimm = 0,
+	.n_row_addr = 14,
+	.n_col_addr = 10,
+	.n_banks_per_sdram_device = 8,
+	.edc_config = 0,
+	.burst_lengths_bitmask = 0x0c,
+
+	.tckmin_x_ps = 937,
+	.caslat_x = 0x6FC << 4,  /* 14,13,11,10,9,8,7,6 */
+	.taa_ps = 13090,
+	.twr_ps = 15000,
+	.trcd_ps = 13090,
+	.trrd_ps = 5000,
+	.trp_ps = 13090,
+	.tras_ps = 33000,
+	.trc_ps = 46090,
+	.trfc_ps = 160000,
+	.twtr_ps = 7500,
+	.trtp_ps = 7500,
+	.refresh_rate_ps = 7800000,
+	.tfaw_ps = 25000,
+};
+
+int fsl_ddr_get_dimm_params(dimm_params_t *pdimm,
+		unsigned int controller_number,
+		unsigned int dimm_number)
+{
+	const char dimm_model[] = "Fixed DDR on board";
+
+	if (((controller_number == 0) && (dimm_number == 0)) ||
+	    ((controller_number == 1) && (dimm_number == 0))) {
+		memcpy(pdimm, &ddr_raw_timing, sizeof(dimm_params_t));
+		memset(pdimm->mpart, 0, sizeof(pdimm->mpart));
+		memcpy(pdimm->mpart, dimm_model, sizeof(dimm_model) - 1);
+	}
+
+	return 0;
+}
+#endif
+phys_size_t initdram(int board_type)
+{
+	phys_size_t dram_size;
+
+	puts("Initializing DDR....");
+
+	puts("using SPD\n");
+	dram_size = fsl_ddr_sdram();
+
+	return dram_size;
+}
+
+void dram_init_banksize(void)
+{
+#ifdef CONFIG_SYS_DP_DDR_BASE_PHY
+	phys_size_t dp_ddr_size;
+#endif
+
+	gd->bd->bi_dram[0].start = CONFIG_SYS_SDRAM_BASE;
+	if (gd->ram_size > CONFIG_SYS_LS2_DDR_BLOCK1_SIZE) {
+		gd->bd->bi_dram[0].size = CONFIG_SYS_LS2_DDR_BLOCK1_SIZE;
+		gd->bd->bi_dram[1].start = CONFIG_SYS_DDR_BLOCK2_BASE;
+		gd->bd->bi_dram[1].size = gd->ram_size -
+					  CONFIG_SYS_LS2_DDR_BLOCK1_SIZE;
+	} else {
+		gd->bd->bi_dram[0].size = gd->ram_size;
+	}
+
+#ifdef CONFIG_SYS_DP_DDR_BASE_PHY
+	/* initialize DP-DDR here */
+	puts("DP-DDR:  ");
+	/*
+	 * DDR controller use 0 as the base address for binding.
+	 * It is mapped to CONFIG_SYS_DP_DDR_BASE for core to access.
+	 */
+	dp_ddr_size = fsl_other_ddr_sdram(CONFIG_SYS_DP_DDR_BASE_PHY,
+					  CONFIG_DP_DDR_CTRL,
+					  CONFIG_DP_DDR_NUM_CTRLS,
+					  CONFIG_DP_DDR_DIMM_SLOTS_PER_CTLR,
+					  NULL, NULL, NULL);
+	if (dp_ddr_size) {
+		gd->bd->bi_dram[2].start = CONFIG_SYS_DP_DDR_BASE;
+		gd->bd->bi_dram[2].size = dp_ddr_size;
+	} else {
+		puts("Not detected");
+	}
+#endif
+}
diff --git a/board/freescale/ls2080a/ddr.h b/board/freescale/ls2080a/ddr.h
new file mode 100644
index 0000000..9958a68
--- /dev/null
+++ b/board/freescale/ls2080a/ddr.h
@@ -0,0 +1,86 @@
+/*
+ * Copyright 2014 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __DDR_H__
+#define __DDR_H__
+struct board_specific_parameters {
+	u32 n_ranks;
+	u32 datarate_mhz_high;
+	u32 rank_gb;
+	u32 clk_adjust;
+	u32 wrlvl_start;
+	u32 wrlvl_ctl_2;
+	u32 wrlvl_ctl_3;
+};
+
+/*
+ * These tables contain all valid speeds we want to override with board
+ * specific parameters. datarate_mhz_high values need to be in ascending order
+ * for each n_ranks group.
+ */
+
+static const struct board_specific_parameters udimm0[] = {
+	/*
+	 * memory controller 0
+	 *   num|  hi| rank|  clk| wrlvl |   wrlvl   |  wrlvl
+	 * ranks| mhz| GB  |adjst| start |   ctl2    |  ctl3
+	 */
+	{2,  2140, 0, 4,     4, 0x0, 0x0},
+	{1,  2140, 0, 4,     4, 0x0, 0x0},
+	{}
+};
+
+/* DP-DDR DIMM */
+static const struct board_specific_parameters udimm2[] = {
+	/*
+	 * memory controller 2
+	 *   num|  hi| rank|  clk| wrlvl |   wrlvl   |  wrlvl
+	 * ranks| mhz| GB  |adjst| start |   ctl2    |  ctl3
+	 */
+	{2,  2140, 0, 4,     4, 0x0, 0x0},
+	{1,  2140, 0, 4,     4, 0x0, 0x0},
+	{}
+};
+
+static const struct board_specific_parameters rdimm0[] = {
+	/*
+	 * memory controller 0
+	 *   num|  hi| rank|  clk| wrlvl |   wrlvl   |  wrlvl
+	 * ranks| mhz| GB  |adjst| start |   ctl2    |  ctl3
+	 */
+	{4,  2140, 0, 5,     4, 0x0, 0x0},
+	{2,  2140, 0, 5,     4, 0x0, 0x0},
+	{1,  2140, 0, 4,     4, 0x0, 0x0},
+	{}
+};
+
+/* DP-DDR DIMM */
+static const struct board_specific_parameters rdimm2[] = {
+	/*
+	 * memory controller 2
+	 *   num|  hi| rank|  clk| wrlvl |   wrlvl   |  wrlvl
+	 * ranks| mhz| GB  |adjst| start |   ctl2    |  ctl3
+	 */
+	{4,  2140, 0, 5,     4, 0x0, 0x0},
+	{2,  2140, 0, 5,     4, 0x0, 0x0},
+	{1,  2140, 0, 4,     4, 0x0, 0x0},
+	{}
+};
+
+static const struct board_specific_parameters *udimms[] = {
+	udimm0,
+	udimm0,
+	udimm2,
+};
+
+static const struct board_specific_parameters *rdimms[] = {
+	rdimm0,
+	rdimm0,
+	rdimm2,
+};
+
+
+#endif
diff --git a/board/freescale/ls2080a/ls2080a.c b/board/freescale/ls2080a/ls2080a.c
new file mode 100644
index 0000000..827fbf0
--- /dev/null
+++ b/board/freescale/ls2080a/ls2080a.c
@@ -0,0 +1,152 @@
+/*
+ * Copyright 2014 Freescale Semiconductor
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+#include <common.h>
+#include <malloc.h>
+#include <errno.h>
+#include <netdev.h>
+#include <fsl_ifc.h>
+#include <fsl_ddr.h>
+#include <asm/io.h>
+#include <fdt_support.h>
+#include <libfdt.h>
+#include <fsl_debug_server.h>
+#include <fsl-mc/fsl_mc.h>
+#include <environment.h>
+#include <asm/arch/soc.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+int board_init(void)
+{
+	init_final_memctl_regs();
+
+#ifdef CONFIG_ENV_IS_NOWHERE
+	gd->env_addr = (ulong)&default_environment[0];
+#endif
+
+	return 0;
+}
+
+int board_early_init_f(void)
+{
+	fsl_lsch3_early_init_f();
+	return 0;
+}
+
+void detail_board_ddr_info(void)
+{
+	puts("\nDDR    ");
+	print_size(gd->bd->bi_dram[0].size + gd->bd->bi_dram[1].size, "");
+	print_ddr_info(0);
+#ifdef CONFIG_SYS_FSL_HAS_DP_DDR
+	if (gd->bd->bi_dram[2].size) {
+		puts("\nDP-DDR ");
+		print_size(gd->bd->bi_dram[2].size, "");
+		print_ddr_info(CONFIG_DP_DDR_CTRL);
+	}
+#endif
+}
+
+int dram_init(void)
+{
+	gd->ram_size = initdram(0);
+
+	return 0;
+}
+
+#if defined(CONFIG_ARCH_MISC_INIT)
+int arch_misc_init(void)
+{
+#ifdef CONFIG_FSL_DEBUG_SERVER
+	debug_server_init();
+#endif
+
+	return 0;
+}
+#endif
+
+unsigned long get_dram_size_to_hide(void)
+{
+	unsigned long dram_to_hide = 0;
+
+/* Carve the Debug Server private DRAM block from the end of DRAM */
+#ifdef CONFIG_FSL_DEBUG_SERVER
+	dram_to_hide += debug_server_get_dram_block_size();
+#endif
+
+/* Carve the MC private DRAM block from the end of DRAM */
+#ifdef CONFIG_FSL_MC_ENET
+	dram_to_hide += mc_get_dram_block_size();
+#endif
+
+	return roundup(dram_to_hide, CONFIG_SYS_MEM_TOP_HIDE_MIN);
+}
+
+int board_eth_init(bd_t *bis)
+{
+	int error = 0;
+
+#ifdef CONFIG_SMC91111
+	error = smc91111_initialize(0, CONFIG_SMC91111_BASE);
+#endif
+
+#ifdef CONFIG_FSL_MC_ENET
+	error = cpu_eth_init(bis);
+#endif
+	return error;
+}
+
+#ifdef CONFIG_FSL_MC_ENET
+void fdt_fixup_board_enet(void *fdt)
+{
+	int offset;
+
+	offset = fdt_path_offset(fdt, "/fsl-mc");
+
+	/*
+	 * TODO: Remove this when backward compatibility
+	 * with old DT node (fsl,dprc@0) is no longer needed.
+	 */
+	if (offset < 0)
+		offset = fdt_path_offset(fdt, "/fsl,dprc@0");
+
+	if (offset < 0) {
+		printf("%s: ERROR: fsl-mc node not found in device tree (error %d)\n",
+		       __func__, offset);
+		return;
+	}
+
+	if (get_mc_boot_status() == 0)
+		fdt_status_okay(fdt, offset);
+	else
+		fdt_status_fail(fdt, offset);
+}
+#endif
+
+#ifdef CONFIG_OF_BOARD_SETUP
+int ft_board_setup(void *blob, bd_t *bd)
+{
+	u64 base[CONFIG_NR_DRAM_BANKS];
+	u64 size[CONFIG_NR_DRAM_BANKS];
+
+	ft_cpu_setup(blob, bd);
+
+	/* fixup DT for the two GPP DDR banks */
+	base[0] = gd->bd->bi_dram[0].start;
+	size[0] = gd->bd->bi_dram[0].size;
+	base[1] = gd->bd->bi_dram[1].start;
+	size[1] = gd->bd->bi_dram[1].size;
+
+	fdt_fixup_memory_banks(blob, base, size, 2);
+
+#ifdef CONFIG_FSL_MC_ENET
+	fdt_fixup_board_enet(blob);
+	fsl_mc_ldpaa_exit(bd);
+#endif
+
+	return 0;
+}
+#endif
diff --git a/board/freescale/ls2080aqds/Kconfig b/board/freescale/ls2080aqds/Kconfig
new file mode 100644
index 0000000..2f997e9
--- /dev/null
+++ b/board/freescale/ls2080aqds/Kconfig
@@ -0,0 +1,16 @@
+
+if TARGET_LS2080AQDS
+
+config SYS_BOARD
+	default "ls2080aqds"
+
+config SYS_VENDOR
+	default "freescale"
+
+config SYS_SOC
+	default "fsl-layerscape"
+
+config SYS_CONFIG_NAME
+	default "ls2080aqds"
+
+endif
diff --git a/board/freescale/ls2080aqds/MAINTAINERS b/board/freescale/ls2080aqds/MAINTAINERS
new file mode 100644
index 0000000..3d82482
--- /dev/null
+++ b/board/freescale/ls2080aqds/MAINTAINERS
@@ -0,0 +1,8 @@
+LS2080A BOARD
+M:	Prabhakar Kushwaha <prabhakar@freescale.com>
+S:	Maintained
+F:	board/freescale/ls2080aqds/
+F:	board/freescale/ls2080a/ls2080aqds.c
+F:	include/configs/ls2080aqds.h
+F:	configs/ls2080aqds_defconfig
+F:	configs/ls2080aqds_nand_defconfig
diff --git a/board/freescale/ls2080aqds/Makefile b/board/freescale/ls2080aqds/Makefile
new file mode 100644
index 0000000..e0da8a5
--- /dev/null
+++ b/board/freescale/ls2080aqds/Makefile
@@ -0,0 +1,9 @@
+#
+# Copyright 2015 Freescale Semiconductor
+#
+# SPDX-License-Identifier:	GPL-2.0+
+#
+
+obj-y += ls2080aqds.o
+obj-y += ddr.o
+obj-y += eth.o
diff --git a/board/freescale/ls2080aqds/README b/board/freescale/ls2080aqds/README
new file mode 100644
index 0000000..a4abb7e
--- /dev/null
+++ b/board/freescale/ls2080aqds/README
@@ -0,0 +1,229 @@
+Overview
+--------
+The LS2080A Development System (QDS) is a high-performance computing,
+evaluation, and development platform that supports the QorIQ LS2080A
+Layerscape Architecture processor. The LS2080AQDS provides validation and
+SW development platform for the Freescale LS2080A processor series, with
+a complete debugging environment.
+
+LS2080A SoC Overview
+------------------
+The LS2080A integrated multicore processor combines eight ARM Cortex-A57
+processor cores with high-performance data path acceleration logic and network
+and peripheral bus interfaces required for networking, telecom/datacom,
+wireless infrastructure, and mil/aerospace applications.
+
+The LS2080A SoC includes the following function and features:
+
+ - Eight 64-bit ARM Cortex-A57 CPUs
+ - 1 MB platform cache with ECC
+ - Two 64-bit DDR4 SDRAM memory controllers with ECC and interleaving support
+ - One secondary 32-bit DDR4 SDRAM memory controller, intended for use by
+  the AIOP
+ - Data path acceleration architecture (DPAA2) incorporating acceleration for
+ the following functions:
+   - Packet parsing, classification, and distribution (WRIOP)
+   - Queue and Hardware buffer management for scheduling, packet sequencing, and
+     congestion management, buffer allocation and de-allocation (QBMan)
+   - Cryptography acceleration (SEC) at up to 10 Gbps
+   - RegEx pattern matching acceleration (PME) at up to 10 Gbps
+   - Decompression/compression acceleration (DCE) at up to 20 Gbps
+   - Accelerated I/O processing (AIOP) at up to 20 Gbps
+   - QDMA engine
+ - 16 SerDes lanes at up to 10.3125 GHz
+ - Ethernet interfaces
+   - Up to eight 10 Gbps Ethernet MACs
+   - Up to eight 1 / 2.5 Gbps Ethernet MACs
+ - High-speed peripheral interfaces
+   - Four PCIe 3.0 controllers, one supporting SR-IOV
+ - Additional peripheral interfaces
+   - Two serial ATA (SATA 3.0) controllers
+   - Two high-speed USB 3.0 controllers with integrated PHY
+   - Enhanced secure digital host controller (eSDXC/eMMC)
+   - Serial peripheral interface (SPI) controller
+   - Quad Serial Peripheral Interface (QSPI) Controller
+   - Four I2C controllers
+   - Two DUARTs
+   - Integrated flash controller (IFC 2.0) supporting NAND and NOR flash
+ - Support for hardware virtualization and partitioning enforcement
+ - QorIQ platform's trust architecture 3.0
+ - Service processor (SP) provides pre-boot initialization and secure-boot
+  capabilities
+
+ LS2080AQDS board Overview
+ -----------------------
+ - SERDES Connections, 16 lanes supporting:
+      - PCI Express - 3.0
+      - SGMII, SGMII 2.5
+      - QSGMII
+      - SATA 3.0
+      - XAUI
+      - XFI
+ - DDR Controller
+     - Two ports of 72-bits (8-bits ECC) DDR4. Each port supports four
+       chip-selects and two DIMM connectors. Support is up to 2133MT/s.
+     - One port of 40-bits (8-bits ECC) DDR4 which supports four chip-selects
+       and two DIMM connectors. Support is up to 1600MT/s.
+ -IFC/Local Bus
+    - IFC rev. 2.0 implementation supporting Little Endian connection scheme.
+    - One in-socket 128 MB NOR flash 16-bit data bus
+    - One 512 MB NAND flash with ECC support
+    - IFC Test Port
+    - PromJet Port
+    - FPGA connection
+ - USB 3.0
+    - Two high speed USB 3.0 ports
+    - First USB 3.0 port configured as Host with Type-A connector
+    - Second USB 3.0 port configured as OTG with micro-AB connector
+ - SDHC: PCIe x1 Right Angle connector for supporting following cards
+    - 1/4-/8-bit SD/MMC Legacy CARD supporting 3.3V devices only
+    - 1-/4-/8-bit SD/MMC Card supporting 1.8V devices only
+    - 4-bit eMMC Card Rev 4.4 (1.8V only)
+    - 8-bit eMMC Card Rev 4.5 (1.8V only)
+    - SD Card Rev 2.0 and Rev 3.0
+ - DSPI: 3 high-speed flash Memory for storage
+    - 16 MB high-speed flash Memory for boot code and storage (up to 108MHz)
+    - 8 MB high-speed flash Memory (up to 104 MHz)
+    - 512 MB low-speed flash Memory (up to 40 MHz)
+ - QSPI: via NAND/QSPI Card
+ - 4 I2C controllers
+ - Two SATA onboard connectors
+ - UART
+   - Two 4-pin (HW control) or four 2-pin (SW control) serial ports at up to 115.2 Kbit/s
+   - Two DB9 D-Type connectors supporting one Serial port each
+ - ARM JTAG support
+
+Memory map from core's view
+----------------------------
+0x00_0000_0000 .. 0x00_000F_FFFF	Boot Rom
+0x00_0100_0000 .. 0x00_0FFF_FFFF	CCSR
+0x00_1800_0000 .. 0x00_181F_FFFF	OCRAM
+0x00_3000_0000 .. 0x00_3FFF_FFFF	IFC region #1
+0x00_8000_0000 .. 0x00_FFFF_FFFF	DDR region #1
+0x05_1000_0000 .. 0x05_FFFF_FFFF	IFC region #2
+0x80_8000_0000 .. 0xFF_FFFF_FFFF	DDR region #2
+
+Other addresses are either reserved, or not used directly by u-boot.
+This list should be updated when more addresses are used.
+
+IFC region map from core's view
+-------------------------------
+During boot i.e. IFC Region #1:-
+  0x30000000 - 0x37ffffff : 128MB : NOR flash
+  0x38000000 - 0x3BFFFFFF : 64MB  : Promjet
+  0x3C000000 - 0x40000000 : 64MB  : FPGA etc
+
+After relocate to DDR i.e. IFC Region #2:-
+  0x5_1000_0000..0x5_1fff_ffff	Memory Hole
+  0x5_2000_0000..0x5_3fff_ffff	IFC CSx (FPGA, NAND and others 512MB)
+  0x5_4000_0000..0x5_7fff_ffff	ASIC or others 1GB
+  0x5_8000_0000..0x5_bfff_ffff	IFC CS0 1GB (NOR/Promjet)
+  0x5_C000_0000..0x5_ffff_ffff	IFC CS1 1GB (NOR/Promjet)
+
+Booting Options
+---------------
+a) Promjet Boot
+b) NOR boot
+c) NAND boot
+d) SD boot
+e) QSPI boot
+
+Environment Variables
+---------------------
+- mcboottimeout: MC boot timeout in milliseconds. If this variable is not defined
+  the value CONFIG_SYS_LS_MC_BOOT_TIMEOUT_MS will be assumed.
+
+- mcmemsize: MC DRAM block size. If this variable is not defined
+  the value CONFIG_SYS_LS_MC_DRAM_BLOCK_MIN_SIZE will be assumed.
+
+Booting Linux flavors which do not support 48-bit VA (< Linux 3.18)
+-------------------------------------------------------------------
+One needs to use appropriate bootargs to boot Linux flavors which do
+not support 48-bit VA (for e.g. < Linux 3.18) by appending mem=2048M, as shown
+below:
+
+=> setenv bootargs 'console=ttyS1,115200 root=/dev/ram
+   earlycon=uart8250,mmio,0x21c0600,115200 default_hugepagesz=2m hugepagesz=2m
+   hugepages=16 mem=2048M'
+
+
+X-QSGMII-16PORT riser card
+----------------------------
+The X-QSGMII-16PORT is a 4xQSGMII/8xSGMII riser card with eighth SerDes
+interfaces implemented in PCIe form factor board.
+It supports followings
+ - Card can operate with up to 4 QSGMII lane simultaneously
+ - Card can operate with up to 8 SGMII lane simultaneously
+
+Supported card configuration
+	- CSEL  : ON ON ON ON
+	- MSEL1 : ON ON ON ON OFF OFF OFF OFF
+	- MSEL2 : OFF OFF OFF OFF ON ON ON ON
+
+To enable this card: modify hwconfig to add "xqsgmii" variable.
+
+Supported PHY addresses during SGMII:
+#define XQSGMII_CARD_PHY1_PORT0_ADDR 0x0
+#define XQSGMII_CARD_PHY1_PORT2_ADDR 0x2
+#define XQSGMII_CARD_PHY2_PORT0_ADDR 0x4
+#define XQSGMII_CARD_PHY2_PORT2_ADDR 0x6
+#define XQSGMII_CARD_PHY3_PORT0_ADDR 0x8
+#define XQSGMII_CARD_PHY3_PORT2_ADDR 0xa
+#define XQSGMII_CARD_PHY4_PORT0_ADDR 0xc
+#define XQSGMII_CARD_PHY4_PORT2_ADDR 0xe
+
+Mapping DPMACx to PHY during QSGMII
+DPMAC1 -> PHY1-P0
+DPMAC2 -> PHY2-P0
+DPMAC3 -> PHY3-P0
+DPMAC4 -> PHY4-P0
+DPMAC5 -> PHY3-P2
+DPMAC6 -> PHY1-P2
+DPMAC7 -> PHY4-P1
+DPMAC8 -> PHY2-P2
+DPMAC9 -> PHY1-P0
+DPMAC10 -> PHY2-P0
+DPMAC11 -> PHY3-P0
+DPMAC12 -> PHY4-P0
+DPMAC13 -> PHY3-P2
+DPMAC14 -> PHY1-P2
+DPMAC15 -> PHY4-P1
+DPMAC16 -> PHY2-P2
+
+
+Supported PHY address during QSGMII
+#define XQSGMII_CARD_PHY1_PORT0_ADDR 0x0
+#define XQSGMII_CARD_PHY1_PORT1_ADDR 0x1
+#define XQSGMII_CARD_PHY1_PORT2_ADDR 0x2
+#define XQSGMII_CARD_PHY1_PORT3_ADDR 0x3
+#define XQSGMII_CARD_PHY2_PORT0_ADDR 0x4
+#define XQSGMII_CARD_PHY2_PORT1_ADDR 0x5
+#define XQSGMII_CARD_PHY2_PORT2_ADDR 0x6
+#define XQSGMII_CARD_PHY2_PORT3_ADDR 0x7
+#define XQSGMII_CARD_PHY3_PORT0_ADDR 0x8
+#define XQSGMII_CARD_PHY3_PORT1_ADDR 0x9
+#define XQSGMII_CARD_PHY3_PORT2_ADDR 0xa
+#define XQSGMII_CARD_PHY3_PORT3_ADDR 0xb
+#define XQSGMII_CARD_PHY4_PORT0_ADDR 0xc
+#define XQSGMII_CARD_PHY4_PORT1_ADDR 0xd
+#define XQSGMII_CARD_PHY4_PORT2_ADDR 0xe
+#define XQSGMII_CARD_PHY4_PORT3_ADDR 0xf
+
+Mapping DPMACx to PHY during QSGMII
+DPMAC1 -> PHY1-P3
+DPMAC2 -> PHY1-P2
+DPMAC3 -> PHY1-P1
+DPMAC4 -> PHY1-P0
+DPMAC5 -> PHY2-P3
+DPMAC6 -> PHY2-P2
+DPMAC7 -> PHY2-P1
+DPMAC8 -> PHY2-P0
+DPMAC9 -> PHY3-P0
+DPMAC10 -> PHY3-P1
+DPMAC11 -> PHY3-P2
+DPMAC12 -> PHY3-P3
+DPMAC13 -> PHY4-P0
+DPMAC14 -> PHY4-P1
+DPMAC15 -> PHY4-P2
+DPMAC16 -> PHY4-P3
+
diff --git a/board/freescale/ls2080aqds/ddr.c b/board/freescale/ls2080aqds/ddr.c
new file mode 100644
index 0000000..ae681de
--- /dev/null
+++ b/board/freescale/ls2080aqds/ddr.c
@@ -0,0 +1,199 @@
+/*
+ * Copyright 2015 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <fsl_ddr_sdram.h>
+#include <fsl_ddr_dimm_params.h>
+#include "ddr.h"
+
+DECLARE_GLOBAL_DATA_PTR;
+
+void fsl_ddr_board_options(memctl_options_t *popts,
+				dimm_params_t *pdimm,
+				unsigned int ctrl_num)
+{
+#ifdef CONFIG_SYS_FSL_HAS_DP_DDR
+	u8 dq_mapping_0, dq_mapping_2, dq_mapping_3;
+#endif
+	const struct board_specific_parameters *pbsp, *pbsp_highest = NULL;
+	ulong ddr_freq;
+	int slot;
+
+	if (ctrl_num > 2) {
+		printf("Not supported controller number %d\n", ctrl_num);
+		return;
+	}
+
+	for (slot = 0; slot < CONFIG_DIMM_SLOTS_PER_CTLR; slot++) {
+		if (pdimm[slot].n_ranks)
+			break;
+	}
+
+	if (slot >= CONFIG_DIMM_SLOTS_PER_CTLR)
+		return;
+
+	/*
+	 * we use identical timing for all slots. If needed, change the code
+	 * to  pbsp = rdimms[ctrl_num] or pbsp = udimms[ctrl_num];
+	 */
+	if (popts->registered_dimm_en)
+		pbsp = rdimms[ctrl_num];
+	else
+		pbsp = udimms[ctrl_num];
+
+
+	/* Get clk_adjust, wrlvl_start, wrlvl_ctl, according to the board ddr
+	 * freqency and n_banks specified in board_specific_parameters table.
+	 */
+	ddr_freq = get_ddr_freq(ctrl_num) / 1000000;
+	while (pbsp->datarate_mhz_high) {
+		if (pbsp->n_ranks == pdimm[slot].n_ranks &&
+		    (pdimm[slot].rank_density >> 30) >= pbsp->rank_gb) {
+			if (ddr_freq <= pbsp->datarate_mhz_high) {
+				popts->clk_adjust = pbsp->clk_adjust;
+				popts->wrlvl_start = pbsp->wrlvl_start;
+				popts->wrlvl_ctl_2 = pbsp->wrlvl_ctl_2;
+				popts->wrlvl_ctl_3 = pbsp->wrlvl_ctl_3;
+				goto found;
+			}
+			pbsp_highest = pbsp;
+		}
+		pbsp++;
+	}
+
+	if (pbsp_highest) {
+		printf("Error: board specific timing not found for data rate %lu MT/s\n"
+			"Trying to use the highest speed (%u) parameters\n",
+			ddr_freq, pbsp_highest->datarate_mhz_high);
+		popts->clk_adjust = pbsp_highest->clk_adjust;
+		popts->wrlvl_start = pbsp_highest->wrlvl_start;
+		popts->wrlvl_ctl_2 = pbsp->wrlvl_ctl_2;
+		popts->wrlvl_ctl_3 = pbsp->wrlvl_ctl_3;
+	} else {
+		panic("DIMM is not supported by this board");
+	}
+found:
+	debug("Found timing match: n_ranks %d, data rate %d, rank_gb %d\n"
+		"\tclk_adjust %d, wrlvl_start %d, wrlvl_ctrl_2 0x%x, wrlvl_ctrl_3 0x%x\n",
+		pbsp->n_ranks, pbsp->datarate_mhz_high, pbsp->rank_gb,
+		pbsp->clk_adjust, pbsp->wrlvl_start, pbsp->wrlvl_ctl_2,
+		pbsp->wrlvl_ctl_3);
+#ifdef CONFIG_SYS_FSL_HAS_DP_DDR
+	if (ctrl_num == CONFIG_DP_DDR_CTRL) {
+		/* force DDR bus width to 32 bits */
+		popts->data_bus_width = 1;
+		popts->otf_burst_chop_en = 0;
+		popts->burst_length = DDR_BL8;
+		popts->bstopre = 0;	/* enable auto precharge */
+		/*
+		 * Layout optimization results byte mapping
+		 * Byte 0 -> Byte ECC
+		 * Byte 1 -> Byte 3
+		 * Byte 2 -> Byte 2
+		 * Byte 3 -> Byte 1
+		 * Byte ECC -> Byte 0
+		 */
+		dq_mapping_0 = pdimm[slot].dq_mapping[0];
+		dq_mapping_2 = pdimm[slot].dq_mapping[2];
+		dq_mapping_3 = pdimm[slot].dq_mapping[3];
+		pdimm[slot].dq_mapping[0] = pdimm[slot].dq_mapping[8];
+		pdimm[slot].dq_mapping[1] = pdimm[slot].dq_mapping[9];
+		pdimm[slot].dq_mapping[2] = pdimm[slot].dq_mapping[6];
+		pdimm[slot].dq_mapping[3] = pdimm[slot].dq_mapping[7];
+		pdimm[slot].dq_mapping[6] = dq_mapping_2;
+		pdimm[slot].dq_mapping[7] = dq_mapping_3;
+		pdimm[slot].dq_mapping[8] = dq_mapping_0;
+		pdimm[slot].dq_mapping[9] = 0;
+		pdimm[slot].dq_mapping[10] = 0;
+		pdimm[slot].dq_mapping[11] = 0;
+		pdimm[slot].dq_mapping[12] = 0;
+		pdimm[slot].dq_mapping[13] = 0;
+		pdimm[slot].dq_mapping[14] = 0;
+		pdimm[slot].dq_mapping[15] = 0;
+		pdimm[slot].dq_mapping[16] = 0;
+		pdimm[slot].dq_mapping[17] = 0;
+	}
+#endif
+	/* To work at higher than 1333MT/s */
+	popts->half_strength_driver_enable = 0;
+	/*
+	 * Write leveling override
+	 */
+	popts->wrlvl_override = 1;
+	popts->wrlvl_sample = 0x0;	/* 32 clocks */
+
+	/*
+	 * Rtt and Rtt_WR override
+	 */
+	popts->rtt_override = 0;
+
+	/* Enable ZQ calibration */
+	popts->zq_en = 1;
+
+	if (ddr_freq < 2350) {
+		popts->ddr_cdr1 = DDR_CDR1_DHC_EN |
+				  DDR_CDR1_ODT(DDR_CDR_ODT_60ohm);
+		popts->ddr_cdr2 = DDR_CDR2_ODT(DDR_CDR_ODT_60ohm) |
+				  DDR_CDR2_VREF_RANGE_2;
+	} else {
+		popts->ddr_cdr1 = DDR_CDR1_DHC_EN |
+				  DDR_CDR1_ODT(DDR_CDR_ODT_100ohm);
+		popts->ddr_cdr2 = DDR_CDR2_ODT(DDR_CDR_ODT_100ohm) |
+				  DDR_CDR2_VREF_RANGE_2;
+	}
+}
+
+phys_size_t initdram(int board_type)
+{
+	phys_size_t dram_size;
+
+#if defined(CONFIG_SPL) && !defined(CONFIG_SPL_BUILD)
+	return fsl_ddr_sdram_size();
+#else
+	puts("Initializing DDR....using SPD\n");
+
+	dram_size = fsl_ddr_sdram();
+#endif
+
+	return dram_size;
+}
+
+void dram_init_banksize(void)
+{
+#ifdef CONFIG_SYS_DP_DDR_BASE_PHY
+	phys_size_t dp_ddr_size;
+#endif
+
+	gd->bd->bi_dram[0].start = CONFIG_SYS_SDRAM_BASE;
+	if (gd->ram_size > CONFIG_SYS_LS2_DDR_BLOCK1_SIZE) {
+		gd->bd->bi_dram[0].size = CONFIG_SYS_LS2_DDR_BLOCK1_SIZE;
+		gd->bd->bi_dram[1].start = CONFIG_SYS_DDR_BLOCK2_BASE;
+		gd->bd->bi_dram[1].size = gd->ram_size -
+					  CONFIG_SYS_LS2_DDR_BLOCK1_SIZE;
+	} else {
+		gd->bd->bi_dram[0].size = gd->ram_size;
+	}
+
+#ifdef CONFIG_SYS_DP_DDR_BASE_PHY
+	/* initialize DP-DDR here */
+	puts("DP-DDR:  ");
+	/*
+	 * DDR controller use 0 as the base address for binding.
+	 * It is mapped to CONFIG_SYS_DP_DDR_BASE for core to access.
+	 */
+	dp_ddr_size = fsl_other_ddr_sdram(CONFIG_SYS_DP_DDR_BASE_PHY,
+					  CONFIG_DP_DDR_CTRL,
+					  CONFIG_DP_DDR_NUM_CTRLS,
+					  CONFIG_DP_DDR_DIMM_SLOTS_PER_CTLR,
+					  NULL, NULL, NULL);
+	if (dp_ddr_size) {
+		gd->bd->bi_dram[2].start = CONFIG_SYS_DP_DDR_BASE;
+		gd->bd->bi_dram[2].size = dp_ddr_size;
+	} else {
+		puts("Not detected");
+	}
+#endif
+}
diff --git a/board/freescale/ls2080aqds/ddr.h b/board/freescale/ls2080aqds/ddr.h
new file mode 100644
index 0000000..b76ea61
--- /dev/null
+++ b/board/freescale/ls2080aqds/ddr.h
@@ -0,0 +1,92 @@
+/*
+ * Copyright 2015 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __DDR_H__
+#define __DDR_H__
+struct board_specific_parameters {
+	u32 n_ranks;
+	u32 datarate_mhz_high;
+	u32 rank_gb;
+	u32 clk_adjust;
+	u32 wrlvl_start;
+	u32 wrlvl_ctl_2;
+	u32 wrlvl_ctl_3;
+};
+
+/*
+ * These tables contain all valid speeds we want to override with board
+ * specific parameters. datarate_mhz_high values need to be in ascending order
+ * for each n_ranks group.
+ */
+
+static const struct board_specific_parameters udimm0[] = {
+	/*
+	 * memory controller 0
+	 *   num|  hi| rank|  clk| wrlvl |   wrlvl   |  wrlvl
+	 * ranks| mhz| GB  |adjst| start |   ctl2    |  ctl3
+	 */
+	{2,  1350, 0, 4,     6, 0x0708090B, 0x0C0D0E09,},
+	{2,  1666, 0, 4,     7, 0x08090A0C, 0x0D0F100B,},
+	{2,  1900, 0, 4,     7, 0x09090B0D, 0x0E10120B,},
+	{2,  2300, 0, 4,     8, 0x090A0C0F, 0x1012130C,},
+	{}
+};
+
+/* DP-DDR DIMM */
+static const struct board_specific_parameters udimm2[] = {
+	/*
+	 * memory controller 2
+	 *   num|  hi| rank|  clk| wrlvl |   wrlvl   |  wrlvl
+	 * ranks| mhz| GB  |adjst| start |   ctl2    |  ctl3
+	 */
+	{2,  1350, 0, 4,   0xd, 0x0C0A0A00, 0x00000009,},
+	{2,  1666, 0, 4,   0xd, 0x0C0A0A00, 0x00000009,},
+	{2,  1900, 0, 4,   0xe, 0x0D0C0B00, 0x0000000A,},
+	{2,  2200, 0, 4,   0xe, 0x0D0C0B00, 0x0000000A,},
+	{}
+};
+
+static const struct board_specific_parameters rdimm0[] = {
+	/*
+	 * memory controller 0
+	 *   num|  hi| rank|  clk| wrlvl |   wrlvl   |  wrlvl
+	 * ranks| mhz| GB  |adjst| start |   ctl2    |  ctl3
+	 */
+	{2,  1350, 0, 4,     6, 0x0708090B, 0x0C0D0E09,},
+	{2,  1666, 0, 4,     7, 0x08090A0C, 0x0D0F100B,},
+	{2,  1900, 0, 4,     7, 0x09090B0D, 0x0E10120B,},
+	{2,  2200, 0, 4,     8, 0x090A0C0F, 0x1012130C,},
+	{}
+};
+
+/* DP-DDR DIMM */
+static const struct board_specific_parameters rdimm2[] = {
+	/*
+	 * memory controller 2
+	 *   num|  hi| rank|  clk| wrlvl |   wrlvl   |  wrlvl
+	 * ranks| mhz| GB  |adjst| start |   ctl2    |  ctl3
+	 */
+	{2,  1350, 0, 4,     6, 0x0708090B, 0x0C0D0E09,},
+	{2,  1666, 0, 4,     7, 0x0B0A090C, 0x0D0F100B,},
+	{2,  1900, 0, 4,     7, 0x09090B0D, 0x0E10120B,},
+	{2,  2200, 0, 4,     8, 0x090A0C0F, 0x1012130C,},
+	{}
+};
+
+static const struct board_specific_parameters *udimms[] = {
+	udimm0,
+	udimm0,
+	udimm2,
+};
+
+static const struct board_specific_parameters *rdimms[] = {
+	rdimm0,
+	rdimm0,
+	rdimm2,
+};
+
+
+#endif
diff --git a/board/freescale/ls2080aqds/eth.c b/board/freescale/ls2080aqds/eth.c
new file mode 100644
index 0000000..ec0acee
--- /dev/null
+++ b/board/freescale/ls2080aqds/eth.c
@@ -0,0 +1,825 @@
+/*
+ * Copyright 2015 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <netdev.h>
+#include <asm/io.h>
+#include <asm/arch/fsl_serdes.h>
+#include <hwconfig.h>
+#include <fsl_mdio.h>
+#include <malloc.h>
+#include <fm_eth.h>
+#include <i2c.h>
+#include <miiphy.h>
+#include <fsl-mc/ldpaa_wriop.h>
+
+#include "../common/qixis.h"
+
+#include "ls2080aqds_qixis.h"
+
+
+#ifdef CONFIG_FSL_MC_ENET
+ /* - In LS2080A there are only 16 SERDES lanes, spread across 2 SERDES banks.
+ *   Bank 1 -> Lanes A, B, C, D, E, F, G, H
+ *   Bank 2 -> Lanes A,B, C, D, E, F, G, H
+ */
+
+ /* Mapping of 16 SERDES lanes to LS2080A QDS board slots. A value of '0' here
+  * means that the mapping must be determined dynamically, or that the lane
+  * maps to something other than a board slot.
+  */
+
+static u8 lane_to_slot_fsm1[] = {
+	0, 0, 0, 0, 0, 0, 0, 0
+};
+
+static u8 lane_to_slot_fsm2[] = {
+	0, 0, 0, 0, 0, 0, 0, 0
+};
+
+/* On the Vitesse VSC8234XHG SGMII riser card there are 4 SGMII PHYs
+ * housed.
+ */
+
+static int xqsgii_riser_phy_addr[] = {
+	XQSGMII_CARD_PHY1_PORT0_ADDR,
+	XQSGMII_CARD_PHY2_PORT0_ADDR,
+	XQSGMII_CARD_PHY3_PORT0_ADDR,
+	XQSGMII_CARD_PHY4_PORT0_ADDR,
+	XQSGMII_CARD_PHY3_PORT2_ADDR,
+	XQSGMII_CARD_PHY1_PORT2_ADDR,
+	XQSGMII_CARD_PHY4_PORT2_ADDR,
+	XQSGMII_CARD_PHY2_PORT2_ADDR,
+};
+
+static int sgmii_riser_phy_addr[] = {
+	SGMII_CARD_PORT1_PHY_ADDR,
+	SGMII_CARD_PORT2_PHY_ADDR,
+	SGMII_CARD_PORT3_PHY_ADDR,
+	SGMII_CARD_PORT4_PHY_ADDR,
+};
+
+/* Slot2 does not have EMI connections */
+#define EMI_NONE	0xFFFFFFFF
+#define EMI1_SLOT1	0
+#define EMI1_SLOT2	1
+#define EMI1_SLOT3	2
+#define EMI1_SLOT4	3
+#define EMI1_SLOT5	4
+#define EMI1_SLOT6	5
+#define EMI2		6
+#define SFP_TX		0
+
+static const char * const mdio_names[] = {
+	"LS2080A_QDS_MDIO0",
+	"LS2080A_QDS_MDIO1",
+	"LS2080A_QDS_MDIO2",
+	"LS2080A_QDS_MDIO3",
+	"LS2080A_QDS_MDIO4",
+	"LS2080A_QDS_MDIO5",
+	DEFAULT_WRIOP_MDIO2_NAME,
+};
+
+struct ls2080a_qds_mdio {
+	u8 muxval;
+	struct mii_dev *realbus;
+};
+
+static void sgmii_configure_repeater(int serdes_port)
+{
+	struct mii_dev *bus;
+	uint8_t a = 0xf;
+	int i, j, ret;
+	int dpmac_id = 0, dpmac, mii_bus = 0;
+	unsigned short value;
+	char dev[2][20] = {"LS2080A_QDS_MDIO0", "LS2080A_QDS_MDIO3"};
+	uint8_t i2c_addr[] = {0x58, 0x59, 0x5a, 0x5b, 0x5c, 0x5d, 0x5f, 0x60};
+
+	uint8_t ch_a_eq[] = {0x1, 0x2, 0x3, 0x7};
+	uint8_t ch_a_ctl2[] = {0x81, 0x82, 0x83, 0x84};
+	uint8_t ch_b_eq[] = {0x1, 0x2, 0x3, 0x7};
+	uint8_t ch_b_ctl2[] = {0x81, 0x82, 0x83, 0x84};
+
+	int *riser_phy_addr = &xqsgii_riser_phy_addr[0];
+
+	/* Set I2c to Slot 1 */
+	i2c_write(0x77, 0, 0, &a, 1);
+
+	for (dpmac = 0; dpmac < 8; dpmac++) {
+		/* Check the PHY status */
+		switch (serdes_port) {
+		case 1:
+			mii_bus = 0;
+			dpmac_id = dpmac + 1;
+			break;
+		case 2:
+			mii_bus = 1;
+			dpmac_id = dpmac + 9;
+			a = 0xb;
+			i2c_write(0x76, 0, 0, &a, 1);
+			break;
+		}
+
+		ret = miiphy_set_current_dev(dev[mii_bus]);
+		if (ret > 0)
+			goto error;
+
+		bus = mdio_get_current_dev();
+		debug("Reading from bus %s\n", bus->name);
+
+		ret = miiphy_write(dev[mii_bus], riser_phy_addr[dpmac], 0x1f,
+				   3);
+		if (ret > 0)
+			goto error;
+
+		mdelay(10);
+		ret = miiphy_read(dev[mii_bus], riser_phy_addr[dpmac], 0x11,
+				  &value);
+		if (ret > 0)
+			goto error;
+
+		mdelay(10);
+
+		if ((value & 0xfff) == 0x40f) {
+			printf("DPMAC %d:PHY is ..... Configured\n", dpmac_id);
+			continue;
+		}
+
+		for (i = 0; i < 4; i++) {
+			for (j = 0; j < 4; j++) {
+				a = 0x18;
+				i2c_write(i2c_addr[dpmac], 6, 1, &a, 1);
+				a = 0x38;
+				i2c_write(i2c_addr[dpmac], 4, 1, &a, 1);
+				a = 0x4;
+				i2c_write(i2c_addr[dpmac], 8, 1, &a, 1);
+
+				i2c_write(i2c_addr[dpmac], 0xf, 1,
+					  &ch_a_eq[i], 1);
+				i2c_write(i2c_addr[dpmac], 0x11, 1,
+					  &ch_a_ctl2[j], 1);
+
+				i2c_write(i2c_addr[dpmac], 0x16, 1,
+					  &ch_b_eq[i], 1);
+				i2c_write(i2c_addr[dpmac], 0x18, 1,
+					  &ch_b_ctl2[j], 1);
+
+				a = 0x14;
+				i2c_write(i2c_addr[dpmac], 0x23, 1, &a, 1);
+				a = 0xb5;
+				i2c_write(i2c_addr[dpmac], 0x2d, 1, &a, 1);
+				a = 0x20;
+				i2c_write(i2c_addr[dpmac], 4, 1, &a, 1);
+				mdelay(100);
+				ret = miiphy_read(dev[mii_bus],
+						  riser_phy_addr[dpmac],
+						  0x11, &value);
+				if (ret > 0)
+					goto error;
+
+				mdelay(1);
+				ret = miiphy_read(dev[mii_bus],
+						  riser_phy_addr[dpmac],
+						  0x11, &value);
+				if (ret > 0)
+					goto error;
+				mdelay(10);
+
+				if ((value & 0xfff) == 0x40f) {
+					printf("DPMAC %d :PHY is configured ",
+					       dpmac_id);
+					printf("after setting repeater 0x%x\n",
+					       value);
+					i = 5;
+					j = 5;
+				} else
+					printf("DPMAC %d :PHY is failed to ",
+					       dpmac_id);
+					printf("configure the repeater 0x%x\n",
+					       value);
+				}
+		}
+	}
+error:
+	if (ret)
+		printf("DPMAC %d ..... FAILED to configure PHY\n", dpmac_id);
+	return;
+}
+
+static void qsgmii_configure_repeater(int dpmac)
+{
+	uint8_t a = 0xf;
+	int i, j;
+	int i2c_phy_addr = 0;
+	int phy_addr = 0;
+	int i2c_addr[] = {0x58, 0x59, 0x5a, 0x5b};
+
+	uint8_t ch_a_eq[] = {0x1, 0x2, 0x3, 0x7};
+	uint8_t ch_a_ctl2[] = {0x81, 0x82, 0x83, 0x84};
+	uint8_t ch_b_eq[] = {0x1, 0x2, 0x3, 0x7};
+	uint8_t ch_b_ctl2[] = {0x81, 0x82, 0x83, 0x84};
+
+	const char *dev = "LS2080A_QDS_MDIO0";
+	int ret = 0;
+	unsigned short value;
+
+	/* Set I2c to Slot 1 */
+	i2c_write(0x77, 0, 0, &a, 1);
+
+	switch (dpmac) {
+	case 1:
+	case 2:
+	case 3:
+	case 4:
+		i2c_phy_addr = i2c_addr[0];
+		phy_addr = 0;
+		break;
+
+	case 5:
+	case 6:
+	case 7:
+	case 8:
+		i2c_phy_addr = i2c_addr[1];
+		phy_addr = 4;
+		break;
+
+	case 9:
+	case 10:
+	case 11:
+	case 12:
+		i2c_phy_addr = i2c_addr[2];
+		phy_addr = 8;
+		break;
+
+	case 13:
+	case 14:
+	case 15:
+	case 16:
+		i2c_phy_addr = i2c_addr[3];
+		phy_addr = 0xc;
+		break;
+	}
+
+	/* Check the PHY status */
+	ret = miiphy_set_current_dev(dev);
+	ret = miiphy_write(dev, phy_addr, 0x1f, 3);
+	mdelay(10);
+	ret = miiphy_read(dev, phy_addr, 0x11, &value);
+	mdelay(10);
+	ret = miiphy_read(dev, phy_addr, 0x11, &value);
+	mdelay(10);
+	if ((value & 0xf) == 0xf) {
+		printf("DPMAC %d :PHY is ..... Configured\n", dpmac);
+		return;
+	}
+
+	for (i = 0; i < 4; i++) {
+		for (j = 0; j < 4; j++) {
+			a = 0x18;
+			i2c_write(i2c_phy_addr, 6, 1, &a, 1);
+			a = 0x38;
+			i2c_write(i2c_phy_addr, 4, 1, &a, 1);
+			a = 0x4;
+			i2c_write(i2c_phy_addr, 8, 1, &a, 1);
+
+			i2c_write(i2c_phy_addr, 0xf, 1, &ch_a_eq[i], 1);
+			i2c_write(i2c_phy_addr, 0x11, 1, &ch_a_ctl2[j], 1);
+
+			i2c_write(i2c_phy_addr, 0x16, 1, &ch_b_eq[i], 1);
+			i2c_write(i2c_phy_addr, 0x18, 1, &ch_b_ctl2[j], 1);
+
+			a = 0x14;
+			i2c_write(i2c_phy_addr, 0x23, 1, &a, 1);
+			a = 0xb5;
+			i2c_write(i2c_phy_addr, 0x2d, 1, &a, 1);
+			a = 0x20;
+			i2c_write(i2c_phy_addr, 4, 1, &a, 1);
+			mdelay(100);
+			ret = miiphy_read(dev, phy_addr, 0x11, &value);
+			if (ret > 0)
+				goto error;
+			mdelay(1);
+			ret = miiphy_read(dev, phy_addr, 0x11, &value);
+			if (ret > 0)
+				goto error;
+			mdelay(10);
+			if ((value & 0xf) == 0xf) {
+				printf("DPMAC %d :PHY is ..... Configured\n",
+				       dpmac);
+				return;
+			}
+		}
+	}
+error:
+	printf("DPMAC %d :PHY ..... FAILED to configure PHY\n", dpmac);
+	return;
+}
+
+static const char *ls2080a_qds_mdio_name_for_muxval(u8 muxval)
+{
+	return mdio_names[muxval];
+}
+
+struct mii_dev *mii_dev_for_muxval(u8 muxval)
+{
+	struct mii_dev *bus;
+	const char *name = ls2080a_qds_mdio_name_for_muxval(muxval);
+
+	if (!name) {
+		printf("No bus for muxval %x\n", muxval);
+		return NULL;
+	}
+
+	bus = miiphy_get_dev_by_name(name);
+
+	if (!bus) {
+		printf("No bus by name %s\n", name);
+		return NULL;
+	}
+
+	return bus;
+}
+
+static void ls2080a_qds_enable_SFP_TX(u8 muxval)
+{
+	u8 brdcfg9;
+
+	brdcfg9 = QIXIS_READ(brdcfg[9]);
+	brdcfg9 &= ~BRDCFG9_SFPTX_MASK;
+	brdcfg9 |= (muxval << BRDCFG9_SFPTX_SHIFT);
+	QIXIS_WRITE(brdcfg[9], brdcfg9);
+}
+
+static void ls2080a_qds_mux_mdio(u8 muxval)
+{
+	u8 brdcfg4;
+
+	if (muxval <= 5) {
+		brdcfg4 = QIXIS_READ(brdcfg[4]);
+		brdcfg4 &= ~BRDCFG4_EMISEL_MASK;
+		brdcfg4 |= (muxval << BRDCFG4_EMISEL_SHIFT);
+		QIXIS_WRITE(brdcfg[4], brdcfg4);
+	}
+}
+
+static int ls2080a_qds_mdio_read(struct mii_dev *bus, int addr,
+				 int devad, int regnum)
+{
+	struct ls2080a_qds_mdio *priv = bus->priv;
+
+	ls2080a_qds_mux_mdio(priv->muxval);
+
+	return priv->realbus->read(priv->realbus, addr, devad, regnum);
+}
+
+static int ls2080a_qds_mdio_write(struct mii_dev *bus, int addr, int devad,
+				  int regnum, u16 value)
+{
+	struct ls2080a_qds_mdio *priv = bus->priv;
+
+	ls2080a_qds_mux_mdio(priv->muxval);
+
+	return priv->realbus->write(priv->realbus, addr, devad, regnum, value);
+}
+
+static int ls2080a_qds_mdio_reset(struct mii_dev *bus)
+{
+	struct ls2080a_qds_mdio *priv = bus->priv;
+
+	return priv->realbus->reset(priv->realbus);
+}
+
+static int ls2080a_qds_mdio_init(char *realbusname, u8 muxval)
+{
+	struct ls2080a_qds_mdio *pmdio;
+	struct mii_dev *bus = mdio_alloc();
+
+	if (!bus) {
+		printf("Failed to allocate ls2080a_qds MDIO bus\n");
+		return -1;
+	}
+
+	pmdio = malloc(sizeof(*pmdio));
+	if (!pmdio) {
+		printf("Failed to allocate ls2080a_qds private data\n");
+		free(bus);
+		return -1;
+	}
+
+	bus->read = ls2080a_qds_mdio_read;
+	bus->write = ls2080a_qds_mdio_write;
+	bus->reset = ls2080a_qds_mdio_reset;
+	sprintf(bus->name, ls2080a_qds_mdio_name_for_muxval(muxval));
+
+	pmdio->realbus = miiphy_get_dev_by_name(realbusname);
+
+	if (!pmdio->realbus) {
+		printf("No bus with name %s\n", realbusname);
+		free(bus);
+		free(pmdio);
+		return -1;
+	}
+
+	pmdio->muxval = muxval;
+	bus->priv = pmdio;
+
+	return mdio_register(bus);
+}
+
+/*
+ * Initialize the dpmac_info array.
+ *
+ */
+static void initialize_dpmac_to_slot(void)
+{
+	struct ccsr_gur __iomem *gur = (void *)CONFIG_SYS_FSL_GUTS_ADDR;
+	int serdes1_prtcl = (in_le32(&gur->rcwsr[28]) &
+				FSL_CHASSIS3_RCWSR28_SRDS1_PRTCL_MASK)
+		>> FSL_CHASSIS3_RCWSR28_SRDS1_PRTCL_SHIFT;
+	int serdes2_prtcl = (in_le32(&gur->rcwsr[28]) &
+				FSL_CHASSIS3_RCWSR28_SRDS2_PRTCL_MASK)
+		>> FSL_CHASSIS3_RCWSR28_SRDS2_PRTCL_SHIFT;
+
+	char *env_hwconfig;
+	env_hwconfig = getenv("hwconfig");
+
+	switch (serdes1_prtcl) {
+	case 0x07:
+	case 0x09:
+	case 0x33:
+		printf("qds: WRIOP: Supported SerDes1 Protocol 0x%02x\n",
+		       serdes1_prtcl);
+		lane_to_slot_fsm1[0] = EMI1_SLOT1;
+		lane_to_slot_fsm1[1] = EMI1_SLOT1;
+		lane_to_slot_fsm1[2] = EMI1_SLOT1;
+		lane_to_slot_fsm1[3] = EMI1_SLOT1;
+		if (hwconfig_f("xqsgmii", env_hwconfig)) {
+			lane_to_slot_fsm1[4] = EMI1_SLOT1;
+			lane_to_slot_fsm1[5] = EMI1_SLOT1;
+			lane_to_slot_fsm1[6] = EMI1_SLOT1;
+			lane_to_slot_fsm1[7] = EMI1_SLOT1;
+		} else {
+			lane_to_slot_fsm1[4] = EMI1_SLOT2;
+			lane_to_slot_fsm1[5] = EMI1_SLOT2;
+			lane_to_slot_fsm1[6] = EMI1_SLOT2;
+			lane_to_slot_fsm1[7] = EMI1_SLOT2;
+		}
+		break;
+
+	case 0x2A:
+		printf("qds: WRIOP: Supported SerDes1 Protocol 0x%02x\n",
+		       serdes1_prtcl);
+		break;
+	default:
+		printf("qds: WRIOP: Unsupported SerDes1 Protocol 0x%02x\n",
+		       serdes1_prtcl);
+		break;
+	}
+
+	switch (serdes2_prtcl) {
+	case 0x07:
+	case 0x08:
+	case 0x09:
+	case 0x49:
+		printf("qds: WRIOP: Supported SerDes2 Protocol 0x%02x\n",
+		       serdes2_prtcl);
+		lane_to_slot_fsm2[0] = EMI1_SLOT4;
+		lane_to_slot_fsm2[1] = EMI1_SLOT4;
+		lane_to_slot_fsm2[2] = EMI1_SLOT4;
+		lane_to_slot_fsm2[3] = EMI1_SLOT4;
+
+		if (hwconfig_f("xqsgmii", env_hwconfig)) {
+			lane_to_slot_fsm2[4] = EMI1_SLOT4;
+			lane_to_slot_fsm2[5] = EMI1_SLOT4;
+			lane_to_slot_fsm2[6] = EMI1_SLOT4;
+			lane_to_slot_fsm2[7] = EMI1_SLOT4;
+		} else {
+			/* No MDIO physical connection */
+			lane_to_slot_fsm2[4] = EMI1_SLOT6;
+			lane_to_slot_fsm2[5] = EMI1_SLOT6;
+			lane_to_slot_fsm2[6] = EMI1_SLOT6;
+			lane_to_slot_fsm2[7] = EMI1_SLOT6;
+		}
+		break;
+	default:
+		printf("qds: WRIOP: Unsupported SerDes2 Protocol 0x%02x\n",
+		       serdes2_prtcl);
+		break;
+	}
+}
+
+void ls2080a_handle_phy_interface_sgmii(int dpmac_id)
+{
+	int lane, slot;
+	struct mii_dev *bus;
+	struct ccsr_gur __iomem *gur = (void *)CONFIG_SYS_FSL_GUTS_ADDR;
+	int serdes1_prtcl = (in_le32(&gur->rcwsr[28]) &
+				FSL_CHASSIS3_RCWSR28_SRDS1_PRTCL_MASK)
+		>> FSL_CHASSIS3_RCWSR28_SRDS1_PRTCL_SHIFT;
+	int serdes2_prtcl = (in_le32(&gur->rcwsr[28]) &
+				FSL_CHASSIS3_RCWSR28_SRDS2_PRTCL_MASK)
+		>> FSL_CHASSIS3_RCWSR28_SRDS2_PRTCL_SHIFT;
+
+	int *riser_phy_addr;
+	char *env_hwconfig = getenv("hwconfig");
+
+	if (hwconfig_f("xqsgmii", env_hwconfig))
+		riser_phy_addr = &xqsgii_riser_phy_addr[0];
+	else
+		riser_phy_addr = &sgmii_riser_phy_addr[0];
+
+	if (dpmac_id > WRIOP1_DPMAC9)
+		goto serdes2;
+
+	switch (serdes1_prtcl) {
+	case 0x07:
+
+		lane = serdes_get_first_lane(FSL_SRDS_1, SGMII1 + dpmac_id);
+		slot = lane_to_slot_fsm1[lane];
+
+		switch (++slot) {
+		case 1:
+			/* Slot housing a SGMII riser card? */
+			wriop_set_phy_address(dpmac_id,
+					      riser_phy_addr[dpmac_id - 1]);
+			dpmac_info[dpmac_id].board_mux = EMI1_SLOT1;
+			bus = mii_dev_for_muxval(EMI1_SLOT1);
+			wriop_set_mdio(dpmac_id, bus);
+			dpmac_info[dpmac_id].phydev = phy_connect(
+						dpmac_info[dpmac_id].bus,
+						dpmac_info[dpmac_id].phy_addr,
+						NULL,
+						dpmac_info[dpmac_id].enet_if);
+			phy_config(dpmac_info[dpmac_id].phydev);
+			break;
+		case 2:
+			/* Slot housing a SGMII riser card? */
+			wriop_set_phy_address(dpmac_id,
+					      riser_phy_addr[dpmac_id - 1]);
+			dpmac_info[dpmac_id].board_mux = EMI1_SLOT2;
+			bus = mii_dev_for_muxval(EMI1_SLOT2);
+			wriop_set_mdio(dpmac_id, bus);
+			dpmac_info[dpmac_id].phydev = phy_connect(
+						dpmac_info[dpmac_id].bus,
+						dpmac_info[dpmac_id].phy_addr,
+						NULL,
+						dpmac_info[dpmac_id].enet_if);
+			phy_config(dpmac_info[dpmac_id].phydev);
+			break;
+		case 3:
+			break;
+		case 4:
+			break;
+		case 5:
+			break;
+		case 6:
+			break;
+		}
+	break;
+	default:
+		printf("qds: WRIOP: Unsupported SerDes1 Protocol 0x%02x\n",
+		       serdes1_prtcl);
+	break;
+	}
+
+serdes2:
+	switch (serdes2_prtcl) {
+	case 0x07:
+	case 0x08:
+	case 0x49:
+		lane = serdes_get_first_lane(FSL_SRDS_2, SGMII9 +
+							(dpmac_id - 9));
+		slot = lane_to_slot_fsm2[lane];
+
+		switch (++slot) {
+		case 1:
+			break;
+		case 3:
+			break;
+		case 4:
+			/* Slot housing a SGMII riser card? */
+			wriop_set_phy_address(dpmac_id,
+					      riser_phy_addr[dpmac_id - 9]);
+			dpmac_info[dpmac_id].board_mux = EMI1_SLOT4;
+			bus = mii_dev_for_muxval(EMI1_SLOT4);
+			wriop_set_mdio(dpmac_id, bus);
+			dpmac_info[dpmac_id].phydev = phy_connect(
+						dpmac_info[dpmac_id].bus,
+						dpmac_info[dpmac_id].phy_addr,
+						NULL,
+						dpmac_info[dpmac_id].enet_if);
+			phy_config(dpmac_info[dpmac_id].phydev);
+		break;
+		case 5:
+		break;
+		case 6:
+			/* Slot housing a SGMII riser card? */
+			wriop_set_phy_address(dpmac_id,
+					      riser_phy_addr[dpmac_id - 13]);
+			dpmac_info[dpmac_id].board_mux = EMI1_SLOT6;
+			bus = mii_dev_for_muxval(EMI1_SLOT6);
+			wriop_set_mdio(dpmac_id, bus);
+		break;
+	}
+	break;
+	default:
+		printf("qds: WRIOP: Unsupported SerDes2 Protocol 0x%02x\n",
+		       serdes2_prtcl);
+	break;
+	}
+}
+
+void ls2080a_handle_phy_interface_qsgmii(int dpmac_id)
+{
+	int lane = 0, slot;
+	struct mii_dev *bus;
+	struct ccsr_gur __iomem *gur = (void *)CONFIG_SYS_FSL_GUTS_ADDR;
+	int serdes1_prtcl = (in_le32(&gur->rcwsr[28]) &
+				FSL_CHASSIS3_RCWSR28_SRDS1_PRTCL_MASK)
+		>> FSL_CHASSIS3_RCWSR28_SRDS1_PRTCL_SHIFT;
+
+	switch (serdes1_prtcl) {
+	case 0x33:
+		switch (dpmac_id) {
+		case 1:
+		case 2:
+		case 3:
+		case 4:
+			lane = serdes_get_first_lane(FSL_SRDS_1, QSGMII_A);
+		break;
+		case 5:
+		case 6:
+		case 7:
+		case 8:
+			lane = serdes_get_first_lane(FSL_SRDS_1, QSGMII_B);
+		break;
+		case 9:
+		case 10:
+		case 11:
+		case 12:
+			lane = serdes_get_first_lane(FSL_SRDS_1, QSGMII_C);
+		break;
+		case 13:
+		case 14:
+		case 15:
+		case 16:
+			lane = serdes_get_first_lane(FSL_SRDS_1, QSGMII_D);
+		break;
+	}
+
+		slot = lane_to_slot_fsm1[lane];
+
+		switch (++slot) {
+		case 1:
+			/* Slot housing a QSGMII riser card? */
+			wriop_set_phy_address(dpmac_id, dpmac_id - 1);
+			dpmac_info[dpmac_id].board_mux = EMI1_SLOT1;
+			bus = mii_dev_for_muxval(EMI1_SLOT1);
+			wriop_set_mdio(dpmac_id, bus);
+			dpmac_info[dpmac_id].phydev = phy_connect(
+						dpmac_info[dpmac_id].bus,
+						dpmac_info[dpmac_id].phy_addr,
+						NULL,
+						dpmac_info[dpmac_id].enet_if);
+
+			phy_config(dpmac_info[dpmac_id].phydev);
+			break;
+		case 3:
+			break;
+		case 4:
+			break;
+		case 5:
+		break;
+		case 6:
+			break;
+	}
+	break;
+	default:
+		printf("qds: WRIOP: Unsupported SerDes Protocol 0x%02x\n",
+		       serdes1_prtcl);
+	break;
+	}
+
+	qsgmii_configure_repeater(dpmac_id);
+}
+
+void ls2080a_handle_phy_interface_xsgmii(int i)
+{
+	struct ccsr_gur __iomem *gur = (void *)CONFIG_SYS_FSL_GUTS_ADDR;
+	int serdes1_prtcl = (in_le32(&gur->rcwsr[28]) &
+				FSL_CHASSIS3_RCWSR28_SRDS1_PRTCL_MASK)
+		>> FSL_CHASSIS3_RCWSR28_SRDS1_PRTCL_SHIFT;
+
+	switch (serdes1_prtcl) {
+	case 0x2A:
+		/*
+		 * XFI does not need a PHY to work, but to avoid U-boot use
+		 * default PHY address which is zero to a MAC when it found
+		 * a MAC has no PHY address, we give a PHY address to XFI
+		 * MAC, and should not use a real XAUI PHY address, since
+		 * MDIO can access it successfully, and then MDIO thinks
+		 * the XAUI card is used for the XFI MAC, which will cause
+		 * error.
+		 */
+		wriop_set_phy_address(i, i + 4);
+		ls2080a_qds_enable_SFP_TX(SFP_TX);
+
+		break;
+	default:
+		printf("qds: WRIOP: Unsupported SerDes Protocol 0x%02x\n",
+		       serdes1_prtcl);
+		break;
+	}
+}
+#endif
+
+int board_eth_init(bd_t *bis)
+{
+	int error;
+#ifdef CONFIG_FSL_MC_ENET
+	struct ccsr_gur __iomem *gur = (void *)CONFIG_SYS_FSL_GUTS_ADDR;
+	int serdes1_prtcl = (in_le32(&gur->rcwsr[28]) &
+				FSL_CHASSIS3_RCWSR28_SRDS1_PRTCL_MASK)
+		>> FSL_CHASSIS3_RCWSR28_SRDS1_PRTCL_SHIFT;
+	int serdes2_prtcl = (in_le32(&gur->rcwsr[28]) &
+				FSL_CHASSIS3_RCWSR28_SRDS2_PRTCL_MASK)
+		>> FSL_CHASSIS3_RCWSR28_SRDS2_PRTCL_SHIFT;
+
+	struct memac_mdio_info *memac_mdio0_info;
+	struct memac_mdio_info *memac_mdio1_info;
+	unsigned int i;
+	char *env_hwconfig;
+
+	env_hwconfig = getenv("hwconfig");
+
+	initialize_dpmac_to_slot();
+
+	memac_mdio0_info = (struct memac_mdio_info *)malloc(
+					sizeof(struct memac_mdio_info));
+	memac_mdio0_info->regs =
+		(struct memac_mdio_controller *)
+					CONFIG_SYS_FSL_WRIOP1_MDIO1;
+	memac_mdio0_info->name = DEFAULT_WRIOP_MDIO1_NAME;
+
+	/* Register the real MDIO1 bus */
+	fm_memac_mdio_init(bis, memac_mdio0_info);
+
+	memac_mdio1_info = (struct memac_mdio_info *)malloc(
+					sizeof(struct memac_mdio_info));
+	memac_mdio1_info->regs =
+		(struct memac_mdio_controller *)
+					CONFIG_SYS_FSL_WRIOP1_MDIO2;
+	memac_mdio1_info->name = DEFAULT_WRIOP_MDIO2_NAME;
+
+	/* Register the real MDIO2 bus */
+	fm_memac_mdio_init(bis, memac_mdio1_info);
+
+	/* Register the muxing front-ends to the MDIO buses */
+	ls2080a_qds_mdio_init(DEFAULT_WRIOP_MDIO1_NAME, EMI1_SLOT1);
+	ls2080a_qds_mdio_init(DEFAULT_WRIOP_MDIO1_NAME, EMI1_SLOT2);
+	ls2080a_qds_mdio_init(DEFAULT_WRIOP_MDIO1_NAME, EMI1_SLOT3);
+	ls2080a_qds_mdio_init(DEFAULT_WRIOP_MDIO1_NAME, EMI1_SLOT4);
+	ls2080a_qds_mdio_init(DEFAULT_WRIOP_MDIO1_NAME, EMI1_SLOT5);
+	ls2080a_qds_mdio_init(DEFAULT_WRIOP_MDIO1_NAME, EMI1_SLOT6);
+
+	ls2080a_qds_mdio_init(DEFAULT_WRIOP_MDIO2_NAME, EMI2);
+
+	for (i = WRIOP1_DPMAC1; i < NUM_WRIOP_PORTS; i++) {
+		switch (wriop_get_enet_if(i)) {
+		case PHY_INTERFACE_MODE_QSGMII:
+			ls2080a_handle_phy_interface_qsgmii(i);
+			break;
+		case PHY_INTERFACE_MODE_SGMII:
+			ls2080a_handle_phy_interface_sgmii(i);
+			break;
+		case PHY_INTERFACE_MODE_XGMII:
+			ls2080a_handle_phy_interface_xsgmii(i);
+			break;
+		default:
+			break;
+
+		if (i == 16)
+			i = NUM_WRIOP_PORTS;
+		}
+	}
+
+	error = cpu_eth_init(bis);
+
+	if (hwconfig_f("xqsgmii", env_hwconfig)) {
+		if (serdes1_prtcl == 0x7)
+			sgmii_configure_repeater(1);
+		if (serdes2_prtcl == 0x7 || serdes2_prtcl == 0x8 ||
+		    serdes2_prtcl == 0x49)
+			sgmii_configure_repeater(2);
+	}
+#endif
+	error = pci_eth_init(bis);
+	return error;
+}
+
+#ifdef CONFIG_FSL_MC_ENET
+
+#endif
diff --git a/board/freescale/ls2080aqds/ls2080aqds.c b/board/freescale/ls2080aqds/ls2080aqds.c
new file mode 100644
index 0000000..1f99072
--- /dev/null
+++ b/board/freescale/ls2080aqds/ls2080aqds.c
@@ -0,0 +1,336 @@
+/*
+ * Copyright 2015 Freescale Semiconductor
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+#include <common.h>
+#include <malloc.h>
+#include <errno.h>
+#include <netdev.h>
+#include <fsl_ifc.h>
+#include <fsl_ddr.h>
+#include <asm/io.h>
+#include <fdt_support.h>
+#include <libfdt.h>
+#include <fsl_debug_server.h>
+#include <fsl-mc/fsl_mc.h>
+#include <environment.h>
+#include <i2c.h>
+#include <rtc.h>
+#include <asm/arch/soc.h>
+#include <hwconfig.h>
+
+#include "../common/qixis.h"
+#include "ls2080aqds_qixis.h"
+
+#define PIN_MUX_SEL_SDHC	0x00
+#define PIN_MUX_SEL_DSPI	0x0a
+
+#define SET_SDHC_MUX_SEL(reg, value)	((reg & 0xf0) | value)
+
+DECLARE_GLOBAL_DATA_PTR;
+
+enum {
+	MUX_TYPE_SDHC,
+	MUX_TYPE_DSPI,
+};
+
+unsigned long long get_qixis_addr(void)
+{
+	unsigned long long addr;
+
+	if (gd->flags & GD_FLG_RELOC)
+		addr = QIXIS_BASE_PHYS;
+	else
+		addr = QIXIS_BASE_PHYS_EARLY;
+
+	/*
+	 * IFC address under 256MB is mapped to 0x30000000, any address above
+	 * is mapped to 0x5_10000000 up to 4GB.
+	 */
+	addr = addr  > 0x10000000 ? addr + 0x500000000ULL : addr + 0x30000000;
+
+	return addr;
+}
+
+int checkboard(void)
+{
+	char buf[64];
+	u8 sw;
+	static const char *const freq[] = {"100", "125", "156.25",
+					    "100 separate SSCG"};
+	int clock;
+
+	cpu_name(buf);
+	printf("Board: %s-QDS, ", buf);
+
+	sw = QIXIS_READ(arch);
+	printf("Board Arch: V%d, ", sw >> 4);
+	printf("Board version: %c, boot from ", (sw & 0xf) + 'A' - 1);
+
+	memset((u8 *)buf, 0x00, ARRAY_SIZE(buf));
+
+	sw = QIXIS_READ(brdcfg[0]);
+	sw = (sw & QIXIS_LBMAP_MASK) >> QIXIS_LBMAP_SHIFT;
+
+	if (sw < 0x8)
+		printf("vBank: %d\n", sw);
+	else if (sw == 0x8)
+		puts("PromJet\n");
+	else if (sw == 0x9)
+		puts("NAND\n");
+	else if (sw == 0x15)
+		printf("IFCCard\n");
+	else
+		printf("invalid setting of SW%u\n", QIXIS_LBMAP_SWITCH);
+
+	printf("FPGA: v%d (%s), build %d",
+	       (int)QIXIS_READ(scver), qixis_read_tag(buf),
+	       (int)qixis_read_minor());
+	/* the timestamp string contains "\n" at the end */
+	printf(" on %s", qixis_read_time(buf));
+
+	/*
+	 * Display the actual SERDES reference clocks as configured by the
+	 * dip switches on the board.  Note that the SWx registers could
+	 * technically be set to force the reference clocks to match the
+	 * values that the SERDES expects (or vice versa).  For now, however,
+	 * we just display both values and hope the user notices when they
+	 * don't match.
+	 */
+	puts("SERDES1 Reference : ");
+	sw = QIXIS_READ(brdcfg[2]);
+	clock = (sw >> 6) & 3;
+	printf("Clock1 = %sMHz ", freq[clock]);
+	clock = (sw >> 4) & 3;
+	printf("Clock2 = %sMHz", freq[clock]);
+
+	puts("\nSERDES2 Reference : ");
+	clock = (sw >> 2) & 3;
+	printf("Clock1 = %sMHz ", freq[clock]);
+	clock = (sw >> 0) & 3;
+	printf("Clock2 = %sMHz\n", freq[clock]);
+
+	return 0;
+}
+
+unsigned long get_board_sys_clk(void)
+{
+	u8 sysclk_conf = QIXIS_READ(brdcfg[1]);
+
+	switch (sysclk_conf & 0x0F) {
+	case QIXIS_SYSCLK_83:
+		return 83333333;
+	case QIXIS_SYSCLK_100:
+		return 100000000;
+	case QIXIS_SYSCLK_125:
+		return 125000000;
+	case QIXIS_SYSCLK_133:
+		return 133333333;
+	case QIXIS_SYSCLK_150:
+		return 150000000;
+	case QIXIS_SYSCLK_160:
+		return 160000000;
+	case QIXIS_SYSCLK_166:
+		return 166666666;
+	}
+	return 66666666;
+}
+
+unsigned long get_board_ddr_clk(void)
+{
+	u8 ddrclk_conf = QIXIS_READ(brdcfg[1]);
+
+	switch ((ddrclk_conf & 0x30) >> 4) {
+	case QIXIS_DDRCLK_100:
+		return 100000000;
+	case QIXIS_DDRCLK_125:
+		return 125000000;
+	case QIXIS_DDRCLK_133:
+		return 133333333;
+	}
+	return 66666666;
+}
+
+int select_i2c_ch_pca9547(u8 ch)
+{
+	int ret;
+
+	ret = i2c_write(I2C_MUX_PCA_ADDR_PRI, 0, 1, &ch, 1);
+	if (ret) {
+		puts("PCA: failed to select proper channel\n");
+		return ret;
+	}
+
+	return 0;
+}
+
+int config_board_mux(int ctrl_type)
+{
+	u8 reg5;
+
+	reg5 = QIXIS_READ(brdcfg[5]);
+
+	switch (ctrl_type) {
+	case MUX_TYPE_SDHC:
+		reg5 = SET_SDHC_MUX_SEL(reg5, PIN_MUX_SEL_SDHC);
+		break;
+	case MUX_TYPE_DSPI:
+		reg5 = SET_SDHC_MUX_SEL(reg5, PIN_MUX_SEL_DSPI);
+		break;
+	default:
+		printf("Wrong mux interface type\n");
+		return -1;
+	}
+
+	QIXIS_WRITE(brdcfg[5], reg5);
+
+	return 0;
+}
+
+int board_init(void)
+{
+	char *env_hwconfig;
+	u32 __iomem *dcfg_ccsr = (u32 __iomem *)DCFG_BASE;
+	u32 val;
+
+	init_final_memctl_regs();
+
+	val = in_le32(dcfg_ccsr + DCFG_RCWSR13 / 4);
+
+	env_hwconfig = getenv("hwconfig");
+
+	if (hwconfig_f("dspi", env_hwconfig) &&
+	    DCFG_RCWSR13_DSPI == (val & (u32)(0xf << 8)))
+		config_board_mux(MUX_TYPE_DSPI);
+	else
+		config_board_mux(MUX_TYPE_SDHC);
+
+#ifdef CONFIG_ENV_IS_NOWHERE
+	gd->env_addr = (ulong)&default_environment[0];
+#endif
+	select_i2c_ch_pca9547(I2C_MUX_CH_DEFAULT);
+	rtc_enable_32khz_output();
+
+	return 0;
+}
+
+int board_early_init_f(void)
+{
+	fsl_lsch3_early_init_f();
+	return 0;
+}
+
+void detail_board_ddr_info(void)
+{
+	puts("\nDDR    ");
+	print_size(gd->bd->bi_dram[0].size + gd->bd->bi_dram[1].size, "");
+	print_ddr_info(0);
+#ifdef CONFIG_SYS_FSL_HAS_DP_DDR
+	if (gd->bd->bi_dram[2].size) {
+		puts("\nDP-DDR ");
+		print_size(gd->bd->bi_dram[2].size, "");
+		print_ddr_info(CONFIG_DP_DDR_CTRL);
+	}
+#endif
+}
+
+int dram_init(void)
+{
+	gd->ram_size = initdram(0);
+
+	return 0;
+}
+
+#if defined(CONFIG_ARCH_MISC_INIT)
+int arch_misc_init(void)
+{
+#ifdef CONFIG_FSL_DEBUG_SERVER
+	debug_server_init();
+#endif
+
+	return 0;
+}
+#endif
+
+unsigned long get_dram_size_to_hide(void)
+{
+	unsigned long dram_to_hide = 0;
+
+/* Carve the Debug Server private DRAM block from the end of DRAM */
+#ifdef CONFIG_FSL_DEBUG_SERVER
+	dram_to_hide += debug_server_get_dram_block_size();
+#endif
+
+/* Carve the MC private DRAM block from the end of DRAM */
+#ifdef CONFIG_FSL_MC_ENET
+	dram_to_hide += mc_get_dram_block_size();
+#endif
+
+	return roundup(dram_to_hide, CONFIG_SYS_MEM_TOP_HIDE_MIN);
+}
+
+#ifdef CONFIG_FSL_MC_ENET
+void fdt_fixup_board_enet(void *fdt)
+{
+	int offset;
+
+	offset = fdt_path_offset(fdt, "/fsl-mc");
+
+	if (offset < 0)
+		offset = fdt_path_offset(fdt, "/fsl,dprc@0");
+
+	if (offset < 0) {
+		printf("%s: ERROR: fsl-mc node not found in device tree (error %d)\n",
+		       __func__, offset);
+		return;
+	}
+
+	if (get_mc_boot_status() == 0)
+		fdt_status_okay(fdt, offset);
+	else
+		fdt_status_fail(fdt, offset);
+}
+#endif
+
+#ifdef CONFIG_OF_BOARD_SETUP
+int ft_board_setup(void *blob, bd_t *bd)
+{
+	int err;
+	u64 base[CONFIG_NR_DRAM_BANKS];
+	u64 size[CONFIG_NR_DRAM_BANKS];
+
+	ft_cpu_setup(blob, bd);
+
+	/* fixup DT for the two GPP DDR banks */
+	base[0] = gd->bd->bi_dram[0].start;
+	size[0] = gd->bd->bi_dram[0].size;
+	base[1] = gd->bd->bi_dram[1].start;
+	size[1] = gd->bd->bi_dram[1].size;
+
+	fdt_fixup_memory_banks(blob, base, size, 2);
+
+#ifdef CONFIG_FSL_MC_ENET
+	fdt_fixup_board_enet(blob);
+	err = fsl_mc_ldpaa_exit(bd);
+	if (err)
+		return err;
+#endif
+
+	return 0;
+}
+#endif
+
+void qixis_dump_switch(void)
+{
+	int i, nr_of_cfgsw;
+
+	QIXIS_WRITE(cms[0], 0x00);
+	nr_of_cfgsw = QIXIS_READ(cms[1]);
+
+	puts("DIP switch settings dump:\n");
+	for (i = 1; i <= nr_of_cfgsw; i++) {
+		QIXIS_WRITE(cms[0], i);
+		printf("SW%d = (0x%02x)\n", i, QIXIS_READ(cms[1]));
+	}
+}
diff --git a/board/freescale/ls2080aqds/ls2080aqds_qixis.h b/board/freescale/ls2080aqds/ls2080aqds_qixis.h
new file mode 100644
index 0000000..e281e5f
--- /dev/null
+++ b/board/freescale/ls2080aqds/ls2080aqds_qixis.h
@@ -0,0 +1,30 @@
+/*
+ * Copyright 2015 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __LS2_QDS_QIXIS_H__
+#define __LS2_QDS_QIXIS_H__
+
+/* SYSCLK */
+#define QIXIS_SYSCLK_66			0x0
+#define QIXIS_SYSCLK_83			0x1
+#define QIXIS_SYSCLK_100		0x2
+#define QIXIS_SYSCLK_125		0x3
+#define QIXIS_SYSCLK_133		0x4
+#define QIXIS_SYSCLK_150		0x5
+#define QIXIS_SYSCLK_160		0x6
+#define QIXIS_SYSCLK_166		0x7
+
+/* DDRCLK */
+#define QIXIS_DDRCLK_66			0x0
+#define QIXIS_DDRCLK_100		0x1
+#define QIXIS_DDRCLK_125		0x2
+#define QIXIS_DDRCLK_133		0x3
+
+#define BRDCFG4_EMISEL_MASK		0xE0
+#define BRDCFG4_EMISEL_SHIFT		5
+#define BRDCFG9_SFPTX_MASK		0x10
+#define BRDCFG9_SFPTX_SHIFT		4
+#endif /*__LS2_QDS_QIXIS_H__*/
diff --git a/board/freescale/ls2080ardb/Kconfig b/board/freescale/ls2080ardb/Kconfig
new file mode 100644
index 0000000..fe02575
--- /dev/null
+++ b/board/freescale/ls2080ardb/Kconfig
@@ -0,0 +1,16 @@
+
+if TARGET_LS2080ARDB
+
+config SYS_BOARD
+	default "ls2080ardb"
+
+config SYS_VENDOR
+	default "freescale"
+
+config SYS_SOC
+	default "fsl-layerscape"
+
+config SYS_CONFIG_NAME
+	default "ls2080ardb"
+
+endif
diff --git a/board/freescale/ls2080ardb/MAINTAINERS b/board/freescale/ls2080ardb/MAINTAINERS
new file mode 100644
index 0000000..aac8110
--- /dev/null
+++ b/board/freescale/ls2080ardb/MAINTAINERS
@@ -0,0 +1,8 @@
+LS2080A BOARD
+M:	Prabhakar Kushwaha <prabhakar@freescale.com>
+S:	Maintained
+F:	board/freescale/ls2080ardb/
+F:	board/freescale/ls2080a/ls2080ardb.c
+F:	include/configs/ls2080ardb.h
+F:	configs/ls2080ardb_defconfig
+F:	configs/ls2080ardb_nand_defconfig
diff --git a/board/freescale/ls2080ardb/Makefile b/board/freescale/ls2080ardb/Makefile
new file mode 100644
index 0000000..6a52167
--- /dev/null
+++ b/board/freescale/ls2080ardb/Makefile
@@ -0,0 +1,8 @@
+#
+# Copyright 2015 Freescale Semiconductor
+#
+# SPDX-License-Identifier:	GPL-2.0+
+#
+
+obj-y += ls2080ardb.o eth_ls2080rdb.o
+obj-y += ddr.o
diff --git a/board/freescale/ls2080ardb/README b/board/freescale/ls2080ardb/README
new file mode 100644
index 0000000..7fc2569
--- /dev/null
+++ b/board/freescale/ls2080ardb/README
@@ -0,0 +1,120 @@
+Overview
+--------
+The LS2080A Reference Design (RDB) is a high-performance computing,
+evaluation, and development platform that supports the QorIQ LS2080A
+Layerscape Architecture processor.
+
+LS2080A SoC Overview
+------------------
+The LS2080A integrated multicore processor combines eight ARM Cortex-A57
+processor cores with high-performance data path acceleration logic and network
+and peripheral bus interfaces required for networking, telecom/datacom,
+wireless infrastructure, and mil/aerospace applications.
+
+The LS2080A SoC includes the following function and features:
+
+ - Eight 64-bit ARM Cortex-A57 CPUs
+ - 1 MB platform cache with ECC
+ - Two 64-bit DDR4 SDRAM memory controllers with ECC and interleaving support
+ - One secondary 32-bit DDR4 SDRAM memory controller, intended for use by
+  the AIOP
+ - Data path acceleration architecture (DPAA2) incorporating acceleration for
+ the following functions:
+   - Packet parsing, classification, and distribution (WRIOP)
+   - Queue and Hardware buffer management for scheduling, packet sequencing, and
+     congestion management, buffer allocation and de-allocation (QBMan)
+   - Cryptography acceleration (SEC) at up to 10 Gbps
+   - RegEx pattern matching acceleration (PME) at up to 10 Gbps
+   - Decompression/compression acceleration (DCE) at up to 20 Gbps
+   - Accelerated I/O processing (AIOP) at up to 20 Gbps
+   - QDMA engine
+ - 16 SerDes lanes at up to 10.3125 GHz
+ - Ethernet interfaces
+   - Up to eight 10 Gbps Ethernet MACs
+   - Up to eight 1 / 2.5 Gbps Ethernet MACs
+ - High-speed peripheral interfaces
+   - Four PCIe 3.0 controllers, one supporting SR-IOV
+ - Additional peripheral interfaces
+   - Two serial ATA (SATA 3.0) controllers
+   - Two high-speed USB 3.0 controllers with integrated PHY
+   - Enhanced secure digital host controller (eSDXC/eMMC)
+   - Serial peripheral interface (SPI) controller
+   - Quad Serial Peripheral Interface (QSPI) Controller
+   - Four I2C controllers
+   - Two DUARTs
+   - Integrated flash controller (IFC 2.0) supporting NAND and NOR flash
+ - Support for hardware virtualization and partitioning enforcement
+ - QorIQ platform's trust architecture 3.0
+ - Service processor (SP) provides pre-boot initialization and secure-boot
+  capabilities
+
+ LS2080ARDB board Overview
+ -----------------------
+ - SERDES Connections, 16 lanes supporting:
+      - PCI Express - 3.0
+      - SATA 3.0
+      - XFI
+ - DDR Controller
+     - Two ports of 72-bits (8-bits ECC) DDR4. Each port supports four
+       chip-selects and two DIMM connectors. Support is up to 2133MT/s.
+     - One port of 40-bits (8-bits ECC) DDR4 which supports four chip-selects
+       and two DIMM connectors. Support is up to 1600MT/s.
+ -IFC/Local Bus
+    - IFC rev. 2.0 implementation supporting Little Endian connection scheme.
+    - 128 MB NOR flash 16-bit data bus
+    - One 2 GB NAND flash with ECC support
+    - CPLD connection
+ - USB 3.0
+    - Two high speed USB 3.0 ports
+    - First USB 3.0 port configured as Host with Type-A connector
+    - Second USB 3.0 port configured as OTG with micro-AB connector
+ - SDHC adapter
+    - SD Card Rev 2.0 and Rev 3.0
+ - DSPI
+    - 128 MB high-speed flash Memory for boot code and storage (up to 108MHz)
+ - 4 I2C controllers
+ - Two SATA onboard connectors
+ - UART
+ - ARM JTAG support
+
+Memory map from core's view
+----------------------------
+0x00_0000_0000 .. 0x00_000F_FFFF	Boot Rom
+0x00_0100_0000 .. 0x00_0FFF_FFFF	CCSR
+0x00_1800_0000 .. 0x00_181F_FFFF	OCRAM
+0x00_3000_0000 .. 0x00_3FFF_FFFF	IFC region #1
+0x00_8000_0000 .. 0x00_FFFF_FFFF	DDR region #1
+0x05_1000_0000 .. 0x05_FFFF_FFFF	IFC region #2
+0x80_8000_0000 .. 0xFF_FFFF_FFFF	DDR region #2
+
+Other addresses are either reserved, or not used directly by u-boot.
+This list should be updated when more addresses are used.
+
+IFC region map from core's view
+-------------------------------
+During boot i.e. IFC Region #1:-
+  0x30000000 - 0x37ffffff : 128MB : NOR flash
+  0x3C000000 - 0x40000000 : 64MB  : CPLD
+
+After relocate to DDR i.e. IFC Region #2:-
+  0x5_1000_0000..0x5_1fff_ffff	Memory Hole
+  0x5_2000_0000..0x5_3fff_ffff	IFC CSx (CPLD, NAND and others 512MB)
+  0x5_4000_0000..0x5_7fff_ffff	ASIC or others 1GB
+  0x5_8000_0000..0x5_bfff_ffff	IFC CS0 1GB (NOR/Promjet)
+  0x5_C000_0000..0x5_ffff_ffff	IFC CS1 1GB (NOR/Promjet)
+
+Booting Options
+---------------
+a) NOR boot
+b) NAND boot
+
+Booting Linux flavors which do not support 48-bit VA (< Linux 3.18)
+-------------------------------------------------------------------
+One needs to use appropriate bootargs to boot Linux flavors which do
+not support 48-bit VA (for e.g. < Linux 3.18) by appending mem=2048M, as shown
+below:
+
+=> setenv bootargs 'console=ttyS1,115200 root=/dev/ram
+   earlycon=uart8250,mmio,0x21c0600,115200 default_hugepagesz=2m hugepagesz=2m
+   hugepages=16 mem=2048M'
+
diff --git a/board/freescale/ls2080ardb/ddr.c b/board/freescale/ls2080ardb/ddr.c
new file mode 100644
index 0000000..ae681de
--- /dev/null
+++ b/board/freescale/ls2080ardb/ddr.c
@@ -0,0 +1,199 @@
+/*
+ * Copyright 2015 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <fsl_ddr_sdram.h>
+#include <fsl_ddr_dimm_params.h>
+#include "ddr.h"
+
+DECLARE_GLOBAL_DATA_PTR;
+
+void fsl_ddr_board_options(memctl_options_t *popts,
+				dimm_params_t *pdimm,
+				unsigned int ctrl_num)
+{
+#ifdef CONFIG_SYS_FSL_HAS_DP_DDR
+	u8 dq_mapping_0, dq_mapping_2, dq_mapping_3;
+#endif
+	const struct board_specific_parameters *pbsp, *pbsp_highest = NULL;
+	ulong ddr_freq;
+	int slot;
+
+	if (ctrl_num > 2) {
+		printf("Not supported controller number %d\n", ctrl_num);
+		return;
+	}
+
+	for (slot = 0; slot < CONFIG_DIMM_SLOTS_PER_CTLR; slot++) {
+		if (pdimm[slot].n_ranks)
+			break;
+	}
+
+	if (slot >= CONFIG_DIMM_SLOTS_PER_CTLR)
+		return;
+
+	/*
+	 * we use identical timing for all slots. If needed, change the code
+	 * to  pbsp = rdimms[ctrl_num] or pbsp = udimms[ctrl_num];
+	 */
+	if (popts->registered_dimm_en)
+		pbsp = rdimms[ctrl_num];
+	else
+		pbsp = udimms[ctrl_num];
+
+
+	/* Get clk_adjust, wrlvl_start, wrlvl_ctl, according to the board ddr
+	 * freqency and n_banks specified in board_specific_parameters table.
+	 */
+	ddr_freq = get_ddr_freq(ctrl_num) / 1000000;
+	while (pbsp->datarate_mhz_high) {
+		if (pbsp->n_ranks == pdimm[slot].n_ranks &&
+		    (pdimm[slot].rank_density >> 30) >= pbsp->rank_gb) {
+			if (ddr_freq <= pbsp->datarate_mhz_high) {
+				popts->clk_adjust = pbsp->clk_adjust;
+				popts->wrlvl_start = pbsp->wrlvl_start;
+				popts->wrlvl_ctl_2 = pbsp->wrlvl_ctl_2;
+				popts->wrlvl_ctl_3 = pbsp->wrlvl_ctl_3;
+				goto found;
+			}
+			pbsp_highest = pbsp;
+		}
+		pbsp++;
+	}
+
+	if (pbsp_highest) {
+		printf("Error: board specific timing not found for data rate %lu MT/s\n"
+			"Trying to use the highest speed (%u) parameters\n",
+			ddr_freq, pbsp_highest->datarate_mhz_high);
+		popts->clk_adjust = pbsp_highest->clk_adjust;
+		popts->wrlvl_start = pbsp_highest->wrlvl_start;
+		popts->wrlvl_ctl_2 = pbsp->wrlvl_ctl_2;
+		popts->wrlvl_ctl_3 = pbsp->wrlvl_ctl_3;
+	} else {
+		panic("DIMM is not supported by this board");
+	}
+found:
+	debug("Found timing match: n_ranks %d, data rate %d, rank_gb %d\n"
+		"\tclk_adjust %d, wrlvl_start %d, wrlvl_ctrl_2 0x%x, wrlvl_ctrl_3 0x%x\n",
+		pbsp->n_ranks, pbsp->datarate_mhz_high, pbsp->rank_gb,
+		pbsp->clk_adjust, pbsp->wrlvl_start, pbsp->wrlvl_ctl_2,
+		pbsp->wrlvl_ctl_3);
+#ifdef CONFIG_SYS_FSL_HAS_DP_DDR
+	if (ctrl_num == CONFIG_DP_DDR_CTRL) {
+		/* force DDR bus width to 32 bits */
+		popts->data_bus_width = 1;
+		popts->otf_burst_chop_en = 0;
+		popts->burst_length = DDR_BL8;
+		popts->bstopre = 0;	/* enable auto precharge */
+		/*
+		 * Layout optimization results byte mapping
+		 * Byte 0 -> Byte ECC
+		 * Byte 1 -> Byte 3
+		 * Byte 2 -> Byte 2
+		 * Byte 3 -> Byte 1
+		 * Byte ECC -> Byte 0
+		 */
+		dq_mapping_0 = pdimm[slot].dq_mapping[0];
+		dq_mapping_2 = pdimm[slot].dq_mapping[2];
+		dq_mapping_3 = pdimm[slot].dq_mapping[3];
+		pdimm[slot].dq_mapping[0] = pdimm[slot].dq_mapping[8];
+		pdimm[slot].dq_mapping[1] = pdimm[slot].dq_mapping[9];
+		pdimm[slot].dq_mapping[2] = pdimm[slot].dq_mapping[6];
+		pdimm[slot].dq_mapping[3] = pdimm[slot].dq_mapping[7];
+		pdimm[slot].dq_mapping[6] = dq_mapping_2;
+		pdimm[slot].dq_mapping[7] = dq_mapping_3;
+		pdimm[slot].dq_mapping[8] = dq_mapping_0;
+		pdimm[slot].dq_mapping[9] = 0;
+		pdimm[slot].dq_mapping[10] = 0;
+		pdimm[slot].dq_mapping[11] = 0;
+		pdimm[slot].dq_mapping[12] = 0;
+		pdimm[slot].dq_mapping[13] = 0;
+		pdimm[slot].dq_mapping[14] = 0;
+		pdimm[slot].dq_mapping[15] = 0;
+		pdimm[slot].dq_mapping[16] = 0;
+		pdimm[slot].dq_mapping[17] = 0;
+	}
+#endif
+	/* To work at higher than 1333MT/s */
+	popts->half_strength_driver_enable = 0;
+	/*
+	 * Write leveling override
+	 */
+	popts->wrlvl_override = 1;
+	popts->wrlvl_sample = 0x0;	/* 32 clocks */
+
+	/*
+	 * Rtt and Rtt_WR override
+	 */
+	popts->rtt_override = 0;
+
+	/* Enable ZQ calibration */
+	popts->zq_en = 1;
+
+	if (ddr_freq < 2350) {
+		popts->ddr_cdr1 = DDR_CDR1_DHC_EN |
+				  DDR_CDR1_ODT(DDR_CDR_ODT_60ohm);
+		popts->ddr_cdr2 = DDR_CDR2_ODT(DDR_CDR_ODT_60ohm) |
+				  DDR_CDR2_VREF_RANGE_2;
+	} else {
+		popts->ddr_cdr1 = DDR_CDR1_DHC_EN |
+				  DDR_CDR1_ODT(DDR_CDR_ODT_100ohm);
+		popts->ddr_cdr2 = DDR_CDR2_ODT(DDR_CDR_ODT_100ohm) |
+				  DDR_CDR2_VREF_RANGE_2;
+	}
+}
+
+phys_size_t initdram(int board_type)
+{
+	phys_size_t dram_size;
+
+#if defined(CONFIG_SPL) && !defined(CONFIG_SPL_BUILD)
+	return fsl_ddr_sdram_size();
+#else
+	puts("Initializing DDR....using SPD\n");
+
+	dram_size = fsl_ddr_sdram();
+#endif
+
+	return dram_size;
+}
+
+void dram_init_banksize(void)
+{
+#ifdef CONFIG_SYS_DP_DDR_BASE_PHY
+	phys_size_t dp_ddr_size;
+#endif
+
+	gd->bd->bi_dram[0].start = CONFIG_SYS_SDRAM_BASE;
+	if (gd->ram_size > CONFIG_SYS_LS2_DDR_BLOCK1_SIZE) {
+		gd->bd->bi_dram[0].size = CONFIG_SYS_LS2_DDR_BLOCK1_SIZE;
+		gd->bd->bi_dram[1].start = CONFIG_SYS_DDR_BLOCK2_BASE;
+		gd->bd->bi_dram[1].size = gd->ram_size -
+					  CONFIG_SYS_LS2_DDR_BLOCK1_SIZE;
+	} else {
+		gd->bd->bi_dram[0].size = gd->ram_size;
+	}
+
+#ifdef CONFIG_SYS_DP_DDR_BASE_PHY
+	/* initialize DP-DDR here */
+	puts("DP-DDR:  ");
+	/*
+	 * DDR controller use 0 as the base address for binding.
+	 * It is mapped to CONFIG_SYS_DP_DDR_BASE for core to access.
+	 */
+	dp_ddr_size = fsl_other_ddr_sdram(CONFIG_SYS_DP_DDR_BASE_PHY,
+					  CONFIG_DP_DDR_CTRL,
+					  CONFIG_DP_DDR_NUM_CTRLS,
+					  CONFIG_DP_DDR_DIMM_SLOTS_PER_CTLR,
+					  NULL, NULL, NULL);
+	if (dp_ddr_size) {
+		gd->bd->bi_dram[2].start = CONFIG_SYS_DP_DDR_BASE;
+		gd->bd->bi_dram[2].size = dp_ddr_size;
+	} else {
+		puts("Not detected");
+	}
+#endif
+}
diff --git a/board/freescale/ls2080ardb/ddr.h b/board/freescale/ls2080ardb/ddr.h
new file mode 100644
index 0000000..bda9d4a
--- /dev/null
+++ b/board/freescale/ls2080ardb/ddr.h
@@ -0,0 +1,92 @@
+/*
+ * Copyright 2015 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __DDR_H__
+#define __DDR_H__
+struct board_specific_parameters {
+	u32 n_ranks;
+	u32 datarate_mhz_high;
+	u32 rank_gb;
+	u32 clk_adjust;
+	u32 wrlvl_start;
+	u32 wrlvl_ctl_2;
+	u32 wrlvl_ctl_3;
+};
+
+/*
+ * These tables contain all valid speeds we want to override with board
+ * specific parameters. datarate_mhz_high values need to be in ascending order
+ * for each n_ranks group.
+ */
+
+static const struct board_specific_parameters udimm0[] = {
+	/*
+	 * memory controller 0
+	 *   num|  hi| rank|  clk| wrlvl |   wrlvl   |  wrlvl
+	 * ranks| mhz| GB  |adjst| start |   ctl2    |  ctl3
+	 */
+	{2,  1350, 0, 4,     6, 0x0708090B, 0x0C0D0E09,},
+	{2,  1666, 0, 4,     8, 0x08090B0D, 0x0E10100C,},
+	{2,  1900, 0, 4,     8, 0x090A0C0E, 0x1012120D,},
+	{2,  2300, 0, 4,     9, 0x0A0B0C10, 0x1114140E,},
+	{}
+};
+
+/* DP-DDR DIMM */
+static const struct board_specific_parameters udimm2[] = {
+	/*
+	 * memory controller 2
+	 *   num|  hi| rank|  clk| wrlvl |   wrlvl   |  wrlvl
+	 * ranks| mhz| GB  |adjst| start |   ctl2    |  ctl3
+	 */
+	{2,  1350, 0, 4,   0xd, 0x0C0A0A00, 0x00000009,},
+	{2,  1666, 0, 4,   0xd, 0x0C0A0A00, 0x00000009,},
+	{2,  1900, 0, 4,   0xe, 0x0D0C0B00, 0x0000000A,},
+	{2,  2200, 0, 4,   0xe, 0x0D0C0B00, 0x0000000A,},
+	{}
+};
+
+static const struct board_specific_parameters rdimm0[] = {
+	/*
+	 * memory controller 0
+	 *   num|  hi| rank|  clk| wrlvl |   wrlvl   |  wrlvl
+	 * ranks| mhz| GB  |adjst| start |   ctl2    |  ctl3
+	 */
+	{2,  1350, 0, 4,     6, 0x0708090B, 0x0C0D0E09,},
+	{2,  1666, 0, 4,     7, 0x08090A0C, 0x0D0F100B,},
+	{2,  1900, 0, 4,     7, 0x09090B0D, 0x0E10120B,},
+	{2,  2200, 0, 4,     8, 0x090A0C0F, 0x1012130C,},
+	{}
+};
+
+/* DP-DDR DIMM */
+static const struct board_specific_parameters rdimm2[] = {
+	/*
+	 * memory controller 2
+	 *   num|  hi| rank|  clk| wrlvl |   wrlvl   |  wrlvl
+	 * ranks| mhz| GB  |adjst| start |   ctl2    |  ctl3
+	 */
+	{2,  1350, 0, 4,     6, 0x0708090B, 0x0C0D0E09,},
+	{2,  1666, 0, 4,     7, 0x0B0A090C, 0x0D0F100B,},
+	{2,  1900, 0, 4,     7, 0x09090B0D, 0x0E10120B,},
+	{2,  2200, 0, 4,     8, 0x090A0C0F, 0x1012130C,},
+	{}
+};
+
+static const struct board_specific_parameters *udimms[] = {
+	udimm0,
+	udimm0,
+	udimm2,
+};
+
+static const struct board_specific_parameters *rdimms[] = {
+	rdimm0,
+	rdimm0,
+	rdimm2,
+};
+
+
+#endif
diff --git a/board/freescale/ls2080ardb/eth_ls2080rdb.c b/board/freescale/ls2080ardb/eth_ls2080rdb.c
new file mode 100644
index 0000000..db50e4e
--- /dev/null
+++ b/board/freescale/ls2080ardb/eth_ls2080rdb.c
@@ -0,0 +1,147 @@
+/*
+ * Copyright 2015 Freescale Semiconductor, Inc.
+ *
+ *
+ * SPDX-License-Identifier:     GPL-2.0+
+ */
+
+#include <common.h>
+#include <command.h>
+#include <netdev.h>
+#include <malloc.h>
+#include <fsl_mdio.h>
+#include <miiphy.h>
+#include <phy.h>
+#include <fm_eth.h>
+#include <asm/io.h>
+#include <exports.h>
+#include <asm/arch/fsl_serdes.h>
+#include <fsl-mc/ldpaa_wriop.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+int load_firmware_cortina(struct phy_device *phy_dev)
+{
+	if (phy_dev->drv->config)
+		return phy_dev->drv->config(phy_dev);
+
+	return 0;
+}
+
+void load_phy_firmware(void)
+{
+	int i;
+	u8 phy_addr;
+	struct phy_device *phy_dev;
+	struct mii_dev *dev;
+	phy_interface_t interface;
+
+	/*Initialize and upload firmware for all the PHYs*/
+	for (i = WRIOP1_DPMAC1; i <= WRIOP1_DPMAC8; i++) {
+		interface = wriop_get_enet_if(i);
+		if (interface == PHY_INTERFACE_MODE_XGMII) {
+			dev = wriop_get_mdio(i);
+			phy_addr = wriop_get_phy_address(i);
+			phy_dev = phy_find_by_mask(dev, 1 << phy_addr,
+						interface);
+			if (!phy_dev) {
+				printf("No phydev for phyaddr %d\n", phy_addr);
+				continue;
+			}
+
+			/*Flash firmware for All CS4340 PHYS */
+			if (phy_dev->phy_id == PHY_UID_CS4340)
+				load_firmware_cortina(phy_dev);
+		}
+	}
+}
+
+int board_eth_init(bd_t *bis)
+{
+#if defined(CONFIG_FSL_MC_ENET)
+	int i, interface;
+	struct memac_mdio_info mdio_info;
+	struct mii_dev *dev;
+	struct ccsr_gur *gur = (void *)(CONFIG_SYS_FSL_GUTS_ADDR);
+	u32 srds_s1;
+	struct memac_mdio_controller *reg;
+
+	srds_s1 = in_le32(&gur->rcwsr[28]) &
+				FSL_CHASSIS3_RCWSR28_SRDS1_PRTCL_MASK;
+	srds_s1 >>= FSL_CHASSIS3_RCWSR28_SRDS1_PRTCL_SHIFT;
+
+	reg = (struct memac_mdio_controller *)CONFIG_SYS_FSL_WRIOP1_MDIO1;
+	mdio_info.regs = reg;
+	mdio_info.name = DEFAULT_WRIOP_MDIO1_NAME;
+
+	/* Register the EMI 1 */
+	fm_memac_mdio_init(bis, &mdio_info);
+
+	reg = (struct memac_mdio_controller *)CONFIG_SYS_FSL_WRIOP1_MDIO2;
+	mdio_info.regs = reg;
+	mdio_info.name = DEFAULT_WRIOP_MDIO2_NAME;
+
+	/* Register the EMI 2 */
+	fm_memac_mdio_init(bis, &mdio_info);
+
+	switch (srds_s1) {
+	case 0x2A:
+		wriop_set_phy_address(WRIOP1_DPMAC1, CORTINA_PHY_ADDR1);
+		wriop_set_phy_address(WRIOP1_DPMAC2, CORTINA_PHY_ADDR2);
+		wriop_set_phy_address(WRIOP1_DPMAC3, CORTINA_PHY_ADDR3);
+		wriop_set_phy_address(WRIOP1_DPMAC4, CORTINA_PHY_ADDR4);
+		wriop_set_phy_address(WRIOP1_DPMAC5, AQ_PHY_ADDR1);
+		wriop_set_phy_address(WRIOP1_DPMAC6, AQ_PHY_ADDR2);
+		wriop_set_phy_address(WRIOP1_DPMAC7, AQ_PHY_ADDR3);
+		wriop_set_phy_address(WRIOP1_DPMAC8, AQ_PHY_ADDR4);
+
+		break;
+	default:
+		printf("SerDes1 protocol 0x%x is not supported on LS2080aRDB\n",
+		       srds_s1);
+		break;
+	}
+
+	for (i = WRIOP1_DPMAC1; i <= WRIOP1_DPMAC4; i++) {
+		interface = wriop_get_enet_if(i);
+		switch (interface) {
+		case PHY_INTERFACE_MODE_XGMII:
+			dev = miiphy_get_dev_by_name(DEFAULT_WRIOP_MDIO1_NAME);
+			wriop_set_mdio(i, dev);
+			break;
+		default:
+			break;
+		}
+	}
+
+	for (i = WRIOP1_DPMAC5; i <= WRIOP1_DPMAC8; i++) {
+		switch (wriop_get_enet_if(i)) {
+		case PHY_INTERFACE_MODE_XGMII:
+			dev = miiphy_get_dev_by_name(DEFAULT_WRIOP_MDIO2_NAME);
+			wriop_set_mdio(i, dev);
+			break;
+		default:
+			break;
+		}
+	}
+
+	/* Load CORTINA CS4340 PHY firmware */
+	load_phy_firmware();
+
+	cpu_eth_init(bis);
+#endif /* CONFIG_FMAN_ENET */
+
+#ifdef CONFIG_PHY_AQUANTIA
+	/*
+	 * Export functions to be used by AQ firmware
+	 * upload application
+	 */
+	gd->jt->strcpy = strcpy;
+	gd->jt->mdelay = mdelay;
+	gd->jt->mdio_get_current_dev = mdio_get_current_dev;
+	gd->jt->phy_find_by_mask = phy_find_by_mask;
+	gd->jt->mdio_phydev_for_ethname = mdio_phydev_for_ethname;
+	gd->jt->miiphy_set_current_dev = miiphy_set_current_dev;
+#endif
+	return pci_eth_init(bis);
+}
diff --git a/board/freescale/ls2080ardb/ls2080ardb.c b/board/freescale/ls2080ardb/ls2080ardb.c
new file mode 100644
index 0000000..2ae9d6c
--- /dev/null
+++ b/board/freescale/ls2080ardb/ls2080ardb.c
@@ -0,0 +1,321 @@
+/*
+ * Copyright 2015 Freescale Semiconductor
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+#include <common.h>
+#include <malloc.h>
+#include <errno.h>
+#include <netdev.h>
+#include <fsl_ifc.h>
+#include <fsl_ddr.h>
+#include <asm/io.h>
+#include <hwconfig.h>
+#include <fdt_support.h>
+#include <libfdt.h>
+#include <fsl_debug_server.h>
+#include <fsl-mc/fsl_mc.h>
+#include <environment.h>
+#include <i2c.h>
+#include <asm/arch/soc.h>
+
+#include "../common/qixis.h"
+#include "ls2080ardb_qixis.h"
+
+#define PIN_MUX_SEL_SDHC	0x00
+#define PIN_MUX_SEL_DSPI	0x0a
+
+#define SET_SDHC_MUX_SEL(reg, value)	((reg & 0xf0) | value)
+DECLARE_GLOBAL_DATA_PTR;
+
+enum {
+	MUX_TYPE_SDHC,
+	MUX_TYPE_DSPI,
+};
+
+unsigned long long get_qixis_addr(void)
+{
+	unsigned long long addr;
+
+	if (gd->flags & GD_FLG_RELOC)
+		addr = QIXIS_BASE_PHYS;
+	else
+		addr = QIXIS_BASE_PHYS_EARLY;
+
+	/*
+	 * IFC address under 256MB is mapped to 0x30000000, any address above
+	 * is mapped to 0x5_10000000 up to 4GB.
+	 */
+	addr = addr  > 0x10000000 ? addr + 0x500000000ULL : addr + 0x30000000;
+
+	return addr;
+}
+
+int checkboard(void)
+{
+	u8 sw;
+	char buf[15];
+
+	cpu_name(buf);
+	printf("Board: %s-RDB, ", buf);
+
+	sw = QIXIS_READ(arch);
+	printf("Board Arch: V%d, ", sw >> 4);
+	printf("Board version: %c, boot from ", (sw & 0xf) + 'A');
+
+	sw = QIXIS_READ(brdcfg[0]);
+	sw = (sw & QIXIS_LBMAP_MASK) >> QIXIS_LBMAP_SHIFT;
+
+	if (sw < 0x8)
+		printf("vBank: %d\n", sw);
+	else if (sw == 0x9)
+		puts("NAND\n");
+	else
+		printf("invalid setting of SW%u\n", QIXIS_LBMAP_SWITCH);
+
+	printf("FPGA: v%d.%d\n", QIXIS_READ(scver), QIXIS_READ(tagdata));
+
+	puts("SERDES1 Reference : ");
+	printf("Clock1 = 156.25MHz ");
+	printf("Clock2 = 156.25MHz");
+
+	puts("\nSERDES2 Reference : ");
+	printf("Clock1 = 100MHz ");
+	printf("Clock2 = 100MHz\n");
+
+	return 0;
+}
+
+unsigned long get_board_sys_clk(void)
+{
+	u8 sysclk_conf = QIXIS_READ(brdcfg[1]);
+
+	switch (sysclk_conf & 0x0F) {
+	case QIXIS_SYSCLK_83:
+		return 83333333;
+	case QIXIS_SYSCLK_100:
+		return 100000000;
+	case QIXIS_SYSCLK_125:
+		return 125000000;
+	case QIXIS_SYSCLK_133:
+		return 133333333;
+	case QIXIS_SYSCLK_150:
+		return 150000000;
+	case QIXIS_SYSCLK_160:
+		return 160000000;
+	case QIXIS_SYSCLK_166:
+		return 166666666;
+	}
+	return 66666666;
+}
+
+int select_i2c_ch_pca9547(u8 ch)
+{
+	int ret;
+
+	ret = i2c_write(I2C_MUX_PCA_ADDR_PRI, 0, 1, &ch, 1);
+	if (ret) {
+		puts("PCA: failed to select proper channel\n");
+		return ret;
+	}
+
+	return 0;
+}
+
+int config_board_mux(int ctrl_type)
+{
+	u8 reg5;
+
+	reg5 = QIXIS_READ(brdcfg[5]);
+
+	switch (ctrl_type) {
+	case MUX_TYPE_SDHC:
+		reg5 = SET_SDHC_MUX_SEL(reg5, PIN_MUX_SEL_SDHC);
+		break;
+	case MUX_TYPE_DSPI:
+		reg5 = SET_SDHC_MUX_SEL(reg5, PIN_MUX_SEL_DSPI);
+		break;
+	default:
+		printf("Wrong mux interface type\n");
+		return -1;
+	}
+
+	QIXIS_WRITE(brdcfg[5], reg5);
+
+	return 0;
+}
+
+int board_init(void)
+{
+	char *env_hwconfig;
+	u32 __iomem *dcfg_ccsr = (u32 __iomem *)DCFG_BASE;
+	u32 val;
+
+	init_final_memctl_regs();
+
+	val = in_le32(dcfg_ccsr + DCFG_RCWSR13 / 4);
+
+	env_hwconfig = getenv("hwconfig");
+
+	if (hwconfig_f("dspi", env_hwconfig) &&
+	    DCFG_RCWSR13_DSPI == (val & (u32)(0xf << 8)))
+		config_board_mux(MUX_TYPE_DSPI);
+	else
+		config_board_mux(MUX_TYPE_SDHC);
+
+#ifdef CONFIG_ENV_IS_NOWHERE
+	gd->env_addr = (ulong)&default_environment[0];
+#endif
+	select_i2c_ch_pca9547(I2C_MUX_CH_DEFAULT);
+
+	QIXIS_WRITE(rst_ctl, QIXIS_RST_CTL_RESET_EN);
+
+	return 0;
+}
+
+int board_early_init_f(void)
+{
+	fsl_lsch3_early_init_f();
+	return 0;
+}
+
+int misc_init_r(void)
+{
+	if (hwconfig("sdhc"))
+		config_board_mux(MUX_TYPE_SDHC);
+
+	return 0;
+}
+
+void detail_board_ddr_info(void)
+{
+	puts("\nDDR    ");
+	print_size(gd->bd->bi_dram[0].size + gd->bd->bi_dram[1].size, "");
+	print_ddr_info(0);
+#ifdef CONFIG_SYS_FSL_HAS_DP_DDR
+	if (gd->bd->bi_dram[2].size) {
+		puts("\nDP-DDR ");
+		print_size(gd->bd->bi_dram[2].size, "");
+		print_ddr_info(CONFIG_DP_DDR_CTRL);
+	}
+#endif
+}
+
+int dram_init(void)
+{
+	gd->ram_size = initdram(0);
+
+	return 0;
+}
+
+#if defined(CONFIG_ARCH_MISC_INIT)
+int arch_misc_init(void)
+{
+#ifdef CONFIG_FSL_DEBUG_SERVER
+	debug_server_init();
+#endif
+
+	return 0;
+}
+#endif
+
+unsigned long get_dram_size_to_hide(void)
+{
+	unsigned long dram_to_hide = 0;
+
+/* Carve the Debug Server private DRAM block from the end of DRAM */
+#ifdef CONFIG_FSL_DEBUG_SERVER
+	dram_to_hide += debug_server_get_dram_block_size();
+#endif
+
+/* Carve the MC private DRAM block from the end of DRAM */
+#ifdef CONFIG_FSL_MC_ENET
+	dram_to_hide += mc_get_dram_block_size();
+#endif
+
+	return roundup(dram_to_hide, CONFIG_SYS_MEM_TOP_HIDE_MIN);
+}
+
+#ifdef CONFIG_FSL_MC_ENET
+void fdt_fixup_board_enet(void *fdt)
+{
+	int offset;
+
+	offset = fdt_path_offset(fdt, "/fsl-mc");
+
+	if (offset < 0)
+		offset = fdt_path_offset(fdt, "/fsl,dprc@0");
+
+	if (offset < 0) {
+		printf("%s: ERROR: fsl-mc node not found in device tree (error %d)\n",
+		       __func__, offset);
+		return;
+	}
+
+	if (get_mc_boot_status() == 0)
+		fdt_status_okay(fdt, offset);
+	else
+		fdt_status_fail(fdt, offset);
+}
+#endif
+
+#ifdef CONFIG_OF_BOARD_SETUP
+int ft_board_setup(void *blob, bd_t *bd)
+{
+	int err;
+	u64 base[CONFIG_NR_DRAM_BANKS];
+	u64 size[CONFIG_NR_DRAM_BANKS];
+
+	ft_cpu_setup(blob, bd);
+
+	/* fixup DT for the two GPP DDR banks */
+	base[0] = gd->bd->bi_dram[0].start;
+	size[0] = gd->bd->bi_dram[0].size;
+	base[1] = gd->bd->bi_dram[1].start;
+	size[1] = gd->bd->bi_dram[1].size;
+
+	fdt_fixup_memory_banks(blob, base, size, 2);
+
+#ifdef CONFIG_FSL_MC_ENET
+	fdt_fixup_board_enet(blob);
+	err = fsl_mc_ldpaa_exit(bd);
+	if (err)
+		return err;
+#endif
+
+	return 0;
+}
+#endif
+
+void qixis_dump_switch(void)
+{
+	int i, nr_of_cfgsw;
+
+	QIXIS_WRITE(cms[0], 0x00);
+	nr_of_cfgsw = QIXIS_READ(cms[1]);
+
+	puts("DIP switch settings dump:\n");
+	for (i = 1; i <= nr_of_cfgsw; i++) {
+		QIXIS_WRITE(cms[0], i);
+		printf("SW%d = (0x%02x)\n", i, QIXIS_READ(cms[1]));
+	}
+}
+
+/*
+ * Board rev C and earlier has duplicated I2C addresses for 2nd controller.
+ * Both slots has 0x54, resulting 2nd slot unusable.
+ */
+void update_spd_address(unsigned int ctrl_num,
+			unsigned int slot,
+			unsigned int *addr)
+{
+	u8 sw;
+
+	sw = QIXIS_READ(arch);
+	if ((sw & 0xf) < 0x3) {
+		if (ctrl_num == 1 && slot == 0)
+			*addr = SPD_EEPROM_ADDRESS4;
+		else if (ctrl_num == 1 && slot == 1)
+			*addr = SPD_EEPROM_ADDRESS3;
+	}
+}
diff --git a/board/freescale/ls2080ardb/ls2080ardb_qixis.h b/board/freescale/ls2080ardb/ls2080ardb_qixis.h
new file mode 100644
index 0000000..cb60c00
--- /dev/null
+++ b/board/freescale/ls2080ardb/ls2080ardb_qixis.h
@@ -0,0 +1,20 @@
+/*
+ * Copyright 2015 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __LS2_RDB_QIXIS_H__
+#define __LS2_RDB_QIXIS_H__
+
+/* SYSCLK */
+#define QIXIS_SYSCLK_66			0x0
+#define QIXIS_SYSCLK_83			0x1
+#define QIXIS_SYSCLK_100		0x2
+#define QIXIS_SYSCLK_125		0x3
+#define QIXIS_SYSCLK_133		0x4
+#define QIXIS_SYSCLK_150		0x5
+#define QIXIS_SYSCLK_160		0x6
+#define QIXIS_SYSCLK_166		0x7
+
+#endif /*__LS2_RDB_QIXIS_H__*/
diff --git a/board/freescale/ls2085a/Kconfig b/board/freescale/ls2085a/Kconfig
deleted file mode 100644
index 042f85b..0000000
--- a/board/freescale/ls2085a/Kconfig
+++ /dev/null
@@ -1,31 +0,0 @@
-if TARGET_LS2085A_EMU
-
-config SYS_BOARD
-	default "ls2085a"
-
-config SYS_VENDOR
-	default "freescale"
-
-config SYS_SOC
-	default "fsl-layerscape"
-
-config SYS_CONFIG_NAME
-	default "ls2085a_emu"
-
-endif
-
-if TARGET_LS2085A_SIMU
-
-config SYS_BOARD
-	default "ls2085a"
-
-config SYS_VENDOR
-	default "freescale"
-
-config SYS_SOC
-	default "fsl-layerscape"
-
-config SYS_CONFIG_NAME
-	default "ls2085a_simu"
-
-endif
diff --git a/board/freescale/ls2085a/MAINTAINERS b/board/freescale/ls2085a/MAINTAINERS
deleted file mode 100644
index 90b4e47..0000000
--- a/board/freescale/ls2085a/MAINTAINERS
+++ /dev/null
@@ -1,8 +0,0 @@
-LS2085A BOARD
-M:	York Sun <yorksun@freescale.com>
-S:	Maintained
-F:	board/freescale/ls2085a/
-F:	include/configs/ls2085a_emu.h
-F:	configs/ls2085a_emu_defconfig
-F:	include/configs/ls2085a_simu.h
-F:	configs/ls2085a_simu_defconfig
diff --git a/board/freescale/ls2085a/Makefile b/board/freescale/ls2085a/Makefile
deleted file mode 100644
index 701b35c..0000000
--- a/board/freescale/ls2085a/Makefile
+++ /dev/null
@@ -1,8 +0,0 @@
-#
-# Copyright 2014 Freescale Semiconductor
-#
-# SPDX-License-Identifier:	GPL-2.0+
-#
-
-obj-y += ls2085a.o
-obj-y += ddr.o
diff --git a/board/freescale/ls2085a/README b/board/freescale/ls2085a/README
deleted file mode 100644
index bc1d0bb..0000000
--- a/board/freescale/ls2085a/README
+++ /dev/null
@@ -1,27 +0,0 @@
-Freescale ls2085a_emu
-
-This is a emulator target with limited peripherals.
-
-Memory map from core's view
-
-0x00_0000_0000 .. 0x00_000F_FFFF	Boot Rom
-0x00_0100_0000 .. 0x00_0FFF_FFFF	CCSR
-0x00_1800_0000 .. 0x00_181F_FFFF	OCRAM
-0x00_3000_0000 .. 0x00_3FFF_FFFF	IFC region #1
-0x00_8000_0000 .. 0x00_FFFF_FFFF	DDR region #1
-0x05_1000_0000 .. 0x05_FFFF_FFFF	IFC region #2
-0x80_8000_0000 .. 0xFF_FFFF_FFFF	DDR region #2
-
-Other addresses are either reserved, or not used directly by u-boot.
-This list should be updated when more addresses are used.
-
-Booting Linux flavors which do not support 48-bit VA (< Linux 3.18)
--------------------------------------------------------------------
-One needs to use appropriate bootargs to boot Linux flavors which do
-not support 48-bit VA (for e.g. < Linux 3.18) by appending mem=2048M, as shown
-below:
-
-=> setenv bootargs 'console=ttyS1,115200 root=/dev/ram
-   earlycon=uart8250,mmio,0x21c0600,115200 default_hugepagesz=2m hugepagesz=2m
-   hugepages=16 mem=2048M'
-
diff --git a/board/freescale/ls2085a/ddr.c b/board/freescale/ls2085a/ddr.c
deleted file mode 100644
index 4884fa2..0000000
--- a/board/freescale/ls2085a/ddr.c
+++ /dev/null
@@ -1,206 +0,0 @@
-/*
- * Copyright 2014 Freescale Semiconductor, Inc.
- *
- * SPDX-License-Identifier:	GPL-2.0+
- */
-
-#include <common.h>
-#include <fsl_ddr_sdram.h>
-#include <fsl_ddr_dimm_params.h>
-#include "ddr.h"
-
-DECLARE_GLOBAL_DATA_PTR;
-
-void fsl_ddr_board_options(memctl_options_t *popts,
-				dimm_params_t *pdimm,
-				unsigned int ctrl_num)
-{
-	const struct board_specific_parameters *pbsp, *pbsp_highest = NULL;
-	ulong ddr_freq;
-
-	if (ctrl_num > 3) {
-		printf("Not supported controller number %d\n", ctrl_num);
-		return;
-	}
-	if (!pdimm->n_ranks)
-		return;
-
-	/*
-	 * we use identical timing for all slots. If needed, change the code
-	 * to  pbsp = rdimms[ctrl_num] or pbsp = udimms[ctrl_num];
-	 */
-	if (popts->registered_dimm_en)
-		pbsp = rdimms[ctrl_num];
-	else
-		pbsp = udimms[ctrl_num];
-
-
-	/* Get clk_adjust, wrlvl_start, wrlvl_ctl, according to the board ddr
-	 * freqency and n_banks specified in board_specific_parameters table.
-	 */
-	ddr_freq = get_ddr_freq(0) / 1000000;
-	while (pbsp->datarate_mhz_high) {
-		if (pbsp->n_ranks == pdimm->n_ranks &&
-		    (pdimm->rank_density >> 30) >= pbsp->rank_gb) {
-			if (ddr_freq <= pbsp->datarate_mhz_high) {
-				popts->clk_adjust = pbsp->clk_adjust;
-				popts->wrlvl_start = pbsp->wrlvl_start;
-				popts->wrlvl_ctl_2 = pbsp->wrlvl_ctl_2;
-				popts->wrlvl_ctl_3 = pbsp->wrlvl_ctl_3;
-				goto found;
-			}
-			pbsp_highest = pbsp;
-		}
-		pbsp++;
-	}
-
-	if (pbsp_highest) {
-		printf("Error: board specific timing not found for data rate %lu MT/s\n"
-			"Trying to use the highest speed (%u) parameters\n",
-			ddr_freq, pbsp_highest->datarate_mhz_high);
-		popts->clk_adjust = pbsp_highest->clk_adjust;
-		popts->wrlvl_start = pbsp_highest->wrlvl_start;
-		popts->wrlvl_ctl_2 = pbsp->wrlvl_ctl_2;
-		popts->wrlvl_ctl_3 = pbsp->wrlvl_ctl_3;
-	} else {
-		panic("DIMM is not supported by this board");
-	}
-found:
-	debug("Found timing match: n_ranks %d, data rate %d, rank_gb %d\n"
-		"\tclk_adjust %d, wrlvl_start %d, wrlvl_ctrl_2 0x%x, wrlvl_ctrl_3 0x%x\n",
-		pbsp->n_ranks, pbsp->datarate_mhz_high, pbsp->rank_gb,
-		pbsp->clk_adjust, pbsp->wrlvl_start, pbsp->wrlvl_ctl_2,
-		pbsp->wrlvl_ctl_3);
-
-	if (ctrl_num == CONFIG_DP_DDR_CTRL) {
-		/* force DDR bus width to 32 bits */
-		popts->data_bus_width = 1;
-		popts->otf_burst_chop_en = 0;
-		popts->burst_length = DDR_BL8;
-		popts->bstopre = 0;	/* enable auto precharge */
-	}
-	/*
-	 * Factors to consider for half-strength driver enable:
-	 *	- number of DIMMs installed
-	 */
-	popts->half_strength_driver_enable = 1;
-	/*
-	 * Write leveling override
-	 */
-	popts->wrlvl_override = 1;
-	popts->wrlvl_sample = 0xf;
-
-	/*
-	 * Rtt and Rtt_WR override
-	 */
-	popts->rtt_override = 0;
-
-	/* Enable ZQ calibration */
-	popts->zq_en = 1;
-
-#ifdef CONFIG_SYS_FSL_DDR4
-	popts->ddr_cdr1 = DDR_CDR1_DHC_EN | DDR_CDR1_ODT(DDR_CDR_ODT_80ohm);
-	popts->ddr_cdr2 = DDR_CDR2_ODT(DDR_CDR_ODT_80ohm) |
-			  DDR_CDR2_VREF_OVRD(70);	/* Vref = 70% */
-#else
-	/* DHC_EN =1, ODT = 75 Ohm */
-	popts->ddr_cdr1 = DDR_CDR1_DHC_EN | DDR_CDR1_ODT(DDR_CDR_ODT_75ohm);
-	popts->ddr_cdr2 = DDR_CDR2_ODT(DDR_CDR_ODT_75ohm);
-#endif
-}
-
-#ifdef CONFIG_SYS_DDR_RAW_TIMING
-dimm_params_t ddr_raw_timing = {
-	.n_ranks = 2,
-	.rank_density = 1073741824u,
-	.capacity = 2147483648,
-	.primary_sdram_width = 64,
-	.ec_sdram_width = 0,
-	.registered_dimm = 0,
-	.mirrored_dimm = 0,
-	.n_row_addr = 14,
-	.n_col_addr = 10,
-	.n_banks_per_sdram_device = 8,
-	.edc_config = 0,
-	.burst_lengths_bitmask = 0x0c,
-
-	.tckmin_x_ps = 937,
-	.caslat_x = 0x6FC << 4,  /* 14,13,11,10,9,8,7,6 */
-	.taa_ps = 13090,
-	.twr_ps = 15000,
-	.trcd_ps = 13090,
-	.trrd_ps = 5000,
-	.trp_ps = 13090,
-	.tras_ps = 33000,
-	.trc_ps = 46090,
-	.trfc_ps = 160000,
-	.twtr_ps = 7500,
-	.trtp_ps = 7500,
-	.refresh_rate_ps = 7800000,
-	.tfaw_ps = 25000,
-};
-
-int fsl_ddr_get_dimm_params(dimm_params_t *pdimm,
-		unsigned int controller_number,
-		unsigned int dimm_number)
-{
-	const char dimm_model[] = "Fixed DDR on board";
-
-	if (((controller_number == 0) && (dimm_number == 0)) ||
-	    ((controller_number == 1) && (dimm_number == 0))) {
-		memcpy(pdimm, &ddr_raw_timing, sizeof(dimm_params_t));
-		memset(pdimm->mpart, 0, sizeof(pdimm->mpart));
-		memcpy(pdimm->mpart, dimm_model, sizeof(dimm_model) - 1);
-	}
-
-	return 0;
-}
-#endif
-phys_size_t initdram(int board_type)
-{
-	phys_size_t dram_size;
-
-	puts("Initializing DDR....");
-
-	puts("using SPD\n");
-	dram_size = fsl_ddr_sdram();
-
-	return dram_size;
-}
-
-void dram_init_banksize(void)
-{
-#ifdef CONFIG_SYS_DP_DDR_BASE_PHY
-	phys_size_t dp_ddr_size;
-#endif
-
-	gd->bd->bi_dram[0].start = CONFIG_SYS_SDRAM_BASE;
-	if (gd->ram_size > CONFIG_SYS_LS2_DDR_BLOCK1_SIZE) {
-		gd->bd->bi_dram[0].size = CONFIG_SYS_LS2_DDR_BLOCK1_SIZE;
-		gd->bd->bi_dram[1].start = CONFIG_SYS_DDR_BLOCK2_BASE;
-		gd->bd->bi_dram[1].size = gd->ram_size -
-					  CONFIG_SYS_LS2_DDR_BLOCK1_SIZE;
-	} else {
-		gd->bd->bi_dram[0].size = gd->ram_size;
-	}
-
-#ifdef CONFIG_SYS_DP_DDR_BASE_PHY
-	/* initialize DP-DDR here */
-	puts("DP-DDR:  ");
-	/*
-	 * DDR controller use 0 as the base address for binding.
-	 * It is mapped to CONFIG_SYS_DP_DDR_BASE for core to access.
-	 */
-	dp_ddr_size = fsl_other_ddr_sdram(CONFIG_SYS_DP_DDR_BASE_PHY,
-					  CONFIG_DP_DDR_CTRL,
-					  CONFIG_DP_DDR_NUM_CTRLS,
-					  CONFIG_DP_DDR_DIMM_SLOTS_PER_CTLR,
-					  NULL, NULL, NULL);
-	if (dp_ddr_size) {
-		gd->bd->bi_dram[2].start = CONFIG_SYS_DP_DDR_BASE;
-		gd->bd->bi_dram[2].size = dp_ddr_size;
-	} else {
-		puts("Not detected");
-	}
-#endif
-}
diff --git a/board/freescale/ls2085a/ddr.h b/board/freescale/ls2085a/ddr.h
deleted file mode 100644
index 9958a68..0000000
--- a/board/freescale/ls2085a/ddr.h
+++ /dev/null
@@ -1,86 +0,0 @@
-/*
- * Copyright 2014 Freescale Semiconductor, Inc.
- *
- * SPDX-License-Identifier:	GPL-2.0+
- */
-
-#ifndef __DDR_H__
-#define __DDR_H__
-struct board_specific_parameters {
-	u32 n_ranks;
-	u32 datarate_mhz_high;
-	u32 rank_gb;
-	u32 clk_adjust;
-	u32 wrlvl_start;
-	u32 wrlvl_ctl_2;
-	u32 wrlvl_ctl_3;
-};
-
-/*
- * These tables contain all valid speeds we want to override with board
- * specific parameters. datarate_mhz_high values need to be in ascending order
- * for each n_ranks group.
- */
-
-static const struct board_specific_parameters udimm0[] = {
-	/*
-	 * memory controller 0
-	 *   num|  hi| rank|  clk| wrlvl |   wrlvl   |  wrlvl
-	 * ranks| mhz| GB  |adjst| start |   ctl2    |  ctl3
-	 */
-	{2,  2140, 0, 4,     4, 0x0, 0x0},
-	{1,  2140, 0, 4,     4, 0x0, 0x0},
-	{}
-};
-
-/* DP-DDR DIMM */
-static const struct board_specific_parameters udimm2[] = {
-	/*
-	 * memory controller 2
-	 *   num|  hi| rank|  clk| wrlvl |   wrlvl   |  wrlvl
-	 * ranks| mhz| GB  |adjst| start |   ctl2    |  ctl3
-	 */
-	{2,  2140, 0, 4,     4, 0x0, 0x0},
-	{1,  2140, 0, 4,     4, 0x0, 0x0},
-	{}
-};
-
-static const struct board_specific_parameters rdimm0[] = {
-	/*
-	 * memory controller 0
-	 *   num|  hi| rank|  clk| wrlvl |   wrlvl   |  wrlvl
-	 * ranks| mhz| GB  |adjst| start |   ctl2    |  ctl3
-	 */
-	{4,  2140, 0, 5,     4, 0x0, 0x0},
-	{2,  2140, 0, 5,     4, 0x0, 0x0},
-	{1,  2140, 0, 4,     4, 0x0, 0x0},
-	{}
-};
-
-/* DP-DDR DIMM */
-static const struct board_specific_parameters rdimm2[] = {
-	/*
-	 * memory controller 2
-	 *   num|  hi| rank|  clk| wrlvl |   wrlvl   |  wrlvl
-	 * ranks| mhz| GB  |adjst| start |   ctl2    |  ctl3
-	 */
-	{4,  2140, 0, 5,     4, 0x0, 0x0},
-	{2,  2140, 0, 5,     4, 0x0, 0x0},
-	{1,  2140, 0, 4,     4, 0x0, 0x0},
-	{}
-};
-
-static const struct board_specific_parameters *udimms[] = {
-	udimm0,
-	udimm0,
-	udimm2,
-};
-
-static const struct board_specific_parameters *rdimms[] = {
-	rdimm0,
-	rdimm0,
-	rdimm2,
-};
-
-
-#endif
diff --git a/board/freescale/ls2085a/ls2085a.c b/board/freescale/ls2085a/ls2085a.c
deleted file mode 100644
index 27481e2..0000000
--- a/board/freescale/ls2085a/ls2085a.c
+++ /dev/null
@@ -1,150 +0,0 @@
-/*
- * Copyright 2014 Freescale Semiconductor
- *
- * SPDX-License-Identifier:	GPL-2.0+
- */
-#include <common.h>
-#include <malloc.h>
-#include <errno.h>
-#include <netdev.h>
-#include <fsl_ifc.h>
-#include <fsl_ddr.h>
-#include <asm/io.h>
-#include <fdt_support.h>
-#include <libfdt.h>
-#include <fsl_debug_server.h>
-#include <fsl-mc/fsl_mc.h>
-#include <environment.h>
-#include <asm/arch/soc.h>
-
-DECLARE_GLOBAL_DATA_PTR;
-
-int board_init(void)
-{
-	init_final_memctl_regs();
-
-#ifdef CONFIG_ENV_IS_NOWHERE
-	gd->env_addr = (ulong)&default_environment[0];
-#endif
-
-	return 0;
-}
-
-int board_early_init_f(void)
-{
-	fsl_lsch3_early_init_f();
-	return 0;
-}
-
-void detail_board_ddr_info(void)
-{
-	puts("\nDDR    ");
-	print_size(gd->bd->bi_dram[0].size + gd->bd->bi_dram[1].size, "");
-	print_ddr_info(0);
-	if (gd->bd->bi_dram[2].size) {
-		puts("\nDP-DDR ");
-		print_size(gd->bd->bi_dram[2].size, "");
-		print_ddr_info(CONFIG_DP_DDR_CTRL);
-	}
-}
-
-int dram_init(void)
-{
-	gd->ram_size = initdram(0);
-
-	return 0;
-}
-
-#if defined(CONFIG_ARCH_MISC_INIT)
-int arch_misc_init(void)
-{
-#ifdef CONFIG_FSL_DEBUG_SERVER
-	debug_server_init();
-#endif
-
-	return 0;
-}
-#endif
-
-unsigned long get_dram_size_to_hide(void)
-{
-	unsigned long dram_to_hide = 0;
-
-/* Carve the Debug Server private DRAM block from the end of DRAM */
-#ifdef CONFIG_FSL_DEBUG_SERVER
-	dram_to_hide += debug_server_get_dram_block_size();
-#endif
-
-/* Carve the MC private DRAM block from the end of DRAM */
-#ifdef CONFIG_FSL_MC_ENET
-	dram_to_hide += mc_get_dram_block_size();
-#endif
-
-	return roundup(dram_to_hide, CONFIG_SYS_MEM_TOP_HIDE_MIN);
-}
-
-int board_eth_init(bd_t *bis)
-{
-	int error = 0;
-
-#ifdef CONFIG_SMC91111
-	error = smc91111_initialize(0, CONFIG_SMC91111_BASE);
-#endif
-
-#ifdef CONFIG_FSL_MC_ENET
-	error = cpu_eth_init(bis);
-#endif
-	return error;
-}
-
-#ifdef CONFIG_FSL_MC_ENET
-void fdt_fixup_board_enet(void *fdt)
-{
-	int offset;
-
-	offset = fdt_path_offset(fdt, "/fsl-mc");
-
-	/*
-	 * TODO: Remove this when backward compatibility
-	 * with old DT node (fsl,dprc@0) is no longer needed.
-	 */
-	if (offset < 0)
-		offset = fdt_path_offset(fdt, "/fsl,dprc@0");
-
-	if (offset < 0) {
-		printf("%s: ERROR: fsl-mc node not found in device tree (error %d)\n",
-		       __func__, offset);
-		return;
-	}
-
-	if (get_mc_boot_status() == 0)
-		fdt_status_okay(fdt, offset);
-	else
-		fdt_status_fail(fdt, offset);
-}
-#endif
-
-#ifdef CONFIG_OF_BOARD_SETUP
-int ft_board_setup(void *blob, bd_t *bd)
-{
-	u64 base[CONFIG_NR_DRAM_BANKS];
-	u64 size[CONFIG_NR_DRAM_BANKS];
-
-	ft_cpu_setup(blob, bd);
-
-	/* fixup DT for the two GPP DDR banks */
-	base[0] = gd->bd->bi_dram[0].start;
-	size[0] = gd->bd->bi_dram[0].size;
-	base[1] = gd->bd->bi_dram[1].start;
-	size[1] = gd->bd->bi_dram[1].size;
-
-	fdt_fixup_memory_banks(blob, base, size, 2);
-
-#ifdef CONFIG_FSL_MC_ENET
-	fdt_fixup_board_enet(blob);
-	fsl_mc_ldpaa_exit(bd);
-#endif
-
-	return 0;
-}
-#endif
diff --git a/board/freescale/ls2085aqds/Kconfig b/board/freescale/ls2085aqds/Kconfig
deleted file mode 100644
index 8d6acba..0000000
--- a/board/freescale/ls2085aqds/Kconfig
+++ /dev/null
@@ -1,16 +0,0 @@
-
-if TARGET_LS2085AQDS
-
-config SYS_BOARD
-	default "ls2085aqds"
-
-config SYS_VENDOR
-	default "freescale"
-
-config SYS_SOC
-	default "fsl-layerscape"
-
-config SYS_CONFIG_NAME
-	default "ls2085aqds"
-
-endif
diff --git a/board/freescale/ls2085aqds/MAINTAINERS b/board/freescale/ls2085aqds/MAINTAINERS
deleted file mode 100644
index fbed672..0000000
--- a/board/freescale/ls2085aqds/MAINTAINERS
+++ /dev/null
@@ -1,8 +0,0 @@
-LS2085A BOARD
-M:	Prabhakar Kushwaha <prabhakar@freescale.com>
-S:	Maintained
-F:	board/freescale/ls2085aqds/
-F:	board/freescale/ls2085a/ls2085aqds.c
-F:	include/configs/ls2085aqds.h
-F:	configs/ls2085aqds_defconfig
-F:	configs/ls2085aqds_nand_defconfig
diff --git a/board/freescale/ls2085aqds/Makefile b/board/freescale/ls2085aqds/Makefile
deleted file mode 100644
index da69a7d..0000000
--- a/board/freescale/ls2085aqds/Makefile
+++ /dev/null
@@ -1,9 +0,0 @@
-#
-# Copyright 2015 Freescale Semiconductor
-#
-# SPDX-License-Identifier:	GPL-2.0+
-#
-
-obj-y += ls2085aqds.o
-obj-y += ddr.o
-obj-y += eth.o
diff --git a/board/freescale/ls2085aqds/README b/board/freescale/ls2085aqds/README
deleted file mode 100644
index e4a6f69..0000000
--- a/board/freescale/ls2085aqds/README
+++ /dev/null
@@ -1,229 +0,0 @@
-Overview
---------
-The LS2085A Development System (QDS) is a high-performance computing,
-evaluation, and development platform that supports the QorIQ LS2085A
-Layerscape Architecture processor. The LS2085AQDS provides validation and
-SW development platform for the Freescale LS2085A processor series, with
-a complete debugging environment.
-
-LS2085A SoC Overview
-------------------
-The LS2085A integrated multicore processor combines eight ARM Cortex-A57
-processor cores with high-performance data path acceleration logic and network
-and peripheral bus interfaces required for networking, telecom/datacom,
-wireless infrastructure, and mil/aerospace applications.
-
-The LS2085A SoC includes the following function and features:
-
- - Eight 64-bit ARM Cortex-A57 CPUs
- - 1 MB platform cache with ECC
- - Two 64-bit DDR4 SDRAM memory controllers with ECC and interleaving support
- - One secondary 32-bit DDR4 SDRAM memory controller, intended for use by
-  the AIOP
- - Data path acceleration architecture (DPAA2) incorporating acceleration for
- the following functions:
-   - Packet parsing, classification, and distribution (WRIOP)
-   - Queue and Hardware buffer management for scheduling, packet sequencing, and
-     congestion management, buffer allocation and de-allocation (QBMan)
-   - Cryptography acceleration (SEC) at up to 10 Gbps
-   - RegEx pattern matching acceleration (PME) at up to 10 Gbps
-   - Decompression/compression acceleration (DCE) at up to 20 Gbps
-   - Accelerated I/O processing (AIOP) at up to 20 Gbps
-   - QDMA engine
- - 16 SerDes lanes at up to 10.3125 GHz
- - Ethernet interfaces
-   - Up to eight 10 Gbps Ethernet MACs
-   - Up to eight 1 / 2.5 Gbps Ethernet MACs
- - High-speed peripheral interfaces
-   - Four PCIe 3.0 controllers, one supporting SR-IOV
- - Additional peripheral interfaces
-   - Two serial ATA (SATA 3.0) controllers
-   - Two high-speed USB 3.0 controllers with integrated PHY
-   - Enhanced secure digital host controller (eSDXC/eMMC)
-   - Serial peripheral interface (SPI) controller
-   - Quad Serial Peripheral Interface (QSPI) Controller
-   - Four I2C controllers
-   - Two DUARTs
-   - Integrated flash controller (IFC 2.0) supporting NAND and NOR flash
- - Support for hardware virtualization and partitioning enforcement
- - QorIQ platform's trust architecture 3.0
- - Service processor (SP) provides pre-boot initialization and secure-boot
-  capabilities
-
- LS2085AQDS board Overview
- -----------------------
- - SERDES Connections, 16 lanes supporting:
-      - PCI Express - 3.0
-      - SGMII, SGMII 2.5
-      - QSGMII
-      - SATA 3.0
-      - XAUI
-      - XFI
- - DDR Controller
-     - Two ports of 72-bits (8-bits ECC) DDR4. Each port supports four
-       chip-selects and two DIMM connectors. Support is up to 2133MT/s.
-     - One port of 40-bits (8-bits ECC) DDR4 which supports four chip-selects
-       and two DIMM connectors. Support is up to 1600MT/s.
- -IFC/Local Bus
-    - IFC rev. 2.0 implementation supporting Little Endian connection scheme.
-    - One in-socket 128 MB NOR flash 16-bit data bus
-    - One 512 MB NAND flash with ECC support
-    - IFC Test Port
-    - PromJet Port
-    - FPGA connection
- - USB 3.0
-    - Two high speed USB 3.0 ports
-    - First USB 3.0 port configured as Host with Type-A connector
-    - Second USB 3.0 port configured as OTG with micro-AB connector
- - SDHC: PCIe x1 Right Angle connector for supporting following cards
-    - 1/4-/8-bit SD/MMC Legacy CARD supporting 3.3V devices only
-    - 1-/4-/8-bit SD/MMC Card supporting 1.8V devices only
-    - 4-bit eMMC Card Rev 4.4 (1.8V only)
-    - 8-bit eMMC Card Rev 4.5 (1.8V only)
-    - SD Card Rev 2.0 and Rev 3.0
- - DSPI: 3 high-speed flash Memory for storage
-    - 16 MB high-speed flash Memory for boot code and storage (up to 108MHz)
-    - 8 MB high-speed flash Memory (up to 104 MHz)
-    - 512 MB low-speed flash Memory (up to 40 MHz)
- - QSPI: via NAND/QSPI Card
- - 4 I2C controllers
- - Two SATA onboard connectors
- - UART
-   - Two 4-pin (HW control) or four 2-pin (SW control) serial ports at up to 115.2 Kbit/s
-   - Two DB9 D-Type connectors supporting one Serial port each
- - ARM JTAG support
-
-Memory map from core's view
-----------------------------
-0x00_0000_0000 .. 0x00_000F_FFFF	Boot Rom
-0x00_0100_0000 .. 0x00_0FFF_FFFF	CCSR
-0x00_1800_0000 .. 0x00_181F_FFFF	OCRAM
-0x00_3000_0000 .. 0x00_3FFF_FFFF	IFC region #1
-0x00_8000_0000 .. 0x00_FFFF_FFFF	DDR region #1
-0x05_1000_0000 .. 0x05_FFFF_FFFF	IFC region #2
-0x80_8000_0000 .. 0xFF_FFFF_FFFF	DDR region #2
-
-Other addresses are either reserved, or not used directly by u-boot.
-This list should be updated when more addresses are used.
-
-IFC region map from core's view
--------------------------------
-During boot i.e. IFC Region #1:-
-  0x30000000 - 0x37ffffff : 128MB : NOR flash
-  0x38000000 - 0x3BFFFFFF : 64MB  : Promjet
-  0x3C000000 - 0x40000000 : 64MB  : FPGA etc
-
-After relocate to DDR i.e. IFC Region #2:-
-  0x5_1000_0000..0x5_1fff_ffff	Memory Hole
-  0x5_2000_0000..0x5_3fff_ffff	IFC CSx (FPGA, NAND and others 512MB)
-  0x5_4000_0000..0x5_7fff_ffff	ASIC or others 1GB
-  0x5_8000_0000..0x5_bfff_ffff	IFC CS0 1GB (NOR/Promjet)
-  0x5_C000_0000..0x5_ffff_ffff	IFC CS1 1GB (NOR/Promjet)
-
-Booting Options
----------------
-a) Promjet Boot
-b) NOR boot
-c) NAND boot
-d) SD boot
-e) QSPI boot
-
-Environment Variables
----------------------
-- mcboottimeout: MC boot timeout in milliseconds. If this variable is not defined
-  the value CONFIG_SYS_LS_MC_BOOT_TIMEOUT_MS will be assumed.
-
-- mcmemsize: MC DRAM block size. If this variable is not defined
-  the value CONFIG_SYS_LS_MC_DRAM_BLOCK_MIN_SIZE will be assumed.
-
-Booting Linux flavors which do not support 48-bit VA (< Linux 3.18)
--------------------------------------------------------------------
-One needs to use appropriate bootargs to boot Linux flavors which do
-not support 48-bit VA (for e.g. < Linux 3.18) by appending mem=2048M, as shown
-below:
-
-=> setenv bootargs 'console=ttyS1,115200 root=/dev/ram
-   earlycon=uart8250,mmio,0x21c0600,115200 default_hugepagesz=2m hugepagesz=2m
-   hugepages=16 mem=2048M'
-
-
-X-QSGMII-16PORT riser card
-----------------------------
-The X-QSGMII-16PORT is a 4xQSGMII/8xSGMII riser card with eighth SerDes
-interfaces implemented in PCIe form factor board.
-It supports followings
- - Card can operate with up to 4 QSGMII lane simultaneously
- - Card can operate with up to 8 SGMII lane simultaneously
-
-Supported card configuration
-	- CSEL  : ON ON ON ON
-	- MSEL1 : ON ON ON ON OFF OFF OFF OFF
-	- MSEL2 : OFF OFF OFF OFF ON ON ON ON
-
-To enable this card: modify hwconfig to add "xqsgmii" variable.
-
-Supported PHY addresses during SGMII:
-#define XQSGMII_CARD_PHY1_PORT0_ADDR 0x0
-#define XQSGMII_CARD_PHY1_PORT2_ADDR 0x2
-#define XQSGMII_CARD_PHY2_PORT0_ADDR 0x4
-#define XQSGMII_CARD_PHY2_PORT2_ADDR 0x6
-#define XQSGMII_CARD_PHY3_PORT0_ADDR 0x8
-#define XQSGMII_CARD_PHY3_PORT2_ADDR 0xa
-#define XQSGMII_CARD_PHY4_PORT0_ADDR 0xc
-#define XQSGMII_CARD_PHY4_PORT2_ADDR 0xe
-
-Mapping DPMACx to PHY during QSGMII
-DPMAC1 -> PHY1-P0
-DPMAC2 -> PHY2-P0
-DPMAC3 -> PHY3-P0
-DPMAC4 -> PHY4-P0
-DPMAC5 -> PHY3-P2
-DPMAC6 -> PHY1-P2
-DPMAC7 -> PHY4-P1
-DPMAC8 -> PHY2-P2
-DPMAC9 -> PHY1-P0
-DPMAC10 -> PHY2-P0
-DPMAC11 -> PHY3-P0
-DPMAC12 -> PHY4-P0
-DPMAC13 -> PHY3-P2
-DPMAC14 -> PHY1-P2
-DPMAC15 -> PHY4-P1
-DPMAC16 -> PHY2-P2
-
-
-Supported PHY address during QSGMII
-#define XQSGMII_CARD_PHY1_PORT0_ADDR 0x0
-#define XQSGMII_CARD_PHY1_PORT1_ADDR 0x1
-#define XQSGMII_CARD_PHY1_PORT2_ADDR 0x2
-#define XQSGMII_CARD_PHY1_PORT3_ADDR 0x3
-#define XQSGMII_CARD_PHY2_PORT0_ADDR 0x4
-#define XQSGMII_CARD_PHY2_PORT1_ADDR 0x5
-#define XQSGMII_CARD_PHY2_PORT2_ADDR 0x6
-#define XQSGMII_CARD_PHY2_PORT3_ADDR 0x7
-#define XQSGMII_CARD_PHY3_PORT0_ADDR 0x8
-#define XQSGMII_CARD_PHY3_PORT1_ADDR 0x9
-#define XQSGMII_CARD_PHY3_PORT2_ADDR 0xa
-#define XQSGMII_CARD_PHY3_PORT3_ADDR 0xb
-#define XQSGMII_CARD_PHY4_PORT0_ADDR 0xc
-#define XQSGMII_CARD_PHY4_PORT1_ADDR 0xd
-#define XQSGMII_CARD_PHY4_PORT2_ADDR 0xe
-#define XQSGMII_CARD_PHY4_PORT3_ADDR 0xf
-
-Mapping DPMACx to PHY during QSGMII
-DPMAC1 -> PHY1-P3
-DPMAC2 -> PHY1-P2
-DPMAC3 -> PHY1-P1
-DPMAC4 -> PHY1-P0
-DPMAC5 -> PHY2-P3
-DPMAC6 -> PHY2-P2
-DPMAC7 -> PHY2-P1
-DPMAC8 -> PHY2-P0
-DPMAC9 -> PHY3-P0
-DPMAC10 -> PHY3-P1
-DPMAC11 -> PHY3-P2
-DPMAC12 -> PHY3-P3
-DPMAC13 -> PHY4-P0
-DPMAC14 -> PHY4-P1
-DPMAC15 -> PHY4-P2
-DPMAC16 -> PHY4-P3
-
diff --git a/board/freescale/ls2085aqds/ddr.c b/board/freescale/ls2085aqds/ddr.c
deleted file mode 100644
index 8d71ae1..0000000
--- a/board/freescale/ls2085aqds/ddr.c
+++ /dev/null
@@ -1,196 +0,0 @@
-/*
- * Copyright 2015 Freescale Semiconductor, Inc.
- *
- * SPDX-License-Identifier:	GPL-2.0+
- */
-
-#include <common.h>
-#include <fsl_ddr_sdram.h>
-#include <fsl_ddr_dimm_params.h>
-#include "ddr.h"
-
-DECLARE_GLOBAL_DATA_PTR;
-
-void fsl_ddr_board_options(memctl_options_t *popts,
-				dimm_params_t *pdimm,
-				unsigned int ctrl_num)
-{
-	u8 dq_mapping_0, dq_mapping_2, dq_mapping_3;
-	const struct board_specific_parameters *pbsp, *pbsp_highest = NULL;
-	ulong ddr_freq;
-	int slot;
-
-	if (ctrl_num > 2) {
-		printf("Not supported controller number %d\n", ctrl_num);
-		return;
-	}
-
-	for (slot = 0; slot < CONFIG_DIMM_SLOTS_PER_CTLR; slot++) {
-		if (pdimm[slot].n_ranks)
-			break;
-	}
-
-	if (slot >= CONFIG_DIMM_SLOTS_PER_CTLR)
-		return;
-
-	/*
-	 * we use identical timing for all slots. If needed, change the code
-	 * to  pbsp = rdimms[ctrl_num] or pbsp = udimms[ctrl_num];
-	 */
-	if (popts->registered_dimm_en)
-		pbsp = rdimms[ctrl_num];
-	else
-		pbsp = udimms[ctrl_num];
-
-
-	/* Get clk_adjust, wrlvl_start, wrlvl_ctl, according to the board ddr
-	 * freqency and n_banks specified in board_specific_parameters table.
-	 */
-	ddr_freq = get_ddr_freq(ctrl_num) / 1000000;
-	while (pbsp->datarate_mhz_high) {
-		if (pbsp->n_ranks == pdimm[slot].n_ranks &&
-		    (pdimm[slot].rank_density >> 30) >= pbsp->rank_gb) {
-			if (ddr_freq <= pbsp->datarate_mhz_high) {
-				popts->clk_adjust = pbsp->clk_adjust;
-				popts->wrlvl_start = pbsp->wrlvl_start;
-				popts->wrlvl_ctl_2 = pbsp->wrlvl_ctl_2;
-				popts->wrlvl_ctl_3 = pbsp->wrlvl_ctl_3;
-				goto found;
-			}
-			pbsp_highest = pbsp;
-		}
-		pbsp++;
-	}
-
-	if (pbsp_highest) {
-		printf("Error: board specific timing not found for data rate %lu MT/s\n"
-			"Trying to use the highest speed (%u) parameters\n",
-			ddr_freq, pbsp_highest->datarate_mhz_high);
-		popts->clk_adjust = pbsp_highest->clk_adjust;
-		popts->wrlvl_start = pbsp_highest->wrlvl_start;
-		popts->wrlvl_ctl_2 = pbsp->wrlvl_ctl_2;
-		popts->wrlvl_ctl_3 = pbsp->wrlvl_ctl_3;
-	} else {
-		panic("DIMM is not supported by this board");
-	}
-found:
-	debug("Found timing match: n_ranks %d, data rate %d, rank_gb %d\n"
-		"\tclk_adjust %d, wrlvl_start %d, wrlvl_ctrl_2 0x%x, wrlvl_ctrl_3 0x%x\n",
-		pbsp->n_ranks, pbsp->datarate_mhz_high, pbsp->rank_gb,
-		pbsp->clk_adjust, pbsp->wrlvl_start, pbsp->wrlvl_ctl_2,
-		pbsp->wrlvl_ctl_3);
-
-	if (ctrl_num == CONFIG_DP_DDR_CTRL) {
-		/* force DDR bus width to 32 bits */
-		popts->data_bus_width = 1;
-		popts->otf_burst_chop_en = 0;
-		popts->burst_length = DDR_BL8;
-		popts->bstopre = 0;	/* enable auto precharge */
-		/*
-		 * Layout optimization results byte mapping
-		 * Byte 0 -> Byte ECC
-		 * Byte 1 -> Byte 3
-		 * Byte 2 -> Byte 2
-		 * Byte 3 -> Byte 1
-		 * Byte ECC -> Byte 0
-		 */
-		dq_mapping_0 = pdimm[slot].dq_mapping[0];
-		dq_mapping_2 = pdimm[slot].dq_mapping[2];
-		dq_mapping_3 = pdimm[slot].dq_mapping[3];
-		pdimm[slot].dq_mapping[0] = pdimm[slot].dq_mapping[8];
-		pdimm[slot].dq_mapping[1] = pdimm[slot].dq_mapping[9];
-		pdimm[slot].dq_mapping[2] = pdimm[slot].dq_mapping[6];
-		pdimm[slot].dq_mapping[3] = pdimm[slot].dq_mapping[7];
-		pdimm[slot].dq_mapping[6] = dq_mapping_2;
-		pdimm[slot].dq_mapping[7] = dq_mapping_3;
-		pdimm[slot].dq_mapping[8] = dq_mapping_0;
-		pdimm[slot].dq_mapping[9] = 0;
-		pdimm[slot].dq_mapping[10] = 0;
-		pdimm[slot].dq_mapping[11] = 0;
-		pdimm[slot].dq_mapping[12] = 0;
-		pdimm[slot].dq_mapping[13] = 0;
-		pdimm[slot].dq_mapping[14] = 0;
-		pdimm[slot].dq_mapping[15] = 0;
-		pdimm[slot].dq_mapping[16] = 0;
-		pdimm[slot].dq_mapping[17] = 0;
-	}
-	/* To work at higher than 1333MT/s */
-	popts->half_strength_driver_enable = 0;
-	/*
-	 * Write leveling override
-	 */
-	popts->wrlvl_override = 1;
-	popts->wrlvl_sample = 0x0;	/* 32 clocks */
-
-	/*
-	 * Rtt and Rtt_WR override
-	 */
-	popts->rtt_override = 0;
-
-	/* Enable ZQ calibration */
-	popts->zq_en = 1;
-
-	if (ddr_freq < 2350) {
-		popts->ddr_cdr1 = DDR_CDR1_DHC_EN |
-				  DDR_CDR1_ODT(DDR_CDR_ODT_60ohm);
-		popts->ddr_cdr2 = DDR_CDR2_ODT(DDR_CDR_ODT_60ohm) |
-				  DDR_CDR2_VREF_RANGE_2;
-	} else {
-		popts->ddr_cdr1 = DDR_CDR1_DHC_EN |
-				  DDR_CDR1_ODT(DDR_CDR_ODT_100ohm);
-		popts->ddr_cdr2 = DDR_CDR2_ODT(DDR_CDR_ODT_100ohm) |
-				  DDR_CDR2_VREF_RANGE_2;
-	}
-}
-
-phys_size_t initdram(int board_type)
-{
-	phys_size_t dram_size;
-
-#if defined(CONFIG_SPL) && !defined(CONFIG_SPL_BUILD)
-	return fsl_ddr_sdram_size();
-#else
-	puts("Initializing DDR....using SPD\n");
-
-	dram_size = fsl_ddr_sdram();
-#endif
-
-	return dram_size;
-}
-
-void dram_init_banksize(void)
-{
-#ifdef CONFIG_SYS_DP_DDR_BASE_PHY
-	phys_size_t dp_ddr_size;
-#endif
-
-	gd->bd->bi_dram[0].start = CONFIG_SYS_SDRAM_BASE;
-	if (gd->ram_size > CONFIG_SYS_LS2_DDR_BLOCK1_SIZE) {
-		gd->bd->bi_dram[0].size = CONFIG_SYS_LS2_DDR_BLOCK1_SIZE;
-		gd->bd->bi_dram[1].start = CONFIG_SYS_DDR_BLOCK2_BASE;
-		gd->bd->bi_dram[1].size = gd->ram_size -
-					  CONFIG_SYS_LS2_DDR_BLOCK1_SIZE;
-	} else {
-		gd->bd->bi_dram[0].size = gd->ram_size;
-	}
-
-#ifdef CONFIG_SYS_DP_DDR_BASE_PHY
-	/* initialize DP-DDR here */
-	puts("DP-DDR:  ");
-	/*
-	 * DDR controller use 0 as the base address for binding.
-	 * It is mapped to CONFIG_SYS_DP_DDR_BASE for core to access.
-	 */
-	dp_ddr_size = fsl_other_ddr_sdram(CONFIG_SYS_DP_DDR_BASE_PHY,
-					  CONFIG_DP_DDR_CTRL,
-					  CONFIG_DP_DDR_NUM_CTRLS,
-					  CONFIG_DP_DDR_DIMM_SLOTS_PER_CTLR,
-					  NULL, NULL, NULL);
-	if (dp_ddr_size) {
-		gd->bd->bi_dram[2].start = CONFIG_SYS_DP_DDR_BASE;
-		gd->bd->bi_dram[2].size = dp_ddr_size;
-	} else {
-		puts("Not detected");
-	}
-#endif
-}
diff --git a/board/freescale/ls2085aqds/ddr.h b/board/freescale/ls2085aqds/ddr.h
deleted file mode 100644
index b76ea61..0000000
--- a/board/freescale/ls2085aqds/ddr.h
+++ /dev/null
@@ -1,92 +0,0 @@
-/*
- * Copyright 2015 Freescale Semiconductor, Inc.
- *
- * SPDX-License-Identifier:	GPL-2.0+
- */
-
-#ifndef __DDR_H__
-#define __DDR_H__
-struct board_specific_parameters {
-	u32 n_ranks;
-	u32 datarate_mhz_high;
-	u32 rank_gb;
-	u32 clk_adjust;
-	u32 wrlvl_start;
-	u32 wrlvl_ctl_2;
-	u32 wrlvl_ctl_3;
-};
-
-/*
- * These tables contain all valid speeds we want to override with board
- * specific parameters. datarate_mhz_high values need to be in ascending order
- * for each n_ranks group.
- */
-
-static const struct board_specific_parameters udimm0[] = {
-	/*
-	 * memory controller 0
-	 *   num|  hi| rank|  clk| wrlvl |   wrlvl   |  wrlvl
-	 * ranks| mhz| GB  |adjst| start |   ctl2    |  ctl3
-	 */
-	{2,  1350, 0, 4,     6, 0x0708090B, 0x0C0D0E09,},
-	{2,  1666, 0, 4,     7, 0x08090A0C, 0x0D0F100B,},
-	{2,  1900, 0, 4,     7, 0x09090B0D, 0x0E10120B,},
-	{2,  2300, 0, 4,     8, 0x090A0C0F, 0x1012130C,},
-	{}
-};
-
-/* DP-DDR DIMM */
-static const struct board_specific_parameters udimm2[] = {
-	/*
-	 * memory controller 2
-	 *   num|  hi| rank|  clk| wrlvl |   wrlvl   |  wrlvl
-	 * ranks| mhz| GB  |adjst| start |   ctl2    |  ctl3
-	 */
-	{2,  1350, 0, 4,   0xd, 0x0C0A0A00, 0x00000009,},
-	{2,  1666, 0, 4,   0xd, 0x0C0A0A00, 0x00000009,},
-	{2,  1900, 0, 4,   0xe, 0x0D0C0B00, 0x0000000A,},
-	{2,  2200, 0, 4,   0xe, 0x0D0C0B00, 0x0000000A,},
-	{}
-};
-
-static const struct board_specific_parameters rdimm0[] = {
-	/*
-	 * memory controller 0
-	 *   num|  hi| rank|  clk| wrlvl |   wrlvl   |  wrlvl
-	 * ranks| mhz| GB  |adjst| start |   ctl2    |  ctl3
-	 */
-	{2,  1350, 0, 4,     6, 0x0708090B, 0x0C0D0E09,},
-	{2,  1666, 0, 4,     7, 0x08090A0C, 0x0D0F100B,},
-	{2,  1900, 0, 4,     7, 0x09090B0D, 0x0E10120B,},
-	{2,  2200, 0, 4,     8, 0x090A0C0F, 0x1012130C,},
-	{}
-};
-
-/* DP-DDR DIMM */
-static const struct board_specific_parameters rdimm2[] = {
-	/*
-	 * memory controller 2
-	 *   num|  hi| rank|  clk| wrlvl |   wrlvl   |  wrlvl
-	 * ranks| mhz| GB  |adjst| start |   ctl2    |  ctl3
-	 */
-	{2,  1350, 0, 4,     6, 0x0708090B, 0x0C0D0E09,},
-	{2,  1666, 0, 4,     7, 0x0B0A090C, 0x0D0F100B,},
-	{2,  1900, 0, 4,     7, 0x09090B0D, 0x0E10120B,},
-	{2,  2200, 0, 4,     8, 0x090A0C0F, 0x1012130C,},
-	{}
-};
-
-static const struct board_specific_parameters *udimms[] = {
-	udimm0,
-	udimm0,
-	udimm2,
-};
-
-static const struct board_specific_parameters *rdimms[] = {
-	rdimm0,
-	rdimm0,
-	rdimm2,
-};
-
-
-#endif
diff --git a/board/freescale/ls2085aqds/eth.c b/board/freescale/ls2085aqds/eth.c
deleted file mode 100644
index b8a2bf4..0000000
--- a/board/freescale/ls2085aqds/eth.c
+++ /dev/null
@@ -1,825 +0,0 @@
-/*
- * Copyright 2015 Freescale Semiconductor, Inc.
- *
- * SPDX-License-Identifier:	GPL-2.0+
- */
-
-#include <common.h>
-#include <netdev.h>
-#include <asm/io.h>
-#include <asm/arch/fsl_serdes.h>
-#include <hwconfig.h>
-#include <fsl_mdio.h>
-#include <malloc.h>
-#include <fm_eth.h>
-#include <i2c.h>
-#include <miiphy.h>
-#include <fsl-mc/ldpaa_wriop.h>
-
-#include "../common/qixis.h"
-
-#include "ls2085aqds_qixis.h"
-
-
-#ifdef CONFIG_FSL_MC_ENET
- /* - In LS2085A there are only 16 SERDES lanes, spread across 2 SERDES banks.
- *   Bank 1 -> Lanes A, B, C, D, E, F, G, H
- *   Bank 2 -> Lanes A,B, C, D, E, F, G, H
- */
-
- /* Mapping of 16 SERDES lanes to LS2085A QDS board slots. A value of '0' here
-  * means that the mapping must be determined dynamically, or that the lane
-  * maps to something other than a board slot.
-  */
-
-static u8 lane_to_slot_fsm1[] = {
-	0, 0, 0, 0, 0, 0, 0, 0
-};
-
-static u8 lane_to_slot_fsm2[] = {
-	0, 0, 0, 0, 0, 0, 0, 0
-};
-
-/* On the Vitesse VSC8234XHG SGMII riser card there are 4 SGMII PHYs
- * housed.
- */
-
-static int xqsgii_riser_phy_addr[] = {
-	XQSGMII_CARD_PHY1_PORT0_ADDR,
-	XQSGMII_CARD_PHY2_PORT0_ADDR,
-	XQSGMII_CARD_PHY3_PORT0_ADDR,
-	XQSGMII_CARD_PHY4_PORT0_ADDR,
-	XQSGMII_CARD_PHY3_PORT2_ADDR,
-	XQSGMII_CARD_PHY1_PORT2_ADDR,
-	XQSGMII_CARD_PHY4_PORT2_ADDR,
-	XQSGMII_CARD_PHY2_PORT2_ADDR,
-};
-
-static int sgmii_riser_phy_addr[] = {
-	SGMII_CARD_PORT1_PHY_ADDR,
-	SGMII_CARD_PORT2_PHY_ADDR,
-	SGMII_CARD_PORT3_PHY_ADDR,
-	SGMII_CARD_PORT4_PHY_ADDR,
-};
-
-/* Slot2 does not have EMI connections */
-#define EMI_NONE	0xFFFFFFFF
-#define EMI1_SLOT1	0
-#define EMI1_SLOT2	1
-#define EMI1_SLOT3	2
-#define EMI1_SLOT4	3
-#define EMI1_SLOT5	4
-#define EMI1_SLOT6	5
-#define EMI2		6
-#define SFP_TX		0
-
-static const char * const mdio_names[] = {
-	"LS2085A_QDS_MDIO0",
-	"LS2085A_QDS_MDIO1",
-	"LS2085A_QDS_MDIO2",
-	"LS2085A_QDS_MDIO3",
-	"LS2085A_QDS_MDIO4",
-	"LS2085A_QDS_MDIO5",
-	DEFAULT_WRIOP_MDIO2_NAME,
-};
-
-struct ls2085a_qds_mdio {
-	u8 muxval;
-	struct mii_dev *realbus;
-};
-
-static void sgmii_configure_repeater(int serdes_port)
-{
-	struct mii_dev *bus;
-	uint8_t a = 0xf;
-	int i, j, ret;
-	int dpmac_id = 0, dpmac, mii_bus = 0;
-	unsigned short value;
-	char dev[2][20] = {"LS2085A_QDS_MDIO0", "LS2085A_QDS_MDIO3"};
-	uint8_t i2c_addr[] = {0x58, 0x59, 0x5a, 0x5b, 0x5c, 0x5d, 0x5f, 0x60};
-
-	uint8_t ch_a_eq[] = {0x1, 0x2, 0x3, 0x7};
-	uint8_t ch_a_ctl2[] = {0x81, 0x82, 0x83, 0x84};
-	uint8_t ch_b_eq[] = {0x1, 0x2, 0x3, 0x7};
-	uint8_t ch_b_ctl2[] = {0x81, 0x82, 0x83, 0x84};
-
-	int *riser_phy_addr = &xqsgii_riser_phy_addr[0];
-
-	/* Set I2c to Slot 1 */
-	i2c_write(0x77, 0, 0, &a, 1);
-
-	for (dpmac = 0; dpmac < 8; dpmac++) {
-		/* Check the PHY status */
-		switch (serdes_port) {
-		case 1:
-			mii_bus = 0;
-			dpmac_id = dpmac + 1;
-			break;
-		case 2:
-			mii_bus = 1;
-			dpmac_id = dpmac + 9;
-			a = 0xb;
-			i2c_write(0x76, 0, 0, &a, 1);
-			break;
-		}
-
-		ret = miiphy_set_current_dev(dev[mii_bus]);
-		if (ret > 0)
-			goto error;
-
-		bus = mdio_get_current_dev();
-		debug("Reading from bus %s\n", bus->name);
-
-		ret = miiphy_write(dev[mii_bus], riser_phy_addr[dpmac], 0x1f,
-				   3);
-		if (ret > 0)
-			goto error;
-
-		mdelay(10);
-		ret = miiphy_read(dev[mii_bus], riser_phy_addr[dpmac], 0x11,
-				  &value);
-		if (ret > 0)
-			goto error;
-
-		mdelay(10);
-
-		if ((value & 0xfff) == 0x40f) {
-			printf("DPMAC %d:PHY is ..... Configured\n", dpmac_id);
-			continue;
-		}
-
-		for (i = 0; i < 4; i++) {
-			for (j = 0; j < 4; j++) {
-				a = 0x18;
-				i2c_write(i2c_addr[dpmac], 6, 1, &a, 1);
-				a = 0x38;
-				i2c_write(i2c_addr[dpmac], 4, 1, &a, 1);
-				a = 0x4;
-				i2c_write(i2c_addr[dpmac], 8, 1, &a, 1);
-
-				i2c_write(i2c_addr[dpmac], 0xf, 1,
-					  &ch_a_eq[i], 1);
-				i2c_write(i2c_addr[dpmac], 0x11, 1,
-					  &ch_a_ctl2[j], 1);
-
-				i2c_write(i2c_addr[dpmac], 0x16, 1,
-					  &ch_b_eq[i], 1);
-				i2c_write(i2c_addr[dpmac], 0x18, 1,
-					  &ch_b_ctl2[j], 1);
-
-				a = 0x14;
-				i2c_write(i2c_addr[dpmac], 0x23, 1, &a, 1);
-				a = 0xb5;
-				i2c_write(i2c_addr[dpmac], 0x2d, 1, &a, 1);
-				a = 0x20;
-				i2c_write(i2c_addr[dpmac], 4, 1, &a, 1);
-				mdelay(100);
-				ret = miiphy_read(dev[mii_bus],
-						  riser_phy_addr[dpmac],
-						  0x11, &value);
-				if (ret > 0)
-					goto error;
-
-				mdelay(1);
-				ret = miiphy_read(dev[mii_bus],
-						  riser_phy_addr[dpmac],
-						  0x11, &value);
-				if (ret > 0)
-					goto error;
-				mdelay(10);
-
-				if ((value & 0xfff) == 0x40f) {
-					printf("DPMAC %d :PHY is configured ",
-					       dpmac_id);
-					printf("after setting repeater 0x%x\n",
-					       value);
-					i = 5;
-					j = 5;
-				} else
-					printf("DPMAC %d :PHY is failed to ",
-					       dpmac_id);
-					printf("configure the repeater 0x%x\n",
-					       value);
-				}
-		}
-	}
-error:
-	if (ret)
-		printf("DPMAC %d ..... FAILED to configure PHY\n", dpmac_id);
-	return;
-}
-
-static void qsgmii_configure_repeater(int dpmac)
-{
-	uint8_t a = 0xf;
-	int i, j;
-	int i2c_phy_addr = 0;
-	int phy_addr = 0;
-	int i2c_addr[] = {0x58, 0x59, 0x5a, 0x5b};
-
-	uint8_t ch_a_eq[] = {0x1, 0x2, 0x3, 0x7};
-	uint8_t ch_a_ctl2[] = {0x81, 0x82, 0x83, 0x84};
-	uint8_t ch_b_eq[] = {0x1, 0x2, 0x3, 0x7};
-	uint8_t ch_b_ctl2[] = {0x81, 0x82, 0x83, 0x84};
-
-	const char *dev = "LS2085A_QDS_MDIO0";
-	int ret = 0;
-	unsigned short value;
-
-	/* Set I2c to Slot 1 */
-	i2c_write(0x77, 0, 0, &a, 1);
-
-	switch (dpmac) {
-	case 1:
-	case 2:
-	case 3:
-	case 4:
-		i2c_phy_addr = i2c_addr[0];
-		phy_addr = 0;
-		break;
-
-	case 5:
-	case 6:
-	case 7:
-	case 8:
-		i2c_phy_addr = i2c_addr[1];
-		phy_addr = 4;
-		break;
-
-	case 9:
-	case 10:
-	case 11:
-	case 12:
-		i2c_phy_addr = i2c_addr[2];
-		phy_addr = 8;
-		break;
-
-	case 13:
-	case 14:
-	case 15:
-	case 16:
-		i2c_phy_addr = i2c_addr[3];
-		phy_addr = 0xc;
-		break;
-	}
-
-	/* Check the PHY status */
-	ret = miiphy_set_current_dev(dev);
-	ret = miiphy_write(dev, phy_addr, 0x1f, 3);
-	mdelay(10);
-	ret = miiphy_read(dev, phy_addr, 0x11, &value);
-	mdelay(10);
-	ret = miiphy_read(dev, phy_addr, 0x11, &value);
-	mdelay(10);
-	if ((value & 0xf) == 0xf) {
-		printf("DPMAC %d :PHY is ..... Configured\n", dpmac);
-		return;
-	}
-
-	for (i = 0; i < 4; i++) {
-		for (j = 0; j < 4; j++) {
-			a = 0x18;
-			i2c_write(i2c_phy_addr, 6, 1, &a, 1);
-			a = 0x38;
-			i2c_write(i2c_phy_addr, 4, 1, &a, 1);
-			a = 0x4;
-			i2c_write(i2c_phy_addr, 8, 1, &a, 1);
-
-			i2c_write(i2c_phy_addr, 0xf, 1, &ch_a_eq[i], 1);
-			i2c_write(i2c_phy_addr, 0x11, 1, &ch_a_ctl2[j], 1);
-
-			i2c_write(i2c_phy_addr, 0x16, 1, &ch_b_eq[i], 1);
-			i2c_write(i2c_phy_addr, 0x18, 1, &ch_b_ctl2[j], 1);
-
-			a = 0x14;
-			i2c_write(i2c_phy_addr, 0x23, 1, &a, 1);
-			a = 0xb5;
-			i2c_write(i2c_phy_addr, 0x2d, 1, &a, 1);
-			a = 0x20;
-			i2c_write(i2c_phy_addr, 4, 1, &a, 1);
-			mdelay(100);
-			ret = miiphy_read(dev, phy_addr, 0x11, &value);
-			if (ret > 0)
-				goto error;
-			mdelay(1);
-			ret = miiphy_read(dev, phy_addr, 0x11, &value);
-			if (ret > 0)
-				goto error;
-			mdelay(10);
-			if ((value & 0xf) == 0xf) {
-				printf("DPMAC %d :PHY is ..... Configured\n",
-				       dpmac);
-				return;
-			}
-		}
-	}
-error:
-	printf("DPMAC %d :PHY ..... FAILED to configure PHY\n", dpmac);
-	return;
-}
-
-static const char *ls2085a_qds_mdio_name_for_muxval(u8 muxval)
-{
-	return mdio_names[muxval];
-}
-
-struct mii_dev *mii_dev_for_muxval(u8 muxval)
-{
-	struct mii_dev *bus;
-	const char *name = ls2085a_qds_mdio_name_for_muxval(muxval);
-
-	if (!name) {
-		printf("No bus for muxval %x\n", muxval);
-		return NULL;
-	}
-
-	bus = miiphy_get_dev_by_name(name);
-
-	if (!bus) {
-		printf("No bus by name %s\n", name);
-		return NULL;
-	}
-
-	return bus;
-}
-
-static void ls2085a_qds_enable_SFP_TX(u8 muxval)
-{
-	u8 brdcfg9;
-
-	brdcfg9 = QIXIS_READ(brdcfg[9]);
-	brdcfg9 &= ~BRDCFG9_SFPTX_MASK;
-	brdcfg9 |= (muxval << BRDCFG9_SFPTX_SHIFT);
-	QIXIS_WRITE(brdcfg[9], brdcfg9);
-}
-
-static void ls2085a_qds_mux_mdio(u8 muxval)
-{
-	u8 brdcfg4;
-
-	if (muxval <= 5) {
-		brdcfg4 = QIXIS_READ(brdcfg[4]);
-		brdcfg4 &= ~BRDCFG4_EMISEL_MASK;
-		brdcfg4 |= (muxval << BRDCFG4_EMISEL_SHIFT);
-		QIXIS_WRITE(brdcfg[4], brdcfg4);
-	}
-}
-
-static int ls2085a_qds_mdio_read(struct mii_dev *bus, int addr,
-				 int devad, int regnum)
-{
-	struct ls2085a_qds_mdio *priv = bus->priv;
-
-	ls2085a_qds_mux_mdio(priv->muxval);
-
-	return priv->realbus->read(priv->realbus, addr, devad, regnum);
-}
-
-static int ls2085a_qds_mdio_write(struct mii_dev *bus, int addr, int devad,
-				  int regnum, u16 value)
-{
-	struct ls2085a_qds_mdio *priv = bus->priv;
-
-	ls2085a_qds_mux_mdio(priv->muxval);
-
-	return priv->realbus->write(priv->realbus, addr, devad, regnum, value);
-}
-
-static int ls2085a_qds_mdio_reset(struct mii_dev *bus)
-{
-	struct ls2085a_qds_mdio *priv = bus->priv;
-
-	return priv->realbus->reset(priv->realbus);
-}
-
-static int ls2085a_qds_mdio_init(char *realbusname, u8 muxval)
-{
-	struct ls2085a_qds_mdio *pmdio;
-	struct mii_dev *bus = mdio_alloc();
-
-	if (!bus) {
-		printf("Failed to allocate ls2085a_qds MDIO bus\n");
-		return -1;
-	}
-
-	pmdio = malloc(sizeof(*pmdio));
-	if (!pmdio) {
-		printf("Failed to allocate ls2085a_qds private data\n");
-		free(bus);
-		return -1;
-	}
-
-	bus->read = ls2085a_qds_mdio_read;
-	bus->write = ls2085a_qds_mdio_write;
-	bus->reset = ls2085a_qds_mdio_reset;
-	sprintf(bus->name, ls2085a_qds_mdio_name_for_muxval(muxval));
-
-	pmdio->realbus = miiphy_get_dev_by_name(realbusname);
-
-	if (!pmdio->realbus) {
-		printf("No bus with name %s\n", realbusname);
-		free(bus);
-		free(pmdio);
-		return -1;
-	}
-
-	pmdio->muxval = muxval;
-	bus->priv = pmdio;
-
-	return mdio_register(bus);
-}
-
-/*
- * Initialize the dpmac_info array.
- *
- */
-static void initialize_dpmac_to_slot(void)
-{
-	struct ccsr_gur __iomem *gur = (void *)CONFIG_SYS_FSL_GUTS_ADDR;
-	int serdes1_prtcl = (in_le32(&gur->rcwsr[28]) &
-				FSL_CHASSIS3_RCWSR28_SRDS1_PRTCL_MASK)
-		>> FSL_CHASSIS3_RCWSR28_SRDS1_PRTCL_SHIFT;
-	int serdes2_prtcl = (in_le32(&gur->rcwsr[28]) &
-				FSL_CHASSIS3_RCWSR28_SRDS2_PRTCL_MASK)
-		>> FSL_CHASSIS3_RCWSR28_SRDS2_PRTCL_SHIFT;
-
-	char *env_hwconfig;
-	env_hwconfig = getenv("hwconfig");
-
-	switch (serdes1_prtcl) {
-	case 0x07:
-	case 0x09:
-	case 0x33:
-		printf("qds: WRIOP: Supported SerDes1 Protocol 0x%02x\n",
-		       serdes1_prtcl);
-		lane_to_slot_fsm1[0] = EMI1_SLOT1;
-		lane_to_slot_fsm1[1] = EMI1_SLOT1;
-		lane_to_slot_fsm1[2] = EMI1_SLOT1;
-		lane_to_slot_fsm1[3] = EMI1_SLOT1;
-		if (hwconfig_f("xqsgmii", env_hwconfig)) {
-			lane_to_slot_fsm1[4] = EMI1_SLOT1;
-			lane_to_slot_fsm1[5] = EMI1_SLOT1;
-			lane_to_slot_fsm1[6] = EMI1_SLOT1;
-			lane_to_slot_fsm1[7] = EMI1_SLOT1;
-		} else {
-			lane_to_slot_fsm1[4] = EMI1_SLOT2;
-			lane_to_slot_fsm1[5] = EMI1_SLOT2;
-			lane_to_slot_fsm1[6] = EMI1_SLOT2;
-			lane_to_slot_fsm1[7] = EMI1_SLOT2;
-		}
-		break;
-
-	case 0x2A:
-		printf("qds: WRIOP: Supported SerDes1 Protocol 0x%02x\n",
-		       serdes1_prtcl);
-		break;
-	default:
-		printf("qds: WRIOP: Unsupported SerDes1 Protocol 0x%02x\n",
-		       serdes1_prtcl);
-		break;
-	}
-
-	switch (serdes2_prtcl) {
-	case 0x07:
-	case 0x08:
-	case 0x09:
-	case 0x49:
-		printf("qds: WRIOP: Supported SerDes2 Protocol 0x%02x\n",
-		       serdes2_prtcl);
-		lane_to_slot_fsm2[0] = EMI1_SLOT4;
-		lane_to_slot_fsm2[1] = EMI1_SLOT4;
-		lane_to_slot_fsm2[2] = EMI1_SLOT4;
-		lane_to_slot_fsm2[3] = EMI1_SLOT4;
-
-		if (hwconfig_f("xqsgmii", env_hwconfig)) {
-			lane_to_slot_fsm2[4] = EMI1_SLOT4;
-			lane_to_slot_fsm2[5] = EMI1_SLOT4;
-			lane_to_slot_fsm2[6] = EMI1_SLOT4;
-			lane_to_slot_fsm2[7] = EMI1_SLOT4;
-		} else {
-			/* No MDIO physical connection */
-			lane_to_slot_fsm2[4] = EMI1_SLOT6;
-			lane_to_slot_fsm2[5] = EMI1_SLOT6;
-			lane_to_slot_fsm2[6] = EMI1_SLOT6;
-			lane_to_slot_fsm2[7] = EMI1_SLOT6;
-		}
-		break;
-	default:
-		printf("qds: WRIOP: Unsupported SerDes2 Protocol 0x%02x\n",
-		       serdes2_prtcl);
-		break;
-	}
-}
-
-void ls2085a_handle_phy_interface_sgmii(int dpmac_id)
-{
-	int lane, slot;
-	struct mii_dev *bus;
-	struct ccsr_gur __iomem *gur = (void *)CONFIG_SYS_FSL_GUTS_ADDR;
-	int serdes1_prtcl = (in_le32(&gur->rcwsr[28]) &
-				FSL_CHASSIS3_RCWSR28_SRDS1_PRTCL_MASK)
-		>> FSL_CHASSIS3_RCWSR28_SRDS1_PRTCL_SHIFT;
-	int serdes2_prtcl = (in_le32(&gur->rcwsr[28]) &
-				FSL_CHASSIS3_RCWSR28_SRDS2_PRTCL_MASK)
-		>> FSL_CHASSIS3_RCWSR28_SRDS2_PRTCL_SHIFT;
-
-	int *riser_phy_addr;
-	char *env_hwconfig = getenv("hwconfig");
-
-	if (hwconfig_f("xqsgmii", env_hwconfig))
-		riser_phy_addr = &xqsgii_riser_phy_addr[0];
-	else
-		riser_phy_addr = &sgmii_riser_phy_addr[0];
-
-	if (dpmac_id > WRIOP1_DPMAC9)
-		goto serdes2;
-
-	switch (serdes1_prtcl) {
-	case 0x07:
-
-		lane = serdes_get_first_lane(FSL_SRDS_1, SGMII1 + dpmac_id);
-		slot = lane_to_slot_fsm1[lane];
-
-		switch (++slot) {
-		case 1:
-			/* Slot housing a SGMII riser card? */
-			wriop_set_phy_address(dpmac_id,
-					      riser_phy_addr[dpmac_id - 1]);
-			dpmac_info[dpmac_id].board_mux = EMI1_SLOT1;
-			bus = mii_dev_for_muxval(EMI1_SLOT1);
-			wriop_set_mdio(dpmac_id, bus);
-			dpmac_info[dpmac_id].phydev = phy_connect(
-						dpmac_info[dpmac_id].bus,
-						dpmac_info[dpmac_id].phy_addr,
-						NULL,
-						dpmac_info[dpmac_id].enet_if);
-			phy_config(dpmac_info[dpmac_id].phydev);
-			break;
-		case 2:
-			/* Slot housing a SGMII riser card? */
-			wriop_set_phy_address(dpmac_id,
-					      riser_phy_addr[dpmac_id - 1]);
-			dpmac_info[dpmac_id].board_mux = EMI1_SLOT2;
-			bus = mii_dev_for_muxval(EMI1_SLOT2);
-			wriop_set_mdio(dpmac_id, bus);
-			dpmac_info[dpmac_id].phydev = phy_connect(
-						dpmac_info[dpmac_id].bus,
-						dpmac_info[dpmac_id].phy_addr,
-						NULL,
-						dpmac_info[dpmac_id].enet_if);
-			phy_config(dpmac_info[dpmac_id].phydev);
-			break;
-		case 3:
-			break;
-		case 4:
-			break;
-		case 5:
-			break;
-		case 6:
-			break;
-		}
-	break;
-	default:
-		printf("qds: WRIOP: Unsupported SerDes1 Protocol 0x%02x\n",
-		       serdes1_prtcl);
-	break;
-	}
-
-serdes2:
-	switch (serdes2_prtcl) {
-	case 0x07:
-	case 0x08:
-	case 0x49:
-		lane = serdes_get_first_lane(FSL_SRDS_2, SGMII9 +
-							(dpmac_id - 9));
-		slot = lane_to_slot_fsm2[lane];
-
-		switch (++slot) {
-		case 1:
-			break;
-		case 3:
-			break;
-		case 4:
-			/* Slot housing a SGMII riser card? */
-			wriop_set_phy_address(dpmac_id,
-					      riser_phy_addr[dpmac_id - 9]);
-			dpmac_info[dpmac_id].board_mux = EMI1_SLOT4;
-			bus = mii_dev_for_muxval(EMI1_SLOT4);
-			wriop_set_mdio(dpmac_id, bus);
-			dpmac_info[dpmac_id].phydev = phy_connect(
-						dpmac_info[dpmac_id].bus,
-						dpmac_info[dpmac_id].phy_addr,
-						NULL,
-						dpmac_info[dpmac_id].enet_if);
-			phy_config(dpmac_info[dpmac_id].phydev);
-		break;
-		case 5:
-		break;
-		case 6:
-			/* Slot housing a SGMII riser card? */
-			wriop_set_phy_address(dpmac_id,
-					      riser_phy_addr[dpmac_id - 13]);
-			dpmac_info[dpmac_id].board_mux = EMI1_SLOT6;
-			bus = mii_dev_for_muxval(EMI1_SLOT6);
-			wriop_set_mdio(dpmac_id, bus);
-		break;
-	}
-	break;
-	default:
-		printf("qds: WRIOP: Unsupported SerDes2 Protocol 0x%02x\n",
-		       serdes2_prtcl);
-	break;
-	}
-}
-
-void ls2085a_handle_phy_interface_qsgmii(int dpmac_id)
-{
-	int lane = 0, slot;
-	struct mii_dev *bus;
-	struct ccsr_gur __iomem *gur = (void *)CONFIG_SYS_FSL_GUTS_ADDR;
-	int serdes1_prtcl = (in_le32(&gur->rcwsr[28]) &
-				FSL_CHASSIS3_RCWSR28_SRDS1_PRTCL_MASK)
-		>> FSL_CHASSIS3_RCWSR28_SRDS1_PRTCL_SHIFT;
-
-	switch (serdes1_prtcl) {
-	case 0x33:
-		switch (dpmac_id) {
-		case 1:
-		case 2:
-		case 3:
-		case 4:
-			lane = serdes_get_first_lane(FSL_SRDS_1, QSGMII_A);
-		break;
-		case 5:
-		case 6:
-		case 7:
-		case 8:
-			lane = serdes_get_first_lane(FSL_SRDS_1, QSGMII_B);
-		break;
-		case 9:
-		case 10:
-		case 11:
-		case 12:
-			lane = serdes_get_first_lane(FSL_SRDS_1, QSGMII_C);
-		break;
-		case 13:
-		case 14:
-		case 15:
-		case 16:
-			lane = serdes_get_first_lane(FSL_SRDS_1, QSGMII_D);
-		break;
-	}
-
-		slot = lane_to_slot_fsm1[lane];
-
-		switch (++slot) {
-		case 1:
-			/* Slot housing a QSGMII riser card? */
-			wriop_set_phy_address(dpmac_id, dpmac_id - 1);
-			dpmac_info[dpmac_id].board_mux = EMI1_SLOT1;
-			bus = mii_dev_for_muxval(EMI1_SLOT1);
-			wriop_set_mdio(dpmac_id, bus);
-			dpmac_info[dpmac_id].phydev = phy_connect(
-						dpmac_info[dpmac_id].bus,
-						dpmac_info[dpmac_id].phy_addr,
-						NULL,
-						dpmac_info[dpmac_id].enet_if);
-
-			phy_config(dpmac_info[dpmac_id].phydev);
-			break;
-		case 3:
-			break;
-		case 4:
-			break;
-		case 5:
-		break;
-		case 6:
-			break;
-	}
-	break;
-	default:
-		printf("qds: WRIOP: Unsupported SerDes Protocol 0x%02x\n",
-		       serdes1_prtcl);
-	break;
-	}
-
-	qsgmii_configure_repeater(dpmac_id);
-}
-
-void ls2085a_handle_phy_interface_xsgmii(int i)
-{
-	struct ccsr_gur __iomem *gur = (void *)CONFIG_SYS_FSL_GUTS_ADDR;
-	int serdes1_prtcl = (in_le32(&gur->rcwsr[28]) &
-				FSL_CHASSIS3_RCWSR28_SRDS1_PRTCL_MASK)
-		>> FSL_CHASSIS3_RCWSR28_SRDS1_PRTCL_SHIFT;
-
-	switch (serdes1_prtcl) {
-	case 0x2A:
-		/*
-		 * XFI does not need a PHY to work, but to avoid U-boot use
-		 * default PHY address which is zero to a MAC when it found
-		 * a MAC has no PHY address, we give a PHY address to XFI
-		 * MAC, and should not use a real XAUI PHY address, since
-		 * MDIO can access it successfully, and then MDIO thinks
-		 * the XAUI card is used for the XFI MAC, which will cause
-		 * error.
-		 */
-		wriop_set_phy_address(i, i + 4);
-		ls2085a_qds_enable_SFP_TX(SFP_TX);
-
-		break;
-	default:
-		printf("qds: WRIOP: Unsupported SerDes Protocol 0x%02x\n",
-		       serdes1_prtcl);
-		break;
-	}
-}
-#endif
-
-int board_eth_init(bd_t *bis)
-{
-	int error;
-#ifdef CONFIG_FSL_MC_ENET
-	struct ccsr_gur __iomem *gur = (void *)CONFIG_SYS_FSL_GUTS_ADDR;
-	int serdes1_prtcl = (in_le32(&gur->rcwsr[28]) &
-				FSL_CHASSIS3_RCWSR28_SRDS1_PRTCL_MASK)
-		>> FSL_CHASSIS3_RCWSR28_SRDS1_PRTCL_SHIFT;
-	int serdes2_prtcl = (in_le32(&gur->rcwsr[28]) &
-				FSL_CHASSIS3_RCWSR28_SRDS2_PRTCL_MASK)
-		>> FSL_CHASSIS3_RCWSR28_SRDS2_PRTCL_SHIFT;
-
-	struct memac_mdio_info *memac_mdio0_info;
-	struct memac_mdio_info *memac_mdio1_info;
-	unsigned int i;
-	char *env_hwconfig;
-
-	env_hwconfig = getenv("hwconfig");
-
-	initialize_dpmac_to_slot();
-
-	memac_mdio0_info = (struct memac_mdio_info *)malloc(
-					sizeof(struct memac_mdio_info));
-	memac_mdio0_info->regs =
-		(struct memac_mdio_controller *)
-					CONFIG_SYS_FSL_WRIOP1_MDIO1;
-	memac_mdio0_info->name = DEFAULT_WRIOP_MDIO1_NAME;
-
-	/* Register the real MDIO1 bus */
-	fm_memac_mdio_init(bis, memac_mdio0_info);
-
-	memac_mdio1_info = (struct memac_mdio_info *)malloc(
-					sizeof(struct memac_mdio_info));
-	memac_mdio1_info->regs =
-		(struct memac_mdio_controller *)
-					CONFIG_SYS_FSL_WRIOP1_MDIO2;
-	memac_mdio1_info->name = DEFAULT_WRIOP_MDIO2_NAME;
-
-	/* Register the real MDIO2 bus */
-	fm_memac_mdio_init(bis, memac_mdio1_info);
-
-	/* Register the muxing front-ends to the MDIO buses */
-	ls2085a_qds_mdio_init(DEFAULT_WRIOP_MDIO1_NAME, EMI1_SLOT1);
-	ls2085a_qds_mdio_init(DEFAULT_WRIOP_MDIO1_NAME, EMI1_SLOT2);
-	ls2085a_qds_mdio_init(DEFAULT_WRIOP_MDIO1_NAME, EMI1_SLOT3);
-	ls2085a_qds_mdio_init(DEFAULT_WRIOP_MDIO1_NAME, EMI1_SLOT4);
-	ls2085a_qds_mdio_init(DEFAULT_WRIOP_MDIO1_NAME, EMI1_SLOT5);
-	ls2085a_qds_mdio_init(DEFAULT_WRIOP_MDIO1_NAME, EMI1_SLOT6);
-
-	ls2085a_qds_mdio_init(DEFAULT_WRIOP_MDIO2_NAME, EMI2);
-
-	for (i = WRIOP1_DPMAC1; i < NUM_WRIOP_PORTS; i++) {
-		switch (wriop_get_enet_if(i)) {
-		case PHY_INTERFACE_MODE_QSGMII:
-			ls2085a_handle_phy_interface_qsgmii(i);
-			break;
-		case PHY_INTERFACE_MODE_SGMII:
-			ls2085a_handle_phy_interface_sgmii(i);
-			break;
-		case PHY_INTERFACE_MODE_XGMII:
-			ls2085a_handle_phy_interface_xsgmii(i);
-			break;
-		default:
-			break;
-
-		if (i == 16)
-			i = NUM_WRIOP_PORTS;
-		}
-	}
-
-	error = cpu_eth_init(bis);
-
-	if (hwconfig_f("xqsgmii", env_hwconfig)) {
-		if (serdes1_prtcl == 0x7)
-			sgmii_configure_repeater(1);
-		if (serdes2_prtcl == 0x7 || serdes2_prtcl == 0x8 ||
-		    serdes2_prtcl == 0x49)
-			sgmii_configure_repeater(2);
-	}
-#endif
-	error = pci_eth_init(bis);
-	return error;
-}
-
-#ifdef CONFIG_FSL_MC_ENET
-
-#endif
diff --git a/board/freescale/ls2085aqds/ls2085aqds.c b/board/freescale/ls2085aqds/ls2085aqds.c
deleted file mode 100644
index 36b059f..0000000
--- a/board/freescale/ls2085aqds/ls2085aqds.c
+++ /dev/null
@@ -1,334 +0,0 @@
-/*
- * Copyright 2015 Freescale Semiconductor
- *
- * SPDX-License-Identifier:	GPL-2.0+
- */
-#include <common.h>
-#include <malloc.h>
-#include <errno.h>
-#include <netdev.h>
-#include <fsl_ifc.h>
-#include <fsl_ddr.h>
-#include <asm/io.h>
-#include <fdt_support.h>
-#include <libfdt.h>
-#include <fsl_debug_server.h>
-#include <fsl-mc/fsl_mc.h>
-#include <environment.h>
-#include <i2c.h>
-#include <rtc.h>
-#include <asm/arch/soc.h>
-#include <hwconfig.h>
-
-#include "../common/qixis.h"
-#include "ls2085aqds_qixis.h"
-
-#define PIN_MUX_SEL_SDHC	0x00
-#define PIN_MUX_SEL_DSPI	0x0a
-
-#define SET_SDHC_MUX_SEL(reg, value)	((reg & 0xf0) | value)
-
-DECLARE_GLOBAL_DATA_PTR;
-
-enum {
-	MUX_TYPE_SDHC,
-	MUX_TYPE_DSPI,
-};
-
-unsigned long long get_qixis_addr(void)
-{
-	unsigned long long addr;
-
-	if (gd->flags & GD_FLG_RELOC)
-		addr = QIXIS_BASE_PHYS;
-	else
-		addr = QIXIS_BASE_PHYS_EARLY;
-
-	/*
-	 * IFC address under 256MB is mapped to 0x30000000, any address above
-	 * is mapped to 0x5_10000000 up to 4GB.
-	 */
-	addr = addr  > 0x10000000 ? addr + 0x500000000ULL : addr + 0x30000000;
-
-	return addr;
-}
-
-int checkboard(void)
-{
-	char buf[64];
-	u8 sw;
-	static const char *const freq[] = {"100", "125", "156.25",
-					    "100 separate SSCG"};
-	int clock;
-
-	cpu_name(buf);
-	printf("Board: %s-QDS, ", buf);
-
-	sw = QIXIS_READ(arch);
-	printf("Board Arch: V%d, ", sw >> 4);
-	printf("Board version: %c, boot from ", (sw & 0xf) + 'A' - 1);
-
-	memset((u8 *)buf, 0x00, ARRAY_SIZE(buf));
-
-	sw = QIXIS_READ(brdcfg[0]);
-	sw = (sw & QIXIS_LBMAP_MASK) >> QIXIS_LBMAP_SHIFT;
-
-	if (sw < 0x8)
-		printf("vBank: %d\n", sw);
-	else if (sw == 0x8)
-		puts("PromJet\n");
-	else if (sw == 0x9)
-		puts("NAND\n");
-	else if (sw == 0x15)
-		printf("IFCCard\n");
-	else
-		printf("invalid setting of SW%u\n", QIXIS_LBMAP_SWITCH);
-
-	printf("FPGA: v%d (%s), build %d",
-	       (int)QIXIS_READ(scver), qixis_read_tag(buf),
-	       (int)qixis_read_minor());
-	/* the timestamp string contains "\n" at the end */
-	printf(" on %s", qixis_read_time(buf));
-
-	/*
-	 * Display the actual SERDES reference clocks as configured by the
-	 * dip switches on the board.  Note that the SWx registers could
-	 * technically be set to force the reference clocks to match the
-	 * values that the SERDES expects (or vice versa).  For now, however,
-	 * we just display both values and hope the user notices when they
-	 * don't match.
-	 */
-	puts("SERDES1 Reference : ");
-	sw = QIXIS_READ(brdcfg[2]);
-	clock = (sw >> 6) & 3;
-	printf("Clock1 = %sMHz ", freq[clock]);
-	clock = (sw >> 4) & 3;
-	printf("Clock2 = %sMHz", freq[clock]);
-
-	puts("\nSERDES2 Reference : ");
-	clock = (sw >> 2) & 3;
-	printf("Clock1 = %sMHz ", freq[clock]);
-	clock = (sw >> 0) & 3;
-	printf("Clock2 = %sMHz\n", freq[clock]);
-
-	return 0;
-}
-
-unsigned long get_board_sys_clk(void)
-{
-	u8 sysclk_conf = QIXIS_READ(brdcfg[1]);
-
-	switch (sysclk_conf & 0x0F) {
-	case QIXIS_SYSCLK_83:
-		return 83333333;
-	case QIXIS_SYSCLK_100:
-		return 100000000;
-	case QIXIS_SYSCLK_125:
-		return 125000000;
-	case QIXIS_SYSCLK_133:
-		return 133333333;
-	case QIXIS_SYSCLK_150:
-		return 150000000;
-	case QIXIS_SYSCLK_160:
-		return 160000000;
-	case QIXIS_SYSCLK_166:
-		return 166666666;
-	}
-	return 66666666;
-}
-
-unsigned long get_board_ddr_clk(void)
-{
-	u8 ddrclk_conf = QIXIS_READ(brdcfg[1]);
-
-	switch ((ddrclk_conf & 0x30) >> 4) {
-	case QIXIS_DDRCLK_100:
-		return 100000000;
-	case QIXIS_DDRCLK_125:
-		return 125000000;
-	case QIXIS_DDRCLK_133:
-		return 133333333;
-	}
-	return 66666666;
-}
-
-int select_i2c_ch_pca9547(u8 ch)
-{
-	int ret;
-
-	ret = i2c_write(I2C_MUX_PCA_ADDR_PRI, 0, 1, &ch, 1);
-	if (ret) {
-		puts("PCA: failed to select proper channel\n");
-		return ret;
-	}
-
-	return 0;
-}
-
-int config_board_mux(int ctrl_type)
-{
-	u8 reg5;
-
-	reg5 = QIXIS_READ(brdcfg[5]);
-
-	switch (ctrl_type) {
-	case MUX_TYPE_SDHC:
-		reg5 = SET_SDHC_MUX_SEL(reg5, PIN_MUX_SEL_SDHC);
-		break;
-	case MUX_TYPE_DSPI:
-		reg5 = SET_SDHC_MUX_SEL(reg5, PIN_MUX_SEL_DSPI);
-		break;
-	default:
-		printf("Wrong mux interface type\n");
-		return -1;
-	}
-
-	QIXIS_WRITE(brdcfg[5], reg5);
-
-	return 0;
-}
-
-int board_init(void)
-{
-	char *env_hwconfig;
-	u32 __iomem *dcfg_ccsr = (u32 __iomem *)DCFG_BASE;
-	u32 val;
-
-	init_final_memctl_regs();
-
-	val = in_le32(dcfg_ccsr + DCFG_RCWSR13 / 4);
-
-	env_hwconfig = getenv("hwconfig");
-
-	if (hwconfig_f("dspi", env_hwconfig) &&
-	    DCFG_RCWSR13_DSPI == (val & (u32)(0xf << 8)))
-		config_board_mux(MUX_TYPE_DSPI);
-	else
-		config_board_mux(MUX_TYPE_SDHC);
-
-#ifdef CONFIG_ENV_IS_NOWHERE
-	gd->env_addr = (ulong)&default_environment[0];
-#endif
-	select_i2c_ch_pca9547(I2C_MUX_CH_DEFAULT);
-	rtc_enable_32khz_output();
-
-	return 0;
-}
-
-int board_early_init_f(void)
-{
-	fsl_lsch3_early_init_f();
-	return 0;
-}
-
-void detail_board_ddr_info(void)
-{
-	puts("\nDDR    ");
-	print_size(gd->bd->bi_dram[0].size + gd->bd->bi_dram[1].size, "");
-	print_ddr_info(0);
-	if (gd->bd->bi_dram[2].size) {
-		puts("\nDP-DDR ");
-		print_size(gd->bd->bi_dram[2].size, "");
-		print_ddr_info(CONFIG_DP_DDR_CTRL);
-	}
-}
-
-int dram_init(void)
-{
-	gd->ram_size = initdram(0);
-
-	return 0;
-}
-
-#if defined(CONFIG_ARCH_MISC_INIT)
-int arch_misc_init(void)
-{
-#ifdef CONFIG_FSL_DEBUG_SERVER
-	debug_server_init();
-#endif
-
-	return 0;
-}
-#endif
-
-unsigned long get_dram_size_to_hide(void)
-{
-	unsigned long dram_to_hide = 0;
-
-/* Carve the Debug Server private DRAM block from the end of DRAM */
-#ifdef CONFIG_FSL_DEBUG_SERVER
-	dram_to_hide += debug_server_get_dram_block_size();
-#endif
-
-/* Carve the MC private DRAM block from the end of DRAM */
-#ifdef CONFIG_FSL_MC_ENET
-	dram_to_hide += mc_get_dram_block_size();
-#endif
-
-	return roundup(dram_to_hide, CONFIG_SYS_MEM_TOP_HIDE_MIN);
-}
-
-#ifdef CONFIG_FSL_MC_ENET
-void fdt_fixup_board_enet(void *fdt)
-{
-	int offset;
-
-	offset = fdt_path_offset(fdt, "/fsl-mc");
-
-	if (offset < 0)
-		offset = fdt_path_offset(fdt, "/fsl,dprc@0");
-
-	if (offset < 0) {
-		printf("%s: ERROR: fsl-mc node not found in device tree (error %d)\n",
-		       __func__, offset);
-		return;
-	}
-
-	if (get_mc_boot_status() == 0)
-		fdt_status_okay(fdt, offset);
-	else
-		fdt_status_fail(fdt, offset);
-}
-#endif
-
-#ifdef CONFIG_OF_BOARD_SETUP
-int ft_board_setup(void *blob, bd_t *bd)
-{
-	int err;
-	u64 base[CONFIG_NR_DRAM_BANKS];
-	u64 size[CONFIG_NR_DRAM_BANKS];
-
-	ft_cpu_setup(blob, bd);
-
-	/* fixup DT for the two GPP DDR banks */
-	base[0] = gd->bd->bi_dram[0].start;
-	size[0] = gd->bd->bi_dram[0].size;
-	base[1] = gd->bd->bi_dram[1].start;
-	size[1] = gd->bd->bi_dram[1].size;
-
-	fdt_fixup_memory_banks(blob, base, size, 2);
-
-#ifdef CONFIG_FSL_MC_ENET
-	fdt_fixup_board_enet(blob);
-	err = fsl_mc_ldpaa_exit(bd);
-	if (err)
-		return err;
-#endif
-
-	return 0;
-}
-#endif
-
-void qixis_dump_switch(void)
-{
-	int i, nr_of_cfgsw;
-
-	QIXIS_WRITE(cms[0], 0x00);
-	nr_of_cfgsw = QIXIS_READ(cms[1]);
-
-	puts("DIP switch settings dump:\n");
-	for (i = 1; i <= nr_of_cfgsw; i++) {
-		QIXIS_WRITE(cms[0], i);
-		printf("SW%d = (0x%02x)\n", i, QIXIS_READ(cms[1]));
-	}
-}
diff --git a/board/freescale/ls2085aqds/ls2085aqds_qixis.h b/board/freescale/ls2085aqds/ls2085aqds_qixis.h
deleted file mode 100644
index e281e5f..0000000
--- a/board/freescale/ls2085aqds/ls2085aqds_qixis.h
+++ /dev/null
@@ -1,30 +0,0 @@
-/*
- * Copyright 2015 Freescale Semiconductor, Inc.
- *
- * SPDX-License-Identifier:	GPL-2.0+
- */
-
-#ifndef __LS2_QDS_QIXIS_H__
-#define __LS2_QDS_QIXIS_H__
-
-/* SYSCLK */
-#define QIXIS_SYSCLK_66			0x0
-#define QIXIS_SYSCLK_83			0x1
-#define QIXIS_SYSCLK_100		0x2
-#define QIXIS_SYSCLK_125		0x3
-#define QIXIS_SYSCLK_133		0x4
-#define QIXIS_SYSCLK_150		0x5
-#define QIXIS_SYSCLK_160		0x6
-#define QIXIS_SYSCLK_166		0x7
-
-/* DDRCLK */
-#define QIXIS_DDRCLK_66			0x0
-#define QIXIS_DDRCLK_100		0x1
-#define QIXIS_DDRCLK_125		0x2
-#define QIXIS_DDRCLK_133		0x3
-
-#define BRDCFG4_EMISEL_MASK		0xE0
-#define BRDCFG4_EMISEL_SHIFT		5
-#define BRDCFG9_SFPTX_MASK		0x10
-#define BRDCFG9_SFPTX_SHIFT		4
-#endif /*__LS2_QDS_QIXIS_H__*/
diff --git a/board/freescale/ls2085ardb/Kconfig b/board/freescale/ls2085ardb/Kconfig
deleted file mode 100644
index cb40db9..0000000
--- a/board/freescale/ls2085ardb/Kconfig
+++ /dev/null
@@ -1,16 +0,0 @@
-
-if TARGET_LS2085ARDB
-
-config SYS_BOARD
-	default "ls2085ardb"
-
-config SYS_VENDOR
-	default "freescale"
-
-config SYS_SOC
-	default "fsl-layerscape"
-
-config SYS_CONFIG_NAME
-	default "ls2085ardb"
-
-endif
diff --git a/board/freescale/ls2085ardb/MAINTAINERS b/board/freescale/ls2085ardb/MAINTAINERS
deleted file mode 100644
index d5cce40..0000000
--- a/board/freescale/ls2085ardb/MAINTAINERS
+++ /dev/null
@@ -1,8 +0,0 @@
-LS2085A BOARD
-M:	Prabhakar Kushwaha <prabhakar@freescale.com>
-S:	Maintained
-F:	board/freescale/ls2085ardb/
-F:	board/freescale/ls2085a/ls2085ardb.c
-F:	include/configs/ls2085ardb.h
-F:	configs/ls2085ardb_defconfig
-F:	configs/ls2085ardb_nand_defconfig
diff --git a/board/freescale/ls2085ardb/Makefile b/board/freescale/ls2085ardb/Makefile
deleted file mode 100644
index de383cc..0000000
--- a/board/freescale/ls2085ardb/Makefile
+++ /dev/null
@@ -1,8 +0,0 @@
-#
-# Copyright 2015 Freescale Semiconductor
-#
-# SPDX-License-Identifier:	GPL-2.0+
-#
-
-obj-y += ls2085ardb.o eth_ls2085rdb.o
-obj-y += ddr.o
diff --git a/board/freescale/ls2085ardb/README b/board/freescale/ls2085ardb/README
deleted file mode 100644
index 2f18243..0000000
--- a/board/freescale/ls2085ardb/README
+++ /dev/null
@@ -1,120 +0,0 @@
-Overview
---------
-The LS2085A Reference Design (RDB) is a high-performance computing,
-evaluation, and development platform that supports the QorIQ LS2085A
-Layerscape Architecture processor.
-
-LS2085A SoC Overview
-------------------
-The LS2085A integrated multicore processor combines eight ARM Cortex-A57
-processor cores with high-performance data path acceleration logic and network
-and peripheral bus interfaces required for networking, telecom/datacom,
-wireless infrastructure, and mil/aerospace applications.
-
-The LS2085A SoC includes the following function and features:
-
- - Eight 64-bit ARM Cortex-A57 CPUs
- - 1 MB platform cache with ECC
- - Two 64-bit DDR4 SDRAM memory controllers with ECC and interleaving support
- - One secondary 32-bit DDR4 SDRAM memory controller, intended for use by
-  the AIOP
- - Data path acceleration architecture (DPAA2) incorporating acceleration for
- the following functions:
-   - Packet parsing, classification, and distribution (WRIOP)
-   - Queue and Hardware buffer management for scheduling, packet sequencing, and
-     congestion management, buffer allocation and de-allocation (QBMan)
-   - Cryptography acceleration (SEC) at up to 10 Gbps
-   - RegEx pattern matching acceleration (PME) at up to 10 Gbps
-   - Decompression/compression acceleration (DCE) at up to 20 Gbps
-   - Accelerated I/O processing (AIOP) at up to 20 Gbps
-   - QDMA engine
- - 16 SerDes lanes at up to 10.3125 GHz
- - Ethernet interfaces
-   - Up to eight 10 Gbps Ethernet MACs
-   - Up to eight 1 / 2.5 Gbps Ethernet MACs
- - High-speed peripheral interfaces
-   - Four PCIe 3.0 controllers, one supporting SR-IOV
- - Additional peripheral interfaces
-   - Two serial ATA (SATA 3.0) controllers
-   - Two high-speed USB 3.0 controllers with integrated PHY
-   - Enhanced secure digital host controller (eSDXC/eMMC)
-   - Serial peripheral interface (SPI) controller
-   - Quad Serial Peripheral Interface (QSPI) Controller
-   - Four I2C controllers
-   - Two DUARTs
-   - Integrated flash controller (IFC 2.0) supporting NAND and NOR flash
- - Support for hardware virtualization and partitioning enforcement
- - QorIQ platform's trust architecture 3.0
- - Service processor (SP) provides pre-boot initialization and secure-boot
-  capabilities
-
- LS2085ARDB board Overview
- -----------------------
- - SERDES Connections, 16 lanes supporting:
-      - PCI Express - 3.0
-      - SATA 3.0
-      - XFI
- - DDR Controller
-     - Two ports of 72-bits (8-bits ECC) DDR4. Each port supports four
-       chip-selects and two DIMM connectors. Support is up to 2133MT/s.
-     - One port of 40-bits (8-bits ECC) DDR4 which supports four chip-selects
-       and two DIMM connectors. Support is up to 1600MT/s.
- -IFC/Local Bus
-    - IFC rev. 2.0 implementation supporting Little Endian connection scheme.
-    - 128 MB NOR flash 16-bit data bus
-    - One 2 GB NAND flash with ECC support
-    - CPLD connection
- - USB 3.0
-    - Two high speed USB 3.0 ports
-    - First USB 3.0 port configured as Host with Type-A connector
-    - Second USB 3.0 port configured as OTG with micro-AB connector
- - SDHC adapter
-    - SD Card Rev 2.0 and Rev 3.0
- - DSPI
-    - 128 MB high-speed flash Memory for boot code and storage (up to 108MHz)
- - 4 I2C controllers
- - Two SATA onboard connectors
- - UART
- - ARM JTAG support
-
-Memory map from core's view
-----------------------------
-0x00_0000_0000 .. 0x00_000F_FFFF	Boot Rom
-0x00_0100_0000 .. 0x00_0FFF_FFFF	CCSR
-0x00_1800_0000 .. 0x00_181F_FFFF	OCRAM
-0x00_3000_0000 .. 0x00_3FFF_FFFF	IFC region #1
-0x00_8000_0000 .. 0x00_FFFF_FFFF	DDR region #1
-0x05_1000_0000 .. 0x05_FFFF_FFFF	IFC region #2
-0x80_8000_0000 .. 0xFF_FFFF_FFFF	DDR region #2
-
-Other addresses are either reserved, or not used directly by u-boot.
-This list should be updated when more addresses are used.
-
-IFC region map from core's view
--------------------------------
-During boot i.e. IFC Region #1:-
-  0x30000000 - 0x37ffffff : 128MB : NOR flash
-  0x3C000000 - 0x40000000 : 64MB  : CPLD
-
-After relocate to DDR i.e. IFC Region #2:-
-  0x5_1000_0000..0x5_1fff_ffff	Memory Hole
-  0x5_2000_0000..0x5_3fff_ffff	IFC CSx (CPLD, NAND and others 512MB)
-  0x5_4000_0000..0x5_7fff_ffff	ASIC or others 1GB
-  0x5_8000_0000..0x5_bfff_ffff	IFC CS0 1GB (NOR/Promjet)
-  0x5_C000_0000..0x5_ffff_ffff	IFC CS1 1GB (NOR/Promjet)
-
-Booting Options
----------------
-a) NOR boot
-b) NAND boot
-
-Booting Linux flavors which do not support 48-bit VA (< Linux 3.18)
--------------------------------------------------------------------
-One needs to use appropriate bootargs to boot Linux flavors which do
-not support 48-bit VA (for e.g. < Linux 3.18) by appending mem=2048M, as shown
-below:
-
-=> setenv bootargs 'console=ttyS1,115200 root=/dev/ram
-   earlycon=uart8250,mmio,0x21c0600,115200 default_hugepagesz=2m hugepagesz=2m
-   hugepages=16 mem=2048M'
-
diff --git a/board/freescale/ls2085ardb/ddr.c b/board/freescale/ls2085ardb/ddr.c
deleted file mode 100644
index 8d71ae1..0000000
--- a/board/freescale/ls2085ardb/ddr.c
+++ /dev/null
@@ -1,196 +0,0 @@
-/*
- * Copyright 2015 Freescale Semiconductor, Inc.
- *
- * SPDX-License-Identifier:	GPL-2.0+
- */
-
-#include <common.h>
-#include <fsl_ddr_sdram.h>
-#include <fsl_ddr_dimm_params.h>
-#include "ddr.h"
-
-DECLARE_GLOBAL_DATA_PTR;
-
-void fsl_ddr_board_options(memctl_options_t *popts,
-				dimm_params_t *pdimm,
-				unsigned int ctrl_num)
-{
-	u8 dq_mapping_0, dq_mapping_2, dq_mapping_3;
-	const struct board_specific_parameters *pbsp, *pbsp_highest = NULL;
-	ulong ddr_freq;
-	int slot;
-
-	if (ctrl_num > 2) {
-		printf("Not supported controller number %d\n", ctrl_num);
-		return;
-	}
-
-	for (slot = 0; slot < CONFIG_DIMM_SLOTS_PER_CTLR; slot++) {
-		if (pdimm[slot].n_ranks)
-			break;
-	}
-
-	if (slot >= CONFIG_DIMM_SLOTS_PER_CTLR)
-		return;
-
-	/*
-	 * we use identical timing for all slots. If needed, change the code
-	 * to  pbsp = rdimms[ctrl_num] or pbsp = udimms[ctrl_num];
-	 */
-	if (popts->registered_dimm_en)
-		pbsp = rdimms[ctrl_num];
-	else
-		pbsp = udimms[ctrl_num];
-
-
-	/* Get clk_adjust, wrlvl_start, wrlvl_ctl, according to the board ddr
-	 * freqency and n_banks specified in board_specific_parameters table.
-	 */
-	ddr_freq = get_ddr_freq(ctrl_num) / 1000000;
-	while (pbsp->datarate_mhz_high) {
-		if (pbsp->n_ranks == pdimm[slot].n_ranks &&
-		    (pdimm[slot].rank_density >> 30) >= pbsp->rank_gb) {
-			if (ddr_freq <= pbsp->datarate_mhz_high) {
-				popts->clk_adjust = pbsp->clk_adjust;
-				popts->wrlvl_start = pbsp->wrlvl_start;
-				popts->wrlvl_ctl_2 = pbsp->wrlvl_ctl_2;
-				popts->wrlvl_ctl_3 = pbsp->wrlvl_ctl_3;
-				goto found;
-			}
-			pbsp_highest = pbsp;
-		}
-		pbsp++;
-	}
-
-	if (pbsp_highest) {
-		printf("Error: board specific timing not found for data rate %lu MT/s\n"
-			"Trying to use the highest speed (%u) parameters\n",
-			ddr_freq, pbsp_highest->datarate_mhz_high);
-		popts->clk_adjust = pbsp_highest->clk_adjust;
-		popts->wrlvl_start = pbsp_highest->wrlvl_start;
-		popts->wrlvl_ctl_2 = pbsp->wrlvl_ctl_2;
-		popts->wrlvl_ctl_3 = pbsp->wrlvl_ctl_3;
-	} else {
-		panic("DIMM is not supported by this board");
-	}
-found:
-	debug("Found timing match: n_ranks %d, data rate %d, rank_gb %d\n"
-		"\tclk_adjust %d, wrlvl_start %d, wrlvl_ctrl_2 0x%x, wrlvl_ctrl_3 0x%x\n",
-		pbsp->n_ranks, pbsp->datarate_mhz_high, pbsp->rank_gb,
-		pbsp->clk_adjust, pbsp->wrlvl_start, pbsp->wrlvl_ctl_2,
-		pbsp->wrlvl_ctl_3);
-
-	if (ctrl_num == CONFIG_DP_DDR_CTRL) {
-		/* force DDR bus width to 32 bits */
-		popts->data_bus_width = 1;
-		popts->otf_burst_chop_en = 0;
-		popts->burst_length = DDR_BL8;
-		popts->bstopre = 0;	/* enable auto precharge */
-		/*
-		 * Layout optimization results byte mapping
-		 * Byte 0 -> Byte ECC
-		 * Byte 1 -> Byte 3
-		 * Byte 2 -> Byte 2
-		 * Byte 3 -> Byte 1
-		 * Byte ECC -> Byte 0
-		 */
-		dq_mapping_0 = pdimm[slot].dq_mapping[0];
-		dq_mapping_2 = pdimm[slot].dq_mapping[2];
-		dq_mapping_3 = pdimm[slot].dq_mapping[3];
-		pdimm[slot].dq_mapping[0] = pdimm[slot].dq_mapping[8];
-		pdimm[slot].dq_mapping[1] = pdimm[slot].dq_mapping[9];
-		pdimm[slot].dq_mapping[2] = pdimm[slot].dq_mapping[6];
-		pdimm[slot].dq_mapping[3] = pdimm[slot].dq_mapping[7];
-		pdimm[slot].dq_mapping[6] = dq_mapping_2;
-		pdimm[slot].dq_mapping[7] = dq_mapping_3;
-		pdimm[slot].dq_mapping[8] = dq_mapping_0;
-		pdimm[slot].dq_mapping[9] = 0;
-		pdimm[slot].dq_mapping[10] = 0;
-		pdimm[slot].dq_mapping[11] = 0;
-		pdimm[slot].dq_mapping[12] = 0;
-		pdimm[slot].dq_mapping[13] = 0;
-		pdimm[slot].dq_mapping[14] = 0;
-		pdimm[slot].dq_mapping[15] = 0;
-		pdimm[slot].dq_mapping[16] = 0;
-		pdimm[slot].dq_mapping[17] = 0;
-	}
-	/* To work at higher than 1333MT/s */
-	popts->half_strength_driver_enable = 0;
-	/*
-	 * Write leveling override
-	 */
-	popts->wrlvl_override = 1;
-	popts->wrlvl_sample = 0x0;	/* 32 clocks */
-
-	/*
-	 * Rtt and Rtt_WR override
-	 */
-	popts->rtt_override = 0;
-
-	/* Enable ZQ calibration */
-	popts->zq_en = 1;
-
-	if (ddr_freq < 2350) {
-		popts->ddr_cdr1 = DDR_CDR1_DHC_EN |
-				  DDR_CDR1_ODT(DDR_CDR_ODT_60ohm);
-		popts->ddr_cdr2 = DDR_CDR2_ODT(DDR_CDR_ODT_60ohm) |
-				  DDR_CDR2_VREF_RANGE_2;
-	} else {
-		popts->ddr_cdr1 = DDR_CDR1_DHC_EN |
-				  DDR_CDR1_ODT(DDR_CDR_ODT_100ohm);
-		popts->ddr_cdr2 = DDR_CDR2_ODT(DDR_CDR_ODT_100ohm) |
-				  DDR_CDR2_VREF_RANGE_2;
-	}
-}
-
-phys_size_t initdram(int board_type)
-{
-	phys_size_t dram_size;
-
-#if defined(CONFIG_SPL) && !defined(CONFIG_SPL_BUILD)
-	return fsl_ddr_sdram_size();
-#else
-	puts("Initializing DDR....using SPD\n");
-
-	dram_size = fsl_ddr_sdram();
-#endif
-
-	return dram_size;
-}
-
-void dram_init_banksize(void)
-{
-#ifdef CONFIG_SYS_DP_DDR_BASE_PHY
-	phys_size_t dp_ddr_size;
-#endif
-
-	gd->bd->bi_dram[0].start = CONFIG_SYS_SDRAM_BASE;
-	if (gd->ram_size > CONFIG_SYS_LS2_DDR_BLOCK1_SIZE) {
-		gd->bd->bi_dram[0].size = CONFIG_SYS_LS2_DDR_BLOCK1_SIZE;
-		gd->bd->bi_dram[1].start = CONFIG_SYS_DDR_BLOCK2_BASE;
-		gd->bd->bi_dram[1].size = gd->ram_size -
-					  CONFIG_SYS_LS2_DDR_BLOCK1_SIZE;
-	} else {
-		gd->bd->bi_dram[0].size = gd->ram_size;
-	}
-
-#ifdef CONFIG_SYS_DP_DDR_BASE_PHY
-	/* initialize DP-DDR here */
-	puts("DP-DDR:  ");
-	/*
-	 * DDR controller use 0 as the base address for binding.
-	 * It is mapped to CONFIG_SYS_DP_DDR_BASE for core to access.
-	 */
-	dp_ddr_size = fsl_other_ddr_sdram(CONFIG_SYS_DP_DDR_BASE_PHY,
-					  CONFIG_DP_DDR_CTRL,
-					  CONFIG_DP_DDR_NUM_CTRLS,
-					  CONFIG_DP_DDR_DIMM_SLOTS_PER_CTLR,
-					  NULL, NULL, NULL);
-	if (dp_ddr_size) {
-		gd->bd->bi_dram[2].start = CONFIG_SYS_DP_DDR_BASE;
-		gd->bd->bi_dram[2].size = dp_ddr_size;
-	} else {
-		puts("Not detected");
-	}
-#endif
-}
diff --git a/board/freescale/ls2085ardb/ddr.h b/board/freescale/ls2085ardb/ddr.h
deleted file mode 100644
index bda9d4a..0000000
--- a/board/freescale/ls2085ardb/ddr.h
+++ /dev/null
@@ -1,92 +0,0 @@
-/*
- * Copyright 2015 Freescale Semiconductor, Inc.
- *
- * SPDX-License-Identifier:	GPL-2.0+
- */
-
-#ifndef __DDR_H__
-#define __DDR_H__
-struct board_specific_parameters {
-	u32 n_ranks;
-	u32 datarate_mhz_high;
-	u32 rank_gb;
-	u32 clk_adjust;
-	u32 wrlvl_start;
-	u32 wrlvl_ctl_2;
-	u32 wrlvl_ctl_3;
-};
-
-/*
- * These tables contain all valid speeds we want to override with board
- * specific parameters. datarate_mhz_high values need to be in ascending order
- * for each n_ranks group.
- */
-
-static const struct board_specific_parameters udimm0[] = {
-	/*
-	 * memory controller 0
-	 *   num|  hi| rank|  clk| wrlvl |   wrlvl   |  wrlvl
-	 * ranks| mhz| GB  |adjst| start |   ctl2    |  ctl3
-	 */
-	{2,  1350, 0, 4,     6, 0x0708090B, 0x0C0D0E09,},
-	{2,  1666, 0, 4,     8, 0x08090B0D, 0x0E10100C,},
-	{2,  1900, 0, 4,     8, 0x090A0C0E, 0x1012120D,},
-	{2,  2300, 0, 4,     9, 0x0A0B0C10, 0x1114140E,},
-	{}
-};
-
-/* DP-DDR DIMM */
-static const struct board_specific_parameters udimm2[] = {
-	/*
-	 * memory controller 2
-	 *   num|  hi| rank|  clk| wrlvl |   wrlvl   |  wrlvl
-	 * ranks| mhz| GB  |adjst| start |   ctl2    |  ctl3
-	 */
-	{2,  1350, 0, 4,   0xd, 0x0C0A0A00, 0x00000009,},
-	{2,  1666, 0, 4,   0xd, 0x0C0A0A00, 0x00000009,},
-	{2,  1900, 0, 4,   0xe, 0x0D0C0B00, 0x0000000A,},
-	{2,  2200, 0, 4,   0xe, 0x0D0C0B00, 0x0000000A,},
-	{}
-};
-
-static const struct board_specific_parameters rdimm0[] = {
-	/*
-	 * memory controller 0
-	 *   num|  hi| rank|  clk| wrlvl |   wrlvl   |  wrlvl
-	 * ranks| mhz| GB  |adjst| start |   ctl2    |  ctl3
-	 */
-	{2,  1350, 0, 4,     6, 0x0708090B, 0x0C0D0E09,},
-	{2,  1666, 0, 4,     7, 0x08090A0C, 0x0D0F100B,},
-	{2,  1900, 0, 4,     7, 0x09090B0D, 0x0E10120B,},
-	{2,  2200, 0, 4,     8, 0x090A0C0F, 0x1012130C,},
-	{}
-};
-
-/* DP-DDR DIMM */
-static const struct board_specific_parameters rdimm2[] = {
-	/*
-	 * memory controller 2
-	 *   num|  hi| rank|  clk| wrlvl |   wrlvl   |  wrlvl
-	 * ranks| mhz| GB  |adjst| start |   ctl2    |  ctl3
-	 */
-	{2,  1350, 0, 4,     6, 0x0708090B, 0x0C0D0E09,},
-	{2,  1666, 0, 4,     7, 0x0B0A090C, 0x0D0F100B,},
-	{2,  1900, 0, 4,     7, 0x09090B0D, 0x0E10120B,},
-	{2,  2200, 0, 4,     8, 0x090A0C0F, 0x1012130C,},
-	{}
-};
-
-static const struct board_specific_parameters *udimms[] = {
-	udimm0,
-	udimm0,
-	udimm2,
-};
-
-static const struct board_specific_parameters *rdimms[] = {
-	rdimm0,
-	rdimm0,
-	rdimm2,
-};
-
-
-#endif
diff --git a/board/freescale/ls2085ardb/eth_ls2085rdb.c b/board/freescale/ls2085ardb/eth_ls2085rdb.c
deleted file mode 100644
index d578757..0000000
--- a/board/freescale/ls2085ardb/eth_ls2085rdb.c
+++ /dev/null
@@ -1,147 +0,0 @@
-/*
- * Copyright 2015 Freescale Semiconductor, Inc.
- *
- *
- * SPDX-License-Identifier:     GPL-2.0+
- */
-
-#include <common.h>
-#include <command.h>
-#include <netdev.h>
-#include <malloc.h>
-#include <fsl_mdio.h>
-#include <miiphy.h>
-#include <phy.h>
-#include <fm_eth.h>
-#include <asm/io.h>
-#include <exports.h>
-#include <asm/arch/fsl_serdes.h>
-#include <fsl-mc/ldpaa_wriop.h>
-
-DECLARE_GLOBAL_DATA_PTR;
-
-int load_firmware_cortina(struct phy_device *phy_dev)
-{
-	if (phy_dev->drv->config)
-		return phy_dev->drv->config(phy_dev);
-
-	return 0;
-}
-
-void load_phy_firmware(void)
-{
-	int i;
-	u8 phy_addr;
-	struct phy_device *phy_dev;
-	struct mii_dev *dev;
-	phy_interface_t interface;
-
-	/*Initialize and upload firmware for all the PHYs*/
-	for (i = WRIOP1_DPMAC1; i <= WRIOP1_DPMAC8; i++) {
-		interface = wriop_get_enet_if(i);
-		if (interface == PHY_INTERFACE_MODE_XGMII) {
-			dev = wriop_get_mdio(i);
-			phy_addr = wriop_get_phy_address(i);
-			phy_dev = phy_find_by_mask(dev, 1 << phy_addr,
-						interface);
-			if (!phy_dev) {
-				printf("No phydev for phyaddr %d\n", phy_addr);
-				continue;
-			}
-
-			/*Flash firmware for All CS4340 PHYS */
-			if (phy_dev->phy_id == PHY_UID_CS4340)
-				load_firmware_cortina(phy_dev);
-		}
-	}
-}
-
-int board_eth_init(bd_t *bis)
-{
-#if defined(CONFIG_FSL_MC_ENET)
-	int i, interface;
-	struct memac_mdio_info mdio_info;
-	struct mii_dev *dev;
-	struct ccsr_gur *gur = (void *)(CONFIG_SYS_FSL_GUTS_ADDR);
-	u32 srds_s1;
-	struct memac_mdio_controller *reg;
-
-	srds_s1 = in_le32(&gur->rcwsr[28]) &
-				FSL_CHASSIS3_RCWSR28_SRDS1_PRTCL_MASK;
-	srds_s1 >>= FSL_CHASSIS3_RCWSR28_SRDS1_PRTCL_SHIFT;
-
-	reg = (struct memac_mdio_controller *)CONFIG_SYS_FSL_WRIOP1_MDIO1;
-	mdio_info.regs = reg;
-	mdio_info.name = DEFAULT_WRIOP_MDIO1_NAME;
-
-	/* Register the EMI 1 */
-	fm_memac_mdio_init(bis, &mdio_info);
-
-	reg = (struct memac_mdio_controller *)CONFIG_SYS_FSL_WRIOP1_MDIO2;
-	mdio_info.regs = reg;
-	mdio_info.name = DEFAULT_WRIOP_MDIO2_NAME;
-
-	/* Register the EMI 2 */
-	fm_memac_mdio_init(bis, &mdio_info);
-
-	switch (srds_s1) {
-	case 0x2A:
-		wriop_set_phy_address(WRIOP1_DPMAC1, CORTINA_PHY_ADDR1);
-		wriop_set_phy_address(WRIOP1_DPMAC2, CORTINA_PHY_ADDR2);
-		wriop_set_phy_address(WRIOP1_DPMAC3, CORTINA_PHY_ADDR3);
-		wriop_set_phy_address(WRIOP1_DPMAC4, CORTINA_PHY_ADDR4);
-		wriop_set_phy_address(WRIOP1_DPMAC5, AQ_PHY_ADDR1);
-		wriop_set_phy_address(WRIOP1_DPMAC6, AQ_PHY_ADDR2);
-		wriop_set_phy_address(WRIOP1_DPMAC7, AQ_PHY_ADDR3);
-		wriop_set_phy_address(WRIOP1_DPMAC8, AQ_PHY_ADDR4);
-
-		break;
-	default:
-		printf("SerDes1 protocol 0x%x is not supported on LS2085aRDB\n",
-		       srds_s1);
-		break;
-	}
-
-	for (i = WRIOP1_DPMAC1; i <= WRIOP1_DPMAC4; i++) {
-		interface = wriop_get_enet_if(i);
-		switch (interface) {
-		case PHY_INTERFACE_MODE_XGMII:
-			dev = miiphy_get_dev_by_name(DEFAULT_WRIOP_MDIO1_NAME);
-			wriop_set_mdio(i, dev);
-			break;
-		default:
-			break;
-		}
-	}
-
-	for (i = WRIOP1_DPMAC5; i <= WRIOP1_DPMAC8; i++) {
-		switch (wriop_get_enet_if(i)) {
-		case PHY_INTERFACE_MODE_XGMII:
-			dev = miiphy_get_dev_by_name(DEFAULT_WRIOP_MDIO2_NAME);
-			wriop_set_mdio(i, dev);
-			break;
-		default:
-			break;
-		}
-	}
-
-	/* Load CORTINA CS4340 PHY firmware */
-	load_phy_firmware();
-
-	cpu_eth_init(bis);
-#endif /* CONFIG_FMAN_ENET */
-
-#ifdef CONFIG_PHY_AQUANTIA
-	/*
-	 * Export functions to be used by AQ firmware
-	 * upload application
-	 */
-	gd->jt->strcpy = strcpy;
-	gd->jt->mdelay = mdelay;
-	gd->jt->mdio_get_current_dev = mdio_get_current_dev;
-	gd->jt->phy_find_by_mask = phy_find_by_mask;
-	gd->jt->mdio_phydev_for_ethname = mdio_phydev_for_ethname;
-	gd->jt->miiphy_set_current_dev = miiphy_set_current_dev;
-#endif
-	return pci_eth_init(bis);
-}
diff --git a/board/freescale/ls2085ardb/ls2085ardb.c b/board/freescale/ls2085ardb/ls2085ardb.c
deleted file mode 100644
index 761d7c8..0000000
--- a/board/freescale/ls2085ardb/ls2085ardb.c
+++ /dev/null
@@ -1,319 +0,0 @@
-/*
- * Copyright 2015 Freescale Semiconductor
- *
- * SPDX-License-Identifier:	GPL-2.0+
- */
-#include <common.h>
-#include <malloc.h>
-#include <errno.h>
-#include <netdev.h>
-#include <fsl_ifc.h>
-#include <fsl_ddr.h>
-#include <asm/io.h>
-#include <hwconfig.h>
-#include <fdt_support.h>
-#include <libfdt.h>
-#include <fsl_debug_server.h>
-#include <fsl-mc/fsl_mc.h>
-#include <environment.h>
-#include <i2c.h>
-#include <asm/arch/soc.h>
-
-#include "../common/qixis.h"
-#include "ls2085ardb_qixis.h"
-
-#define PIN_MUX_SEL_SDHC	0x00
-#define PIN_MUX_SEL_DSPI	0x0a
-
-#define SET_SDHC_MUX_SEL(reg, value)	((reg & 0xf0) | value)
-DECLARE_GLOBAL_DATA_PTR;
-
-enum {
-	MUX_TYPE_SDHC,
-	MUX_TYPE_DSPI,
-};
-
-unsigned long long get_qixis_addr(void)
-{
-	unsigned long long addr;
-
-	if (gd->flags & GD_FLG_RELOC)
-		addr = QIXIS_BASE_PHYS;
-	else
-		addr = QIXIS_BASE_PHYS_EARLY;
-
-	/*
-	 * IFC address under 256MB is mapped to 0x30000000, any address above
-	 * is mapped to 0x5_10000000 up to 4GB.
-	 */
-	addr = addr  > 0x10000000 ? addr + 0x500000000ULL : addr + 0x30000000;
-
-	return addr;
-}
-
-int checkboard(void)
-{
-	u8 sw;
-	char buf[15];
-
-	cpu_name(buf);
-	printf("Board: %s-RDB, ", buf);
-
-	sw = QIXIS_READ(arch);
-	printf("Board Arch: V%d, ", sw >> 4);
-	printf("Board version: %c, boot from ", (sw & 0xf) + 'A');
-
-	sw = QIXIS_READ(brdcfg[0]);
-	sw = (sw & QIXIS_LBMAP_MASK) >> QIXIS_LBMAP_SHIFT;
-
-	if (sw < 0x8)
-		printf("vBank: %d\n", sw);
-	else if (sw == 0x9)
-		puts("NAND\n");
-	else
-		printf("invalid setting of SW%u\n", QIXIS_LBMAP_SWITCH);
-
-	printf("FPGA: v%d.%d\n", QIXIS_READ(scver), QIXIS_READ(tagdata));
-
-	puts("SERDES1 Reference : ");
-	printf("Clock1 = 156.25MHz ");
-	printf("Clock2 = 156.25MHz");
-
-	puts("\nSERDES2 Reference : ");
-	printf("Clock1 = 100MHz ");
-	printf("Clock2 = 100MHz\n");
-
-	return 0;
-}
-
-unsigned long get_board_sys_clk(void)
-{
-	u8 sysclk_conf = QIXIS_READ(brdcfg[1]);
-
-	switch (sysclk_conf & 0x0F) {
-	case QIXIS_SYSCLK_83:
-		return 83333333;
-	case QIXIS_SYSCLK_100:
-		return 100000000;
-	case QIXIS_SYSCLK_125:
-		return 125000000;
-	case QIXIS_SYSCLK_133:
-		return 133333333;
-	case QIXIS_SYSCLK_150:
-		return 150000000;
-	case QIXIS_SYSCLK_160:
-		return 160000000;
-	case QIXIS_SYSCLK_166:
-		return 166666666;
-	}
-	return 66666666;
-}
-
-int select_i2c_ch_pca9547(u8 ch)
-{
-	int ret;
-
-	ret = i2c_write(I2C_MUX_PCA_ADDR_PRI, 0, 1, &ch, 1);
-	if (ret) {
-		puts("PCA: failed to select proper channel\n");
-		return ret;
-	}
-
-	return 0;
-}
-
-int config_board_mux(int ctrl_type)
-{
-	u8 reg5;
-
-	reg5 = QIXIS_READ(brdcfg[5]);
-
-	switch (ctrl_type) {
-	case MUX_TYPE_SDHC:
-		reg5 = SET_SDHC_MUX_SEL(reg5, PIN_MUX_SEL_SDHC);
-		break;
-	case MUX_TYPE_DSPI:
-		reg5 = SET_SDHC_MUX_SEL(reg5, PIN_MUX_SEL_DSPI);
-		break;
-	default:
-		printf("Wrong mux interface type\n");
-		return -1;
-	}
-
-	QIXIS_WRITE(brdcfg[5], reg5);
-
-	return 0;
-}
-
-int board_init(void)
-{
-	char *env_hwconfig;
-	u32 __iomem *dcfg_ccsr = (u32 __iomem *)DCFG_BASE;
-	u32 val;
-
-	init_final_memctl_regs();
-
-	val = in_le32(dcfg_ccsr + DCFG_RCWSR13 / 4);
-
-	env_hwconfig = getenv("hwconfig");
-
-	if (hwconfig_f("dspi", env_hwconfig) &&
-	    DCFG_RCWSR13_DSPI == (val & (u32)(0xf << 8)))
-		config_board_mux(MUX_TYPE_DSPI);
-	else
-		config_board_mux(MUX_TYPE_SDHC);
-
-#ifdef CONFIG_ENV_IS_NOWHERE
-	gd->env_addr = (ulong)&default_environment[0];
-#endif
-	select_i2c_ch_pca9547(I2C_MUX_CH_DEFAULT);
-
-	QIXIS_WRITE(rst_ctl, QIXIS_RST_CTL_RESET_EN);
-
-	return 0;
-}
-
-int board_early_init_f(void)
-{
-	fsl_lsch3_early_init_f();
-	return 0;
-}
-
-int misc_init_r(void)
-{
-	if (hwconfig("sdhc"))
-		config_board_mux(MUX_TYPE_SDHC);
-
-	return 0;
-}
-
-void detail_board_ddr_info(void)
-{
-	puts("\nDDR    ");
-	print_size(gd->bd->bi_dram[0].size + gd->bd->bi_dram[1].size, "");
-	print_ddr_info(0);
-	if (gd->bd->bi_dram[2].size) {
-		puts("\nDP-DDR ");
-		print_size(gd->bd->bi_dram[2].size, "");
-		print_ddr_info(CONFIG_DP_DDR_CTRL);
-	}
-}
-
-int dram_init(void)
-{
-	gd->ram_size = initdram(0);
-
-	return 0;
-}
-
-#if defined(CONFIG_ARCH_MISC_INIT)
-int arch_misc_init(void)
-{
-#ifdef CONFIG_FSL_DEBUG_SERVER
-	debug_server_init();
-#endif
-
-	return 0;
-}
-#endif
-
-unsigned long get_dram_size_to_hide(void)
-{
-	unsigned long dram_to_hide = 0;
-
-/* Carve the Debug Server private DRAM block from the end of DRAM */
-#ifdef CONFIG_FSL_DEBUG_SERVER
-	dram_to_hide += debug_server_get_dram_block_size();
-#endif
-
-/* Carve the MC private DRAM block from the end of DRAM */
-#ifdef CONFIG_FSL_MC_ENET
-	dram_to_hide += mc_get_dram_block_size();
-#endif
-
-	return roundup(dram_to_hide, CONFIG_SYS_MEM_TOP_HIDE_MIN);
-}
-
-#ifdef CONFIG_FSL_MC_ENET
-void fdt_fixup_board_enet(void *fdt)
-{
-	int offset;
-
-	offset = fdt_path_offset(fdt, "/fsl-mc");
-
-	if (offset < 0)
-		offset = fdt_path_offset(fdt, "/fsl,dprc@0");
-
-	if (offset < 0) {
-		printf("%s: ERROR: fsl-mc node not found in device tree (error %d)\n",
-		       __func__, offset);
-		return;
-	}
-
-	if (get_mc_boot_status() == 0)
-		fdt_status_okay(fdt, offset);
-	else
-		fdt_status_fail(fdt, offset);
-}
-#endif
-
-#ifdef CONFIG_OF_BOARD_SETUP
-int ft_board_setup(void *blob, bd_t *bd)
-{
-	int err;
-	u64 base[CONFIG_NR_DRAM_BANKS];
-	u64 size[CONFIG_NR_DRAM_BANKS];
-
-	ft_cpu_setup(blob, bd);
-
-	/* fixup DT for the two GPP DDR banks */
-	base[0] = gd->bd->bi_dram[0].start;
-	size[0] = gd->bd->bi_dram[0].size;
-	base[1] = gd->bd->bi_dram[1].start;
-	size[1] = gd->bd->bi_dram[1].size;
-
-	fdt_fixup_memory_banks(blob, base, size, 2);
-
-#ifdef CONFIG_FSL_MC_ENET
-	fdt_fixup_board_enet(blob);
-	err = fsl_mc_ldpaa_exit(bd);
-	if (err)
-		return err;
-#endif
-
-	return 0;
-}
-#endif
-
-void qixis_dump_switch(void)
-{
-	int i, nr_of_cfgsw;
-
-	QIXIS_WRITE(cms[0], 0x00);
-	nr_of_cfgsw = QIXIS_READ(cms[1]);
-
-	puts("DIP switch settings dump:\n");
-	for (i = 1; i <= nr_of_cfgsw; i++) {
-		QIXIS_WRITE(cms[0], i);
-		printf("SW%d = (0x%02x)\n", i, QIXIS_READ(cms[1]));
-	}
-}
-
-/*
- * Board rev C and earlier has duplicated I2C addresses for 2nd controller.
- * Both slots has 0x54, resulting 2nd slot unusable.
- */
-void update_spd_address(unsigned int ctrl_num,
-			unsigned int slot,
-			unsigned int *addr)
-{
-	u8 sw;
-
-	sw = QIXIS_READ(arch);
-	if ((sw & 0xf) < 0x3) {
-		if (ctrl_num == 1 && slot == 0)
-			*addr = SPD_EEPROM_ADDRESS4;
-		else if (ctrl_num == 1 && slot == 1)
-			*addr = SPD_EEPROM_ADDRESS3;
-	}
-}
diff --git a/board/freescale/ls2085ardb/ls2085ardb_qixis.h b/board/freescale/ls2085ardb/ls2085ardb_qixis.h
deleted file mode 100644
index cb60c00..0000000
--- a/board/freescale/ls2085ardb/ls2085ardb_qixis.h
+++ /dev/null
@@ -1,20 +0,0 @@
-/*
- * Copyright 2015 Freescale Semiconductor, Inc.
- *
- * SPDX-License-Identifier:	GPL-2.0+
- */
-
-#ifndef __LS2_RDB_QIXIS_H__
-#define __LS2_RDB_QIXIS_H__
-
-/* SYSCLK */
-#define QIXIS_SYSCLK_66			0x0
-#define QIXIS_SYSCLK_83			0x1
-#define QIXIS_SYSCLK_100		0x2
-#define QIXIS_SYSCLK_125		0x3
-#define QIXIS_SYSCLK_133		0x4
-#define QIXIS_SYSCLK_150		0x5
-#define QIXIS_SYSCLK_160		0x6
-#define QIXIS_SYSCLK_166		0x7
-
-#endif /*__LS2_RDB_QIXIS_H__*/
diff --git a/configs/ls2080a_emu_defconfig b/configs/ls2080a_emu_defconfig
new file mode 100644
index 0000000..ebdde04
--- /dev/null
+++ b/configs/ls2080a_emu_defconfig
@@ -0,0 +1,14 @@
+CONFIG_ARM=y
+CONFIG_TARGET_LS2080A_EMU=y
+CONFIG_SYS_EXTRA_OPTIONS="EMU,SYS_FSL_DDR4"
+# CONFIG_CMD_CONSOLE is not set
+# CONFIG_CMD_IMLS is not set
+# CONFIG_CMD_XIMG is not set
+# CONFIG_CMD_EDITENV is not set
+# CONFIG_CMD_ENV_EXISTS is not set
+# CONFIG_CMD_LOADS is not set
+# CONFIG_CMD_FPGA is not set
+# CONFIG_CMD_ITEST is not set
+# CONFIG_CMD_SETEXPR is not set
+# CONFIG_CMD_NFS is not set
+# CONFIG_CMD_MISC is not set
diff --git a/configs/ls2080a_simu_defconfig b/configs/ls2080a_simu_defconfig
new file mode 100644
index 0000000..eb8000b
--- /dev/null
+++ b/configs/ls2080a_simu_defconfig
@@ -0,0 +1,15 @@
+CONFIG_ARM=y
+CONFIG_TARGET_LS2080A_SIMU=y
+CONFIG_SYS_EXTRA_OPTIONS="SIMU"
+# CONFIG_CMD_CONSOLE is not set
+# CONFIG_CMD_IMLS is not set
+# CONFIG_CMD_XIMG is not set
+# CONFIG_CMD_EDITENV is not set
+# CONFIG_CMD_ENV_EXISTS is not set
+# CONFIG_CMD_LOADS is not set
+# CONFIG_CMD_FPGA is not set
+# CONFIG_CMD_ITEST is not set
+# CONFIG_CMD_SETEXPR is not set
+# CONFIG_CMD_NFS is not set
+# CONFIG_CMD_MISC is not set
+CONFIG_NET_RANDOM_ETHADDR=y
diff --git a/configs/ls2080aqds_defconfig b/configs/ls2080aqds_defconfig
new file mode 100644
index 0000000..afba06b
--- /dev/null
+++ b/configs/ls2080aqds_defconfig
@@ -0,0 +1,14 @@
+CONFIG_ARM=y
+CONFIG_TARGET_LS2080AQDS=y
+# CONFIG_SYS_MALLOC_F is not set
+CONFIG_DM_SPI=y
+CONFIG_DM_SPI_FLASH=y
+CONFIG_DEFAULT_DEVICE_TREE="fsl-ls2080a-qds"
+CONFIG_SYS_EXTRA_OPTIONS="SYS_FSL_DDR4"
+# CONFIG_CMD_SETEXPR is not set
+CONFIG_OF_CONTROL=y
+CONFIG_NET_RANDOM_ETHADDR=y
+CONFIG_DM=y
+CONFIG_NETDEVICES=y
+CONFIG_E1000=y
+CONFIG_FSL_DSPI=y
diff --git a/configs/ls2080aqds_nand_defconfig b/configs/ls2080aqds_nand_defconfig
new file mode 100644
index 0000000..40cf883
--- /dev/null
+++ b/configs/ls2080aqds_nand_defconfig
@@ -0,0 +1,8 @@
+CONFIG_ARM=y
+CONFIG_TARGET_LS2080AQDS=y
+CONFIG_SPL=y
+CONFIG_SYS_EXTRA_OPTIONS="SYS_FSL_DDR4,NAND"
+# CONFIG_CMD_SETEXPR is not set
+CONFIG_NET_RANDOM_ETHADDR=y
+CONFIG_NETDEVICES=y
+CONFIG_E1000=y
diff --git a/configs/ls2080ardb_defconfig b/configs/ls2080ardb_defconfig
new file mode 100644
index 0000000..301cd7f
--- /dev/null
+++ b/configs/ls2080ardb_defconfig
@@ -0,0 +1,14 @@
+CONFIG_ARM=y
+CONFIG_TARGET_LS2080ARDB=y
+# CONFIG_SYS_MALLOC_F is not set
+CONFIG_DM_SPI=y
+CONFIG_DM_SPI_FLASH=y
+CONFIG_DEFAULT_DEVICE_TREE="fsl-ls2080a-rdb"
+CONFIG_SYS_EXTRA_OPTIONS="SYS_FSL_DDR4"
+# CONFIG_CMD_SETEXPR is not set
+CONFIG_OF_CONTROL=y
+CONFIG_NET_RANDOM_ETHADDR=y
+CONFIG_DM=y
+CONFIG_NETDEVICES=y
+CONFIG_E1000=y
+CONFIG_FSL_DSPI=y
diff --git a/configs/ls2080ardb_nand_defconfig b/configs/ls2080ardb_nand_defconfig
new file mode 100644
index 0000000..658c9ff
--- /dev/null
+++ b/configs/ls2080ardb_nand_defconfig
@@ -0,0 +1,8 @@
+CONFIG_ARM=y
+CONFIG_TARGET_LS2080ARDB=y
+CONFIG_SPL=y
+CONFIG_SYS_EXTRA_OPTIONS="SYS_FSL_DDR4,NAND"
+# CONFIG_CMD_SETEXPR is not set
+CONFIG_NET_RANDOM_ETHADDR=y
+CONFIG_NETDEVICES=y
+CONFIG_E1000=y
diff --git a/configs/ls2085a_emu_defconfig b/configs/ls2085a_emu_defconfig
deleted file mode 100644
index 9c82e17..0000000
--- a/configs/ls2085a_emu_defconfig
+++ /dev/null
@@ -1,14 +0,0 @@
-CONFIG_ARM=y
-CONFIG_TARGET_LS2085A_EMU=y
-CONFIG_SYS_EXTRA_OPTIONS="EMU,SYS_FSL_DDR4"
-# CONFIG_CMD_CONSOLE is not set
-# CONFIG_CMD_IMLS is not set
-# CONFIG_CMD_XIMG is not set
-# CONFIG_CMD_EDITENV is not set
-# CONFIG_CMD_ENV_EXISTS is not set
-# CONFIG_CMD_LOADS is not set
-# CONFIG_CMD_FPGA is not set
-# CONFIG_CMD_ITEST is not set
-# CONFIG_CMD_SETEXPR is not set
-# CONFIG_CMD_NFS is not set
-# CONFIG_CMD_MISC is not set
diff --git a/configs/ls2085a_simu_defconfig b/configs/ls2085a_simu_defconfig
deleted file mode 100644
index 9d04218..0000000
--- a/configs/ls2085a_simu_defconfig
+++ /dev/null
@@ -1,15 +0,0 @@
-CONFIG_ARM=y
-CONFIG_TARGET_LS2085A_SIMU=y
-CONFIG_SYS_EXTRA_OPTIONS="SIMU"
-# CONFIG_CMD_CONSOLE is not set
-# CONFIG_CMD_IMLS is not set
-# CONFIG_CMD_XIMG is not set
-# CONFIG_CMD_EDITENV is not set
-# CONFIG_CMD_ENV_EXISTS is not set
-# CONFIG_CMD_LOADS is not set
-# CONFIG_CMD_FPGA is not set
-# CONFIG_CMD_ITEST is not set
-# CONFIG_CMD_SETEXPR is not set
-# CONFIG_CMD_NFS is not set
-# CONFIG_CMD_MISC is not set
-CONFIG_NET_RANDOM_ETHADDR=y
diff --git a/configs/ls2085aqds_defconfig b/configs/ls2085aqds_defconfig
deleted file mode 100644
index 78b121d..0000000
--- a/configs/ls2085aqds_defconfig
+++ /dev/null
@@ -1,14 +0,0 @@
-CONFIG_ARM=y
-CONFIG_TARGET_LS2085AQDS=y
-# CONFIG_SYS_MALLOC_F is not set
-CONFIG_DM_SPI=y
-CONFIG_DM_SPI_FLASH=y
-CONFIG_DEFAULT_DEVICE_TREE="fsl-ls2085a-qds"
-CONFIG_SYS_EXTRA_OPTIONS="SYS_FSL_DDR4"
-# CONFIG_CMD_SETEXPR is not set
-CONFIG_OF_CONTROL=y
-CONFIG_NET_RANDOM_ETHADDR=y
-CONFIG_DM=y
-CONFIG_NETDEVICES=y
-CONFIG_E1000=y
-CONFIG_FSL_DSPI=y
diff --git a/configs/ls2085aqds_nand_defconfig b/configs/ls2085aqds_nand_defconfig
deleted file mode 100644
index ce2a81c..0000000
--- a/configs/ls2085aqds_nand_defconfig
+++ /dev/null
@@ -1,8 +0,0 @@
-CONFIG_ARM=y
-CONFIG_TARGET_LS2085AQDS=y
-CONFIG_SPL=y
-CONFIG_SYS_EXTRA_OPTIONS="SYS_FSL_DDR4,NAND"
-# CONFIG_CMD_SETEXPR is not set
-CONFIG_NET_RANDOM_ETHADDR=y
-CONFIG_NETDEVICES=y
-CONFIG_E1000=y
diff --git a/configs/ls2085ardb_defconfig b/configs/ls2085ardb_defconfig
deleted file mode 100644
index d0f16f2..0000000
--- a/configs/ls2085ardb_defconfig
+++ /dev/null
@@ -1,14 +0,0 @@
-CONFIG_ARM=y
-CONFIG_TARGET_LS2085ARDB=y
-# CONFIG_SYS_MALLOC_F is not set
-CONFIG_DM_SPI=y
-CONFIG_DM_SPI_FLASH=y
-CONFIG_DEFAULT_DEVICE_TREE="fsl-ls2085a-rdb"
-CONFIG_SYS_EXTRA_OPTIONS="SYS_FSL_DDR4"
-# CONFIG_CMD_SETEXPR is not set
-CONFIG_OF_CONTROL=y
-CONFIG_NET_RANDOM_ETHADDR=y
-CONFIG_DM=y
-CONFIG_NETDEVICES=y
-CONFIG_E1000=y
-CONFIG_FSL_DSPI=y
diff --git a/configs/ls2085ardb_nand_defconfig b/configs/ls2085ardb_nand_defconfig
deleted file mode 100644
index 25a6f71..0000000
--- a/configs/ls2085ardb_nand_defconfig
+++ /dev/null
@@ -1,8 +0,0 @@
-CONFIG_ARM=y
-CONFIG_TARGET_LS2085ARDB=y
-CONFIG_SPL=y
-CONFIG_SYS_EXTRA_OPTIONS="SYS_FSL_DDR4,NAND"
-# CONFIG_CMD_SETEXPR is not set
-CONFIG_NET_RANDOM_ETHADDR=y
-CONFIG_NETDEVICES=y
-CONFIG_E1000=y
diff --git a/doc/README.fsl-trustzone-components b/doc/README.fsl-trustzone-components
index a3afd1f..e122346 100644
--- a/doc/README.fsl-trustzone-components
+++ b/doc/README.fsl-trustzone-components
@@ -1,4 +1,4 @@
-Freescale ARM64 SoCs like LS2085A have ARM TrustZone components like
+Freescale ARM64 SoCs like LS2080A have ARM TrustZone components like
 TZPC-BP147 (TrustZone Protection Controller) and TZASC-400 (TrustZone
 Address Space Controller).
 
@@ -7,7 +7,7 @@ is left to a root-of-trust security software layer (running in EL3
 privilege mode), but still some configurations of these peripherals
 might be required while the bootloader is executing in EL3 privilege
 mode. The following sections define how to turn on these features for
-LS2085A like SoCs.
+LS2080A like SoCs.
 
 TZPC-BP147 (TrustZone Protection Controller)
 ============================================
diff --git a/drivers/ddr/fsl/fsl_ddr_gen4.c b/drivers/ddr/fsl/fsl_ddr_gen4.c
index 49e4688..eefe709 100644
--- a/drivers/ddr/fsl/fsl_ddr_gen4.c
+++ b/drivers/ddr/fsl/fsl_ddr_gen4.c
@@ -107,14 +107,14 @@ void fsl_ddr_set_memctl_regs(const fsl_ddr_cfg_regs_t *regs,
 		goto step2;
 
 #ifdef CONFIG_SYS_FSL_ERRATUM_A008336
-#ifdef CONFIG_LS2085A
+#ifdef CONFIG_LS2080A
 	/* A008336 only applies to general DDR controllers */
 	if ((ctrl_num == 0) || (ctrl_num == 1))
 #endif
 		ddr_out32(eddrtqcr1, 0x63b30002);
 #endif
 #ifdef CONFIG_SYS_FSL_ERRATUM_A008514
-#ifdef CONFIG_LS2085A
+#ifdef CONFIG_LS2080A
 	/* A008514 only applies to DP-DDR controler */
 	if (ctrl_num == 2)
 #endif
diff --git a/drivers/net/fsl-mc/mc.c b/drivers/net/fsl-mc/mc.c
index 5168b99..e1a02d1 100644
--- a/drivers/net/fsl-mc/mc.c
+++ b/drivers/net/fsl-mc/mc.c
@@ -1147,7 +1147,10 @@ static int do_fsl_mc(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
 	switch (argv[1][0]) {
 	case 's': {
 			char sub_cmd;
-			u64 mc_fw_addr, mc_dpc_addr, aiop_fw_addr;
+			u64 mc_fw_addr, mc_dpc_addr;
+#ifdef CONFIG_SYS_LS_MC_DRAM_AIOP_IMG_OFFSET
+			u64 aiop_fw_addr;
+#endif
 
 			sub_cmd = argv[2][0];
 			switch (sub_cmd) {
diff --git a/drivers/net/ldpaa_eth/Makefile b/drivers/net/ldpaa_eth/Makefile
index c37633f..5587aa6 100644
--- a/drivers/net/ldpaa_eth/Makefile
+++ b/drivers/net/ldpaa_eth/Makefile
@@ -6,4 +6,4 @@
 
 obj-y += ldpaa_wriop.o
 obj-y += ldpaa_eth.o
-obj-$(CONFIG_LS2085A) += ls2085a.o
+obj-$(CONFIG_LS2080A) += ls2080a.o
diff --git a/drivers/net/ldpaa_eth/ls2080a.c b/drivers/net/ldpaa_eth/ls2080a.c
new file mode 100644
index 0000000..93ed4f1
--- /dev/null
+++ b/drivers/net/ldpaa_eth/ls2080a.c
@@ -0,0 +1,81 @@
+/*
+ * Copyright 2015 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+#include <common.h>
+#include <phy.h>
+#include <fsl-mc/ldpaa_wriop.h>
+#include <asm/io.h>
+#include <asm/arch/fsl_serdes.h>
+
+u32 dpmac_to_devdisr[] = {
+	[WRIOP1_DPMAC1] = FSL_CHASSIS3_DEVDISR2_DPMAC1,
+	[WRIOP1_DPMAC2] = FSL_CHASSIS3_DEVDISR2_DPMAC2,
+	[WRIOP1_DPMAC3] = FSL_CHASSIS3_DEVDISR2_DPMAC3,
+	[WRIOP1_DPMAC4] = FSL_CHASSIS3_DEVDISR2_DPMAC4,
+	[WRIOP1_DPMAC5] = FSL_CHASSIS3_DEVDISR2_DPMAC5,
+	[WRIOP1_DPMAC6] = FSL_CHASSIS3_DEVDISR2_DPMAC6,
+	[WRIOP1_DPMAC7] = FSL_CHASSIS3_DEVDISR2_DPMAC7,
+	[WRIOP1_DPMAC8] = FSL_CHASSIS3_DEVDISR2_DPMAC8,
+	[WRIOP1_DPMAC9] = FSL_CHASSIS3_DEVDISR2_DPMAC9,
+	[WRIOP1_DPMAC10] = FSL_CHASSIS3_DEVDISR2_DPMAC10,
+	[WRIOP1_DPMAC11] = FSL_CHASSIS3_DEVDISR2_DPMAC11,
+	[WRIOP1_DPMAC12] = FSL_CHASSIS3_DEVDISR2_DPMAC12,
+	[WRIOP1_DPMAC13] = FSL_CHASSIS3_DEVDISR2_DPMAC13,
+	[WRIOP1_DPMAC14] = FSL_CHASSIS3_DEVDISR2_DPMAC14,
+	[WRIOP1_DPMAC15] = FSL_CHASSIS3_DEVDISR2_DPMAC15,
+	[WRIOP1_DPMAC16] = FSL_CHASSIS3_DEVDISR2_DPMAC16,
+	[WRIOP1_DPMAC17] = FSL_CHASSIS3_DEVDISR2_DPMAC17,
+	[WRIOP1_DPMAC18] = FSL_CHASSIS3_DEVDISR2_DPMAC18,
+	[WRIOP1_DPMAC19] = FSL_CHASSIS3_DEVDISR2_DPMAC19,
+	[WRIOP1_DPMAC20] = FSL_CHASSIS3_DEVDISR2_DPMAC20,
+	[WRIOP1_DPMAC21] = FSL_CHASSIS3_DEVDISR2_DPMAC21,
+	[WRIOP1_DPMAC22] = FSL_CHASSIS3_DEVDISR2_DPMAC22,
+	[WRIOP1_DPMAC23] = FSL_CHASSIS3_DEVDISR2_DPMAC23,
+	[WRIOP1_DPMAC24] = FSL_CHASSIS3_DEVDISR2_DPMAC24,
+};
+
+static int is_device_disabled(int dpmac_id)
+{
+	struct ccsr_gur __iomem *gur = (void *)CONFIG_SYS_FSL_GUTS_ADDR;
+	u32 devdisr2 = in_le32(&gur->devdisr2);
+
+	return dpmac_to_devdisr[dpmac_id] & devdisr2;
+}
+
+void wriop_dpmac_disable(int dpmac_id)
+{
+	struct ccsr_gur __iomem *gur = (void *)CONFIG_SYS_FSL_GUTS_ADDR;
+
+	setbits_le32(&gur->devdisr2, dpmac_to_devdisr[dpmac_id]);
+}
+
+void wriop_dpmac_enable(int dpmac_id)
+{
+	struct ccsr_gur __iomem *gur = (void *)CONFIG_SYS_FSL_GUTS_ADDR;
+
+	clrbits_le32(&gur->devdisr2, dpmac_to_devdisr[dpmac_id]);
+}
+
+phy_interface_t wriop_dpmac_enet_if(int dpmac_id, int lane_prtcl)
+{
+	enum srds_prtcl;
+
+	if (is_device_disabled(dpmac_id + 1))
+		return PHY_INTERFACE_MODE_NONE;
+
+	if (lane_prtcl >= SGMII1 && lane_prtcl <= SGMII16)
+		return PHY_INTERFACE_MODE_SGMII;
+
+	if (lane_prtcl >= XFI1 && lane_prtcl <= XFI8)
+		return PHY_INTERFACE_MODE_XGMII;
+
+	if (lane_prtcl >= XAUI1 && lane_prtcl <= XAUI2)
+		return PHY_INTERFACE_MODE_XGMII;
+
+	if (lane_prtcl >= QSGMII_A && lane_prtcl <= QSGMII_D)
+		return PHY_INTERFACE_MODE_QSGMII;
+
+	return PHY_INTERFACE_MODE_NONE;
+}
diff --git a/drivers/net/ldpaa_eth/ls2085a.c b/drivers/net/ldpaa_eth/ls2085a.c
deleted file mode 100644
index 93ed4f1..0000000
--- a/drivers/net/ldpaa_eth/ls2085a.c
+++ /dev/null
@@ -1,81 +0,0 @@
-/*
- * Copyright 2015 Freescale Semiconductor, Inc.
- *
- * SPDX-License-Identifier:	GPL-2.0+
- */
-#include <common.h>
-#include <phy.h>
-#include <fsl-mc/ldpaa_wriop.h>
-#include <asm/io.h>
-#include <asm/arch/fsl_serdes.h>
-
-u32 dpmac_to_devdisr[] = {
-	[WRIOP1_DPMAC1] = FSL_CHASSIS3_DEVDISR2_DPMAC1,
-	[WRIOP1_DPMAC2] = FSL_CHASSIS3_DEVDISR2_DPMAC2,
-	[WRIOP1_DPMAC3] = FSL_CHASSIS3_DEVDISR2_DPMAC3,
-	[WRIOP1_DPMAC4] = FSL_CHASSIS3_DEVDISR2_DPMAC4,
-	[WRIOP1_DPMAC5] = FSL_CHASSIS3_DEVDISR2_DPMAC5,
-	[WRIOP1_DPMAC6] = FSL_CHASSIS3_DEVDISR2_DPMAC6,
-	[WRIOP1_DPMAC7] = FSL_CHASSIS3_DEVDISR2_DPMAC7,
-	[WRIOP1_DPMAC8] = FSL_CHASSIS3_DEVDISR2_DPMAC8,
-	[WRIOP1_DPMAC9] = FSL_CHASSIS3_DEVDISR2_DPMAC9,
-	[WRIOP1_DPMAC10] = FSL_CHASSIS3_DEVDISR2_DPMAC10,
-	[WRIOP1_DPMAC11] = FSL_CHASSIS3_DEVDISR2_DPMAC11,
-	[WRIOP1_DPMAC12] = FSL_CHASSIS3_DEVDISR2_DPMAC12,
-	[WRIOP1_DPMAC13] = FSL_CHASSIS3_DEVDISR2_DPMAC13,
-	[WRIOP1_DPMAC14] = FSL_CHASSIS3_DEVDISR2_DPMAC14,
-	[WRIOP1_DPMAC15] = FSL_CHASSIS3_DEVDISR2_DPMAC15,
-	[WRIOP1_DPMAC16] = FSL_CHASSIS3_DEVDISR2_DPMAC16,
-	[WRIOP1_DPMAC17] = FSL_CHASSIS3_DEVDISR2_DPMAC17,
-	[WRIOP1_DPMAC18] = FSL_CHASSIS3_DEVDISR2_DPMAC18,
-	[WRIOP1_DPMAC19] = FSL_CHASSIS3_DEVDISR2_DPMAC19,
-	[WRIOP1_DPMAC20] = FSL_CHASSIS3_DEVDISR2_DPMAC20,
-	[WRIOP1_DPMAC21] = FSL_CHASSIS3_DEVDISR2_DPMAC21,
-	[WRIOP1_DPMAC22] = FSL_CHASSIS3_DEVDISR2_DPMAC22,
-	[WRIOP1_DPMAC23] = FSL_CHASSIS3_DEVDISR2_DPMAC23,
-	[WRIOP1_DPMAC24] = FSL_CHASSIS3_DEVDISR2_DPMAC24,
-};
-
-static int is_device_disabled(int dpmac_id)
-{
-	struct ccsr_gur __iomem *gur = (void *)CONFIG_SYS_FSL_GUTS_ADDR;
-	u32 devdisr2 = in_le32(&gur->devdisr2);
-
-	return dpmac_to_devdisr[dpmac_id] & devdisr2;
-}
-
-void wriop_dpmac_disable(int dpmac_id)
-{
-	struct ccsr_gur __iomem *gur = (void *)CONFIG_SYS_FSL_GUTS_ADDR;
-
-	setbits_le32(&gur->devdisr2, dpmac_to_devdisr[dpmac_id]);
-}
-
-void wriop_dpmac_enable(int dpmac_id)
-{
-	struct ccsr_gur __iomem *gur = (void *)CONFIG_SYS_FSL_GUTS_ADDR;
-
-	clrbits_le32(&gur->devdisr2, dpmac_to_devdisr[dpmac_id]);
-}
-
-phy_interface_t wriop_dpmac_enet_if(int dpmac_id, int lane_prtcl)
-{
-	enum srds_prtcl;
-
-	if (is_device_disabled(dpmac_id + 1))
-		return PHY_INTERFACE_MODE_NONE;
-
-	if (lane_prtcl >= SGMII1 && lane_prtcl <= SGMII16)
-		return PHY_INTERFACE_MODE_SGMII;
-
-	if (lane_prtcl >= XFI1 && lane_prtcl <= XFI8)
-		return PHY_INTERFACE_MODE_XGMII;
-
-	if (lane_prtcl >= XAUI1 && lane_prtcl <= XAUI2)
-		return PHY_INTERFACE_MODE_XGMII;
-
-	if (lane_prtcl >= QSGMII_A && lane_prtcl <= QSGMII_D)
-		return PHY_INTERFACE_MODE_QSGMII;
-
-	return PHY_INTERFACE_MODE_NONE;
-}
diff --git a/drivers/pci/pcie_layerscape.c b/drivers/pci/pcie_layerscape.c
index 4cee038..8af6531 100644
--- a/drivers/pci/pcie_layerscape.c
+++ b/drivers/pci/pcie_layerscape.c
@@ -665,7 +665,7 @@ void ft_pci_setup(void *blob, bd_t *bd)
 }
 #endif
 
-#ifdef CONFIG_LS2085A
+#ifdef CONFIG_LS2080A
 
 void pcie_set_available_streamids(void *blob, const char *pcie_path,
 				  u32 *stream_ids, int count)
diff --git a/include/configs/ls2080a_common.h b/include/configs/ls2080a_common.h
new file mode 100644
index 0000000..a7bf921
--- /dev/null
+++ b/include/configs/ls2080a_common.h
@@ -0,0 +1,317 @@
+/*
+ * Copyright (C) 2014 Freescale Semiconductor
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __LS2_COMMON_H
+#define __LS2_COMMON_H
+
+
+#define CONFIG_REMAKE_ELF
+#define CONFIG_FSL_LAYERSCAPE
+#define CONFIG_FSL_LSCH3
+#define CONFIG_LS2080A
+#define CONFIG_MP
+#define CONFIG_GICV3
+#define CONFIG_FSL_TZPC_BP147
+
+/* Errata fixes */
+#define CONFIG_ARM_ERRATA_828024
+#define CONFIG_ARM_ERRATA_826974
+
+#include <asm/arch/ls2080a_stream_id.h>
+#include <asm/arch/config.h>
+#if (defined(CONFIG_SYS_FSL_SRDS_1) || defined(CONFIG_SYS_FSL_SRDS_2))
+#define	CONFIG_SYS_HAS_SERDES
+#endif
+
+/* Link Definitions */
+#define CONFIG_SYS_INIT_SP_ADDR		(CONFIG_SYS_FSL_OCRAM_BASE + 0xfff0)
+
+/* We need architecture specific misc initializations */
+#define CONFIG_ARCH_MISC_INIT
+
+/* Link Definitions */
+#ifdef CONFIG_SPL
+#define CONFIG_SYS_TEXT_BASE		0x80400000
+#else
+#define CONFIG_SYS_TEXT_BASE		0x30100000
+#endif
+
+#ifdef CONFIG_EMU
+#define CONFIG_SYS_NO_FLASH
+#endif
+
+#define CONFIG_SUPPORT_RAW_INITRD
+
+#define CONFIG_SKIP_LOWLEVEL_INIT
+#define CONFIG_BOARD_EARLY_INIT_F	1
+
+/* Flat Device Tree Definitions */
+#define CONFIG_OF_LIBFDT
+#define CONFIG_OF_BOARD_SETUP
+
+/* new uImage format support */
+#define CONFIG_FIT
+#define CONFIG_FIT_VERBOSE	/* enable fit_format_{error,warning}() */
+
+#ifndef CONFIG_SPL
+#define CONFIG_FSL_DDR_INTERACTIVE	/* Interactive debugging */
+#endif
+#ifndef CONFIG_SYS_FSL_DDR4
+#define CONFIG_SYS_FSL_DDR3		/* Use DDR3 memory */
+#define CONFIG_SYS_DDR_RAW_TIMING
+#endif
+
+#define CONFIG_SYS_FSL_DDR_INTLV_256B	/* force 256 byte interleaving */
+
+#define CONFIG_VERY_BIG_RAM
+#define CONFIG_SYS_DDR_SDRAM_BASE	0x80000000UL
+#define CONFIG_SYS_FSL_DDR_SDRAM_BASE_PHY	0
+#define CONFIG_SYS_SDRAM_BASE		CONFIG_SYS_DDR_SDRAM_BASE
+#define CONFIG_SYS_DDR_BLOCK2_BASE	0x8080000000ULL
+#define CONFIG_SYS_FSL_DDR_MAIN_NUM_CTRLS	2
+
+/*
+ * SMP Definitinos
+ */
+#define CPU_RELEASE_ADDR		secondary_boot_func
+
+#define CONFIG_SYS_FSL_OTHER_DDR_NUM_CTRLS
+#ifdef CONFIG_SYS_FSL_HAS_DP_DDR
+#define CONFIG_SYS_DP_DDR_BASE		0x6000000000ULL
+/*
+ * DDR controller use 0 as the base address for binding.
+ * It is mapped to CONFIG_SYS_DP_DDR_BASE for core to access.
+ */
+#define CONFIG_SYS_DP_DDR_BASE_PHY	0
+#define CONFIG_DP_DDR_CTRL		2
+#define CONFIG_DP_DDR_NUM_CTRLS		1
+#endif
+
+/* Generic Timer Definitions */
+/*
+ * This is not an accurate number. It is used in start.S. The frequency
+ * will be udpated later when get_bus_freq(0) is available.
+ */
+#define COUNTER_FREQUENCY		25000000	/* 25MHz */
+
+/* Size of malloc() pool */
+#define CONFIG_SYS_MALLOC_LEN		(CONFIG_ENV_SIZE + 2048 * 1024)
+
+/* I2C */
+#define CONFIG_CMD_I2C
+#define CONFIG_SYS_I2C
+#define CONFIG_SYS_I2C_MXC
+#define CONFIG_SYS_I2C_MXC_I2C1		/* enable I2C bus 1 */
+#define CONFIG_SYS_I2C_MXC_I2C2		/* enable I2C bus 2 */
+#define CONFIG_SYS_I2C_MXC_I2C3		/* enable I2C bus 3 */
+#define CONFIG_SYS_I2C_MXC_I2C4		/* enable I2C bus 4 */
+
+/* Serial Port */
+#define CONFIG_CONS_INDEX       1
+#define CONFIG_SYS_NS16550
+#define CONFIG_SYS_NS16550_SERIAL
+#define CONFIG_SYS_NS16550_REG_SIZE     1
+#define CONFIG_SYS_NS16550_CLK          (get_bus_freq(0)/2)
+
+#define CONFIG_BAUDRATE			115200
+#define CONFIG_SYS_BAUDRATE_TABLE	{ 9600, 19200, 38400, 57600, 115200 }
+
+/* IFC */
+#define CONFIG_FSL_IFC
+
+/*
+ * During booting, IFC is mapped at the region of 0x30000000.
+ * But this region is limited to 256MB. To accommodate NOR, promjet
+ * and FPGA. This region is divided as below:
+ * 0x30000000 - 0x37ffffff : 128MB : NOR flash
+ * 0x38000000 - 0x3BFFFFFF : 64MB  : Promjet
+ * 0x3C000000 - 0x40000000 : 64MB  : FPGA etc
+ *
+ * To accommodate bigger NOR flash and other devices, we will map IFC
+ * chip selects to as below:
+ * 0x5_1000_0000..0x5_1fff_ffff	Memory Hole
+ * 0x5_2000_0000..0x5_3fff_ffff	IFC CSx (FPGA, NAND and others 512MB)
+ * 0x5_4000_0000..0x5_7fff_ffff	ASIC or others 1GB
+ * 0x5_8000_0000..0x5_bfff_ffff	IFC CS0 1GB (NOR/Promjet)
+ * 0x5_C000_0000..0x5_ffff_ffff	IFC CS1 1GB (NOR/Promjet)
+ *
+ * For e.g. NOR flash at CS0 will be mapped to 0x580000000 after relocation.
+ * CONFIG_SYS_FLASH_BASE has the final address (core view)
+ * CONFIG_SYS_FLASH_BASE_PHYS has the final address (IFC view)
+ * CONFIG_SYS_FLASH_BASE_PHYS_EARLY has the temporary IFC address
+ * CONFIG_SYS_TEXT_BASE is linked to 0x30000000 for booting
+ */
+
+#define CONFIG_SYS_FLASH_BASE			0x580000000ULL
+#define CONFIG_SYS_FLASH_BASE_PHYS		0x80000000
+#define CONFIG_SYS_FLASH_BASE_PHYS_EARLY	0x00000000
+
+#define CONFIG_SYS_FLASH1_BASE_PHYS		0xC0000000
+#define CONFIG_SYS_FLASH1_BASE_PHYS_EARLY	0x8000000
+
+#ifndef CONFIG_SYS_NO_FLASH
+#define CONFIG_FLASH_CFI_DRIVER
+#define CONFIG_SYS_FLASH_CFI
+#define CONFIG_SYS_FLASH_USE_BUFFER_WRITE
+#define CONFIG_SYS_FLASH_QUIET_TEST
+#endif
+
+#ifndef __ASSEMBLY__
+unsigned long long get_qixis_addr(void);
+#endif
+#define QIXIS_BASE				get_qixis_addr()
+#define QIXIS_BASE_PHYS				0x20000000
+#define QIXIS_BASE_PHYS_EARLY			0xC000000
+#define QIXIS_STAT_PRES1			0xb
+#define QIXIS_SDID_MASK				0x07
+#define QIXIS_ESDHC_NO_ADAPTER			0x7
+
+#define CONFIG_SYS_NAND_BASE			0x530000000ULL
+#define CONFIG_SYS_NAND_BASE_PHYS		0x30000000
+
+/* Debug Server firmware */
+#define CONFIG_FSL_DEBUG_SERVER
+/* 2 sec timeout */
+#define CONFIG_SYS_DEBUG_SERVER_TIMEOUT			(2 * 1000 * 1000)
+
+/* MC firmware */
+#define CONFIG_FSL_MC_ENET
+/* TODO Actual DPL max length needs to be confirmed with the MC FW team */
+#define CONFIG_SYS_LS_MC_DPC_MAX_LENGTH	    0x20000
+#define CONFIG_SYS_LS_MC_DRAM_DPC_OFFSET    0x00F00000
+#define CONFIG_SYS_LS_MC_DPL_MAX_LENGTH	    0x20000
+#define CONFIG_SYS_LS_MC_DRAM_DPL_OFFSET    0x00F20000
+#ifndef CONFIG_LS2080A
+#define CONFIG_SYS_LS_MC_AIOP_IMG_MAX_LENGTH	0x200000
+#define CONFIG_SYS_LS_MC_DRAM_AIOP_IMG_OFFSET	0x07000000
+#endif
+
+/*
+ * Carve out a DDR region which will not be used by u-boot/Linux
+ *
+ * It will be used by MC and Debug Server. The MC region must be
+ * 512MB aligned, so the min size to hide is 512MB.
+ */
+#if defined(CONFIG_FSL_MC_ENET) || defined(CONFIG_FSL_DEBUG_SERVER)
+#define CONFIG_SYS_DEBUG_SERVER_DRAM_BLOCK_MIN_SIZE	(256UL * 1024 * 1024)
+#define CONFIG_SYS_LS_MC_DRAM_BLOCK_MIN_SIZE		(256UL * 1024 * 1024)
+#define CONFIG_SYS_MEM_TOP_HIDE_MIN			(512UL * 1024 * 1024)
+#define CONFIG_SYS_MEM_TOP_HIDE		get_dram_size_to_hide()
+#endif
+
+/* PCIe */
+#define CONFIG_PCIE1		/* PCIE controler 1 */
+#define CONFIG_PCIE2		/* PCIE controler 2 */
+#define CONFIG_PCIE3		/* PCIE controler 3 */
+#define CONFIG_PCIE4		/* PCIE controler 4 */
+#define CONFIG_PCIE_LAYERSCAPE	/* Use common FSL Layerscape PCIe code */
+#define FSL_PCIE_COMPAT "fsl,ls2080a-pcie"
+
+#define CONFIG_SYS_PCI_64BIT
+
+#define CONFIG_SYS_PCIE_CFG0_PHYS_OFF	0x00000000
+#define CONFIG_SYS_PCIE_CFG0_SIZE	0x00001000	/* 4k */
+#define CONFIG_SYS_PCIE_CFG1_PHYS_OFF	0x00001000
+#define CONFIG_SYS_PCIE_CFG1_SIZE	0x00001000	/* 4k */
+
+#define CONFIG_SYS_PCIE_IO_BUS		0x00000000
+#define CONFIG_SYS_PCIE_IO_PHYS_OFF	0x00010000
+#define CONFIG_SYS_PCIE_IO_SIZE		0x00010000	/* 64k */
+
+#define CONFIG_SYS_PCIE_MEM_BUS		0x40000000
+#define CONFIG_SYS_PCIE_MEM_PHYS_OFF	0x40000000
+#define CONFIG_SYS_PCIE_MEM_SIZE	0x40000000	/* 1G */
+
+/* Command line configuration */
+#define CONFIG_CMD_CACHE
+#define CONFIG_CMD_DHCP
+#define CONFIG_CMD_ENV
+#define CONFIG_CMD_GREPENV
+#define CONFIG_CMD_MII
+#define CONFIG_CMD_PING
+
+/* Miscellaneous configurable options */
+#define CONFIG_SYS_LOAD_ADDR	(CONFIG_SYS_DDR_SDRAM_BASE + 0x10000000)
+#define CONFIG_ARCH_EARLY_INIT_R
+
+/* Physical Memory Map */
+/* fixme: these need to be checked against the board */
+#define CONFIG_CHIP_SELECTS_PER_CTRL	4
+
+#define CONFIG_NR_DRAM_BANKS		3
+
+#define CONFIG_HWCONFIG
+#define HWCONFIG_BUFFER_SIZE		128
+
+#define CONFIG_DISPLAY_CPUINFO
+
+/* Initial environment variables */
+#define CONFIG_EXTRA_ENV_SETTINGS		\
+	"hwconfig=fsl_ddr:bank_intlv=auto\0"	\
+	"loadaddr=0x80100000\0"			\
+	"kernel_addr=0x100000\0"		\
+	"ramdisk_addr=0x800000\0"		\
+	"ramdisk_size=0x2000000\0"		\
+	"fdt_high=0xa0000000\0"			\
+	"initrd_high=0xffffffffffffffff\0"	\
+	"kernel_start=0x581200000\0"		\
+	"kernel_load=0xa0000000\0"		\
+	"kernel_size=0x2800000\0"		\
+	"console=ttyAMA0,38400n8\0"
+
+#define CONFIG_BOOTARGS		"console=ttyS0,115200 root=/dev/ram0 " \
+				"earlycon=uart8250,mmio,0x21c0500,115200 " \
+				"ramdisk_size=0x2000000 default_hugepagesz=2m" \
+				" hugepagesz=2m hugepages=16"
+#define CONFIG_BOOTCOMMAND		"cp.b $kernel_start $kernel_load "     \
+					"$kernel_size && bootm $kernel_load"
+#define CONFIG_BOOTDELAY		10
+
+/* Monitor Command Prompt */
+#define CONFIG_SYS_CBSIZE		512	/* Console I/O Buffer Size */
+#define CONFIG_SYS_PBSIZE		(CONFIG_SYS_CBSIZE + \
+					sizeof(CONFIG_SYS_PROMPT) + 16)
+#define CONFIG_SYS_HUSH_PARSER
+#define CONFIG_SYS_PROMPT_HUSH_PS2	"> "
+#define CONFIG_SYS_BARGSIZE		CONFIG_SYS_CBSIZE /* Boot args buffer */
+#define CONFIG_SYS_LONGHELP
+#define CONFIG_CMDLINE_EDITING		1
+#define CONFIG_AUTO_COMPLETE
+#define CONFIG_SYS_MAXARGS		64	/* max command args */
+
+#ifndef __ASSEMBLY__
+unsigned long get_dram_size_to_hide(void);
+#endif
+
+#define CONFIG_PANIC_HANG	/* do not reset board on panic */
+
+#define CONFIG_SPL_BSS_START_ADDR	0x80100000
+#define CONFIG_SPL_BSS_MAX_SIZE		0x00100000
+#define CONFIG_SPL_DRIVERS_MISC_SUPPORT
+#define CONFIG_SPL_ENV_SUPPORT
+#define CONFIG_SPL_FRAMEWORK
+#define CONFIG_SPL_I2C_SUPPORT
+#define CONFIG_SPL_LDSCRIPT "arch/arm/cpu/armv8/u-boot-spl.lds"
+#define CONFIG_SPL_LIBCOMMON_SUPPORT
+#define CONFIG_SPL_LIBGENERIC_SUPPORT
+#define CONFIG_SPL_MAX_SIZE		0x16000
+#define CONFIG_SPL_MPC8XXX_INIT_DDR_SUPPORT
+#define CONFIG_SPL_NAND_SUPPORT
+#define CONFIG_SPL_SERIAL_SUPPORT
+#define CONFIG_SPL_STACK		(CONFIG_SYS_FSL_OCRAM_BASE + 0x9ff0)
+#define CONFIG_SPL_TARGET		"u-boot-with-spl.bin"
+#define CONFIG_SPL_TEXT_BASE		0x1800a000
+
+#define CONFIG_SYS_NAND_U_BOOT_DST	0x80400000
+#define CONFIG_SYS_NAND_U_BOOT_START	CONFIG_SYS_NAND_U_BOOT_DST
+#define CONFIG_SYS_SPL_MALLOC_SIZE	0x00100000
+#define CONFIG_SYS_SPL_MALLOC_START	0x80200000
+#define CONFIG_SYS_MONITOR_LEN		(512 * 1024)
+
+#define CONFIG_SYS_BOOTM_LEN   (64 << 20)      /* Increase max gunzip size */
+
+
+#endif /* __LS2_COMMON_H */
diff --git a/include/configs/ls2080a_emu.h b/include/configs/ls2080a_emu.h
new file mode 100644
index 0000000..6400f4f
--- /dev/null
+++ b/include/configs/ls2080a_emu.h
@@ -0,0 +1,91 @@
+/*
+ * Copyright 2014 Freescale Semiconductor
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __LS2_EMU_H
+#define __LS2_EMU_H
+
+#include "ls2080a_common.h"
+
+#define CONFIG_IDENT_STRING		" LS2080A-EMU"
+#define CONFIG_BOOTP_VCI_STRING		"U-boot.LS2080A-EMU"
+
+#define CONFIG_SYS_CLK_FREQ	100000000
+#define CONFIG_DDR_CLK_FREQ	133333333
+
+#define CONFIG_SYS_MXC_I2C1_SPEED	40000000
+#define CONFIG_SYS_MXC_I2C2_SPEED	40000000
+
+#define CONFIG_DDR_SPD
+#define CONFIG_SYS_FSL_DDR_EMU		/* Support emulator */
+#define SPD_EEPROM_ADDRESS1	0x51
+#define SPD_EEPROM_ADDRESS2	0x52
+#define SPD_EEPROM_ADDRESS3	0x53
+#define SPD_EEPROM_ADDRESS	SPD_EEPROM_ADDRESS1
+#define CONFIG_SYS_SPD_BUS_NUM	1	/* SPD on I2C bus 1 */
+#define CONFIG_DIMM_SLOTS_PER_CTLR		1
+#define CONFIG_CHIP_SELECTS_PER_CTRL		4
+#ifdef CONFIG_SYS_FSL_HAS_DP_DDR
+#define CONFIG_DP_DDR_DIMM_SLOTS_PER_CTLR	1
+#endif
+
+#define CONFIG_FSL_DDR_SYNC_REFRESH
+
+#define CONFIG_SYS_NOR0_CSPR_EXT	(0x0)
+#define CONFIG_SYS_NOR_AMASK	IFC_AMASK(128*1024*1024)
+/*
+ * NOR Flash Timing Params
+ */
+#define CONFIG_SYS_NOR0_CSPR					\
+	(CSPR_PHYS_ADDR(CONFIG_SYS_FLASH_BASE_PHYS)		| \
+	CSPR_PORT_SIZE_16					| \
+	CSPR_MSEL_NOR						| \
+	CSPR_V)
+#define CONFIG_SYS_NOR0_CSPR_EARLY				\
+	(CSPR_PHYS_ADDR(CONFIG_SYS_FLASH_BASE_PHYS_EARLY)	| \
+	CSPR_PORT_SIZE_16					| \
+	CSPR_MSEL_NOR						| \
+	CSPR_V)
+#define CONFIG_SYS_NOR_CSOR	CSOR_NOR_ADM_SHIFT(12)
+#define CONFIG_SYS_NOR_FTIM0	(FTIM0_NOR_TACSE(0x1) | \
+				FTIM0_NOR_TEADC(0x1) | \
+				FTIM0_NOR_TEAHC(0x1))
+#define CONFIG_SYS_NOR_FTIM1	(FTIM1_NOR_TACO(0x1) | \
+				FTIM1_NOR_TRAD_NOR(0x1))
+#define CONFIG_SYS_NOR_FTIM2	(FTIM2_NOR_TCS(0x0) | \
+				FTIM2_NOR_TCH(0x0) | \
+				FTIM2_NOR_TWP(0x1))
+#define CONFIG_SYS_NOR_FTIM3	0x04000000
+#define CONFIG_SYS_IFC_CCR	0x01000000
+
+#define CONFIG_SYS_CSPR0_EXT		CONFIG_SYS_NOR0_CSPR_EXT
+#define CONFIG_SYS_CSPR0		CONFIG_SYS_NOR0_CSPR_EARLY
+#define CONFIG_SYS_CSPR0_FINAL		CONFIG_SYS_NOR0_CSPR
+#define CONFIG_SYS_AMASK0		CONFIG_SYS_NOR_AMASK
+#define CONFIG_SYS_CSOR0		CONFIG_SYS_NOR_CSOR
+#define CONFIG_SYS_CS0_FTIM0		CONFIG_SYS_NOR_FTIM0
+#define CONFIG_SYS_CS0_FTIM1		CONFIG_SYS_NOR_FTIM1
+#define CONFIG_SYS_CS0_FTIM2		CONFIG_SYS_NOR_FTIM2
+#define CONFIG_SYS_CS0_FTIM3		CONFIG_SYS_NOR_FTIM3
+
+/* Debug Server firmware */
+#define CONFIG_SYS_DEBUG_SERVER_FW_IN_NOR
+#define CONFIG_SYS_DEBUG_SERVER_FW_ADDR	0x580C00000ULL
+
+/*
+ * This trick allows users to load MC images into DDR directly without
+ * copying from NOR flash. It dramatically improves speed.
+ */
+#define CONFIG_SYS_LS_MC_FW_IN_DDR
+#define CONFIG_SYS_LS_MC_DPL_IN_DDR
+#define CONFIG_SYS_LS_MC_DPC_IN_DDR
+
+#define CONFIG_SYS_LS_MC_BOOT_TIMEOUT_MS 200000
+
+/* Store environment at top of flash */
+#define CONFIG_ENV_IS_NOWHERE		1
+#define CONFIG_ENV_SIZE			0x1000
+
+#endif /* __LS2_EMU_H */
diff --git a/include/configs/ls2080a_simu.h b/include/configs/ls2080a_simu.h
new file mode 100644
index 0000000..666df80
--- /dev/null
+++ b/include/configs/ls2080a_simu.h
@@ -0,0 +1,163 @@
+/*
+ * Copyright (C) 2014 Freescale Semiconductor
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __LS2_SIMU_H
+#define __LS2_SIMU_H
+
+#include "ls2080a_common.h"
+
+#define CONFIG_IDENT_STRING		" LS2080A-SIMU"
+#define CONFIG_BOOTP_VCI_STRING		"U-boot.LS2080A-SIMU"
+
+#define CONFIG_SYS_CLK_FREQ	100000000
+#define CONFIG_DDR_CLK_FREQ	133333333
+
+#define CONFIG_SYS_MXC_I2C1_SPEED	40000000
+#define CONFIG_SYS_MXC_I2C2_SPEED	40000000
+
+#define CONFIG_DIMM_SLOTS_PER_CTLR		1
+#define CONFIG_CHIP_SELECTS_PER_CTRL		4
+#ifdef CONFIG_SYS_FSL_HAS_DP_DDR
+#define CONFIG_DP_DDR_DIMM_SLOTS_PER_CTLR	1
+#endif
+
+/* SMSC 91C111 ethernet configuration */
+#define CONFIG_SMC91111
+#define CONFIG_SMC91111_BASE	(0x2210000)
+
+#define CONFIG_SYS_NOR0_CSPR_EXT	(0x0)
+#define CONFIG_SYS_NOR_AMASK	IFC_AMASK(128*1024*1024)
+
+/*
+ * NOR Flash Timing Params
+ */
+#define CONFIG_SYS_NOR0_CSPR					\
+	(CSPR_PHYS_ADDR(CONFIG_SYS_FLASH_BASE_PHYS)		| \
+	CSPR_PORT_SIZE_16					| \
+	CSPR_MSEL_NOR						| \
+	CSPR_V)
+#define CONFIG_SYS_NOR0_CSPR_EARLY				\
+	(CSPR_PHYS_ADDR(CONFIG_SYS_FLASH_BASE_PHYS_EARLY)	| \
+	CSPR_PORT_SIZE_16					| \
+	CSPR_MSEL_NOR						| \
+	CSPR_V)
+#define CONFIG_SYS_NOR_CSOR	CSOR_NOR_ADM_SHIFT(12)
+#define CONFIG_SYS_NOR_FTIM0	(FTIM0_NOR_TACSE(0x1) | \
+				FTIM0_NOR_TEADC(0x1) | \
+				FTIM0_NOR_TEAHC(0x1))
+#define CONFIG_SYS_NOR_FTIM1	(FTIM1_NOR_TACO(0x1) | \
+				FTIM1_NOR_TRAD_NOR(0x1))
+#define CONFIG_SYS_NOR_FTIM2	(FTIM2_NOR_TCS(0x0) | \
+				FTIM2_NOR_TCH(0x0) | \
+				FTIM2_NOR_TWP(0x1))
+#define CONFIG_SYS_NOR_FTIM3	0x04000000
+#define CONFIG_SYS_IFC_CCR	0x01000000
+
+#ifndef CONFIG_SYS_NO_FLASH
+#define CONFIG_FLASH_SHOW_PROGRESS	45 /* count down from 45/5: 9..1 */
+
+#define CONFIG_SYS_MAX_FLASH_BANKS	1	/* number of banks */
+#define CONFIG_SYS_MAX_FLASH_SECT	1024	/* sectors per device */
+#define CONFIG_SYS_FLASH_ERASE_TOUT	60000	/* Flash Erase Timeout (ms) */
+#define CONFIG_SYS_FLASH_WRITE_TOUT	500	/* Flash Write Timeout (ms) */
+
+#define CONFIG_SYS_FLASH_EMPTY_INFO
+#define CONFIG_SYS_FLASH_BANKS_LIST	{ CONFIG_SYS_FLASH_BASE }
+#endif
+
+#define CONFIG_NAND_FSL_IFC
+#define CONFIG_SYS_NAND_MAX_ECCPOS	256
+#define CONFIG_SYS_NAND_MAX_OOBFREE	2
+
+
+#define CONFIG_SYS_NAND_CSPR_EXT	(0x0)
+#define CONFIG_SYS_NAND_CSPR	(CSPR_PHYS_ADDR(CONFIG_SYS_NAND_BASE_PHYS) \
+				| CSPR_PORT_SIZE_8 /* Port Size = 8 bit */ \
+				| CSPR_MSEL_NAND	/* MSEL = NAND */ \
+				| CSPR_V)
+#define CONFIG_SYS_NAND_AMASK	IFC_AMASK(64 * 1024)
+
+#define CONFIG_SYS_NAND_CSOR    (CSOR_NAND_ECC_ENC_EN   /* ECC on encode */ \
+				| CSOR_NAND_ECC_DEC_EN  /* ECC on decode */ \
+				| CSOR_NAND_ECC_MODE_4  /* 4-bit ECC */ \
+				| CSOR_NAND_RAL_3	/* RAL = 2Byes */ \
+				| CSOR_NAND_PGS_2K	/* Page Size = 2K */ \
+				| CSOR_NAND_SPRZ_64/* Spare size = 64 */ \
+				| CSOR_NAND_PB(64))	/*Pages Per Block = 64*/
+
+#define CONFIG_SYS_NAND_ONFI_DETECTION
+
+/* ONFI NAND Flash mode0 Timing Params */
+#define CONFIG_SYS_NAND_FTIM0		(FTIM0_NAND_TCCST(0x07) | \
+					FTIM0_NAND_TWP(0x18)   | \
+					FTIM0_NAND_TWCHT(0x07) | \
+					FTIM0_NAND_TWH(0x0a))
+#define CONFIG_SYS_NAND_FTIM1		(FTIM1_NAND_TADLE(0x32) | \
+					FTIM1_NAND_TWBE(0x39)  | \
+					FTIM1_NAND_TRR(0x0e)   | \
+					FTIM1_NAND_TRP(0x18))
+#define CONFIG_SYS_NAND_FTIM2		(FTIM2_NAND_TRAD(0x0f) | \
+					FTIM2_NAND_TREH(0x0a) | \
+					FTIM2_NAND_TWHRE(0x1e))
+#define CONFIG_SYS_NAND_FTIM3		0x0
+
+#define CONFIG_SYS_NAND_BASE_LIST	{ CONFIG_SYS_NAND_BASE }
+#define CONFIG_SYS_MAX_NAND_DEVICE	1
+#define CONFIG_MTD_NAND_VERIFY_WRITE
+#define CONFIG_CMD_NAND
+
+#define CONFIG_SYS_NAND_BLOCK_SIZE	(128 * 1024)
+
+#define CONFIG_SYS_CSPR0_EXT		CONFIG_SYS_NOR0_CSPR_EXT
+#define CONFIG_SYS_CSPR0		CONFIG_SYS_NOR0_CSPR_EARLY
+#define CONFIG_SYS_CSPR0_FINAL		CONFIG_SYS_NOR0_CSPR
+#define CONFIG_SYS_AMASK0		CONFIG_SYS_NOR_AMASK
+#define CONFIG_SYS_CSOR0		CONFIG_SYS_NOR_CSOR
+#define CONFIG_SYS_CS0_FTIM0		CONFIG_SYS_NOR_FTIM0
+#define CONFIG_SYS_CS0_FTIM1		CONFIG_SYS_NOR_FTIM1
+#define CONFIG_SYS_CS0_FTIM2		CONFIG_SYS_NOR_FTIM2
+#define CONFIG_SYS_CS0_FTIM3		CONFIG_SYS_NOR_FTIM3
+#define CONFIG_SYS_CSPR1_EXT		CONFIG_SYS_NAND_CSPR_EXT
+#define CONFIG_SYS_CSPR1		CONFIG_SYS_NAND_CSPR
+#define CONFIG_SYS_AMASK1		CONFIG_SYS_NAND_AMASK
+#define CONFIG_SYS_CSOR1		CONFIG_SYS_NAND_CSOR
+#define CONFIG_SYS_CS1_FTIM0		CONFIG_SYS_NAND_FTIM0
+#define CONFIG_SYS_CS1_FTIM1		CONFIG_SYS_NAND_FTIM1
+#define CONFIG_SYS_CS1_FTIM2		CONFIG_SYS_NAND_FTIM2
+#define CONFIG_SYS_CS1_FTIM3		CONFIG_SYS_NAND_FTIM3
+
+/*  MMC  */
+#define CONFIG_MMC
+#ifdef CONFIG_MMC
+#define CONFIG_CMD_MMC
+#define CONFIG_FSL_ESDHC
+#define CONFIG_SYS_FSL_MMC_HAS_CAPBLT_VS33
+#define CONFIG_GENERIC_MMC
+#define CONFIG_CMD_FAT
+#define CONFIG_DOS_PARTITION
+#endif
+
+/* Debug Server firmware */
+#define CONFIG_SYS_DEBUG_SERVER_FW_IN_NOR
+#define CONFIG_SYS_DEBUG_SERVER_FW_ADDR	0x580C00000ULL
+
+/* MC firmware */
+#define CONFIG_SYS_LS_MC_FW_IN_NOR
+#define CONFIG_SYS_LS_MC_FW_ADDR	0x580200000ULL
+
+#define CONFIG_SYS_LS_MC_DPL_IN_NOR
+#define CONFIG_SYS_LS_MC_DPL_ADDR	0x5806C0000ULL
+
+#define CONFIG_SYS_LS_MC_DPC_IN_NOR
+#define CONFIG_SYS_LS_MC_DPC_ADDR	0x5806F8000ULL
+
+#define CONFIG_SYS_LS_MC_BOOT_TIMEOUT_MS 200000
+
+/* Store environment at top of flash */
+#define CONFIG_ENV_IS_NOWHERE		1
+#define CONFIG_ENV_SIZE			0x1000
+
+#endif /* __LS2_SIMU_H */
diff --git a/include/configs/ls2080aqds.h b/include/configs/ls2080aqds.h
new file mode 100644
index 0000000..625e997
--- /dev/null
+++ b/include/configs/ls2080aqds.h
@@ -0,0 +1,384 @@
+/*
+ * Copyright 2015 Freescale Semiconductor
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __LS2_QDS_H
+#define __LS2_QDS_H
+
+#include "ls2080a_common.h"
+
+#define CONFIG_DISPLAY_BOARDINFO
+
+#ifndef __ASSEMBLY__
+unsigned long get_board_sys_clk(void);
+unsigned long get_board_ddr_clk(void);
+#endif
+
+#define CONFIG_SYS_CLK_FREQ		get_board_sys_clk()
+#define CONFIG_DDR_CLK_FREQ		get_board_ddr_clk()
+#define COUNTER_FREQUENCY_REAL		(CONFIG_SYS_CLK_FREQ/4)
+
+#define CONFIG_DDR_SPD
+#define CONFIG_DDR_ECC
+#define CONFIG_ECC_INIT_VIA_DDRCONTROLLER
+#define CONFIG_MEM_INIT_VALUE		0xdeadbeef
+#define SPD_EEPROM_ADDRESS1	0x51
+#define SPD_EEPROM_ADDRESS2	0x52
+#define SPD_EEPROM_ADDRESS3	0x53
+#define SPD_EEPROM_ADDRESS4	0x54
+#define SPD_EEPROM_ADDRESS5	0x55
+#define SPD_EEPROM_ADDRESS6	0x56	/* dummy address */
+#define SPD_EEPROM_ADDRESS	SPD_EEPROM_ADDRESS1
+#define CONFIG_SYS_SPD_BUS_NUM	0	/* SPD on I2C bus 0 */
+#define CONFIG_DIMM_SLOTS_PER_CTLR		2
+#define CONFIG_CHIP_SELECTS_PER_CTRL		4
+#ifdef CONFIG_SYS_FSL_HAS_DP_DDR
+#define CONFIG_DP_DDR_DIMM_SLOTS_PER_CTLR	1
+#endif
+#define CONFIG_FSL_DDR_BIST	/* enable built-in memory test */
+
+/* undefined CONFIG_FSL_DDR_SYNC_REFRESH for simulator */
+
+#define CONFIG_SYS_NOR0_CSPR_EXT	(0x0)
+#define CONFIG_SYS_NOR_AMASK		IFC_AMASK(128*1024*1024)
+#define CONFIG_SYS_NOR_AMASK_EARLY	IFC_AMASK(64*1024*1024)
+
+#define CONFIG_SYS_NOR0_CSPR					\
+	(CSPR_PHYS_ADDR(CONFIG_SYS_FLASH_BASE_PHYS)		| \
+	CSPR_PORT_SIZE_16					| \
+	CSPR_MSEL_NOR						| \
+	CSPR_V)
+#define CONFIG_SYS_NOR0_CSPR_EARLY				\
+	(CSPR_PHYS_ADDR(CONFIG_SYS_FLASH_BASE_PHYS_EARLY)	| \
+	CSPR_PORT_SIZE_16					| \
+	CSPR_MSEL_NOR						| \
+	CSPR_V)
+#define CONFIG_SYS_NOR1_CSPR					\
+	(CSPR_PHYS_ADDR(CONFIG_SYS_FLASH1_BASE_PHYS)		| \
+	CSPR_PORT_SIZE_16					| \
+	CSPR_MSEL_NOR						| \
+	CSPR_V)
+#define CONFIG_SYS_NOR1_CSPR_EARLY				\
+	(CSPR_PHYS_ADDR(CONFIG_SYS_FLASH1_BASE_PHYS_EARLY)	| \
+	CSPR_PORT_SIZE_16					| \
+	CSPR_MSEL_NOR						| \
+	CSPR_V)
+#define CONFIG_SYS_NOR_CSOR	CSOR_NOR_ADM_SHIFT(12)
+#define CONFIG_SYS_NOR_FTIM0	(FTIM0_NOR_TACSE(0x4) | \
+				FTIM0_NOR_TEADC(0x5) | \
+				FTIM0_NOR_TEAHC(0x5))
+#define CONFIG_SYS_NOR_FTIM1	(FTIM1_NOR_TACO(0x35) | \
+				FTIM1_NOR_TRAD_NOR(0x1a) |\
+				FTIM1_NOR_TSEQRAD_NOR(0x13))
+#define CONFIG_SYS_NOR_FTIM2	(FTIM2_NOR_TCS(0x4) | \
+				FTIM2_NOR_TCH(0x4) | \
+				FTIM2_NOR_TWPH(0x0E) | \
+				FTIM2_NOR_TWP(0x1c))
+#define CONFIG_SYS_NOR_FTIM3	0x04000000
+#define CONFIG_SYS_IFC_CCR	0x01000000
+
+#ifndef CONFIG_SYS_NO_FLASH
+#define CONFIG_FLASH_CFI_DRIVER
+#define CONFIG_SYS_FLASH_CFI
+#define CONFIG_SYS_FLASH_USE_BUFFER_WRITE
+#define CONFIG_SYS_FLASH_QUIET_TEST
+#define CONFIG_FLASH_SHOW_PROGRESS	45 /* count down from 45/5: 9..1 */
+
+#define CONFIG_SYS_MAX_FLASH_BANKS	2	/* number of banks */
+#define CONFIG_SYS_MAX_FLASH_SECT	1024	/* sectors per device */
+#define CONFIG_SYS_FLASH_ERASE_TOUT	60000	/* Flash Erase Timeout (ms) */
+#define CONFIG_SYS_FLASH_WRITE_TOUT	500	/* Flash Write Timeout (ms) */
+
+#define CONFIG_SYS_FLASH_EMPTY_INFO
+#define CONFIG_SYS_FLASH_BANKS_LIST	{ CONFIG_SYS_FLASH_BASE,\
+					 CONFIG_SYS_FLASH_BASE + 0x40000000}
+#endif
+
+#define CONFIG_NAND_FSL_IFC
+#define CONFIG_SYS_NAND_MAX_ECCPOS	256
+#define CONFIG_SYS_NAND_MAX_OOBFREE	2
+
+
+#define CONFIG_SYS_NAND_CSPR_EXT	(0x0)
+#define CONFIG_SYS_NAND_CSPR	(CSPR_PHYS_ADDR(CONFIG_SYS_NAND_BASE_PHYS) \
+				| CSPR_PORT_SIZE_8 /* Port Size = 8 bit */ \
+				| CSPR_MSEL_NAND	/* MSEL = NAND */ \
+				| CSPR_V)
+#define CONFIG_SYS_NAND_AMASK	IFC_AMASK(64 * 1024)
+
+#define CONFIG_SYS_NAND_CSOR    (CSOR_NAND_ECC_ENC_EN   /* ECC on encode */ \
+				| CSOR_NAND_ECC_DEC_EN  /* ECC on decode */ \
+				| CSOR_NAND_ECC_MODE_4  /* 4-bit ECC */ \
+				| CSOR_NAND_RAL_3	/* RAL = 3Byes */ \
+				| CSOR_NAND_PGS_2K	/* Page Size = 2K */ \
+				| CSOR_NAND_SPRZ_64/* Spare size = 64 */ \
+				| CSOR_NAND_PB(64))	/*Pages Per Block = 64*/
+
+#define CONFIG_SYS_NAND_ONFI_DETECTION
+
+/* ONFI NAND Flash mode0 Timing Params */
+#define CONFIG_SYS_NAND_FTIM0		(FTIM0_NAND_TCCST(0x07) | \
+					FTIM0_NAND_TWP(0x18)   | \
+					FTIM0_NAND_TWCHT(0x07) | \
+					FTIM0_NAND_TWH(0x0a))
+#define CONFIG_SYS_NAND_FTIM1		(FTIM1_NAND_TADLE(0x32) | \
+					FTIM1_NAND_TWBE(0x39)  | \
+					FTIM1_NAND_TRR(0x0e)   | \
+					FTIM1_NAND_TRP(0x18))
+#define CONFIG_SYS_NAND_FTIM2		(FTIM2_NAND_TRAD(0x0f) | \
+					FTIM2_NAND_TREH(0x0a) | \
+					FTIM2_NAND_TWHRE(0x1e))
+#define CONFIG_SYS_NAND_FTIM3		0x0
+
+#define CONFIG_SYS_NAND_BASE_LIST	{ CONFIG_SYS_NAND_BASE }
+#define CONFIG_SYS_MAX_NAND_DEVICE	1
+#define CONFIG_MTD_NAND_VERIFY_WRITE
+#define CONFIG_CMD_NAND
+
+#define CONFIG_SYS_NAND_BLOCK_SIZE	(128 * 1024)
+
+#define CONFIG_FSL_QIXIS	/* use common QIXIS code */
+#define QIXIS_LBMAP_SWITCH		0x06
+#define QIXIS_LBMAP_MASK		0x0f
+#define QIXIS_LBMAP_SHIFT		0
+#define QIXIS_LBMAP_DFLTBANK		0x00
+#define QIXIS_LBMAP_ALTBANK		0x04
+#define QIXIS_LBMAP_NAND		0x09
+#define QIXIS_RST_CTL_RESET		0x31
+#define QIXIS_RCFG_CTL_RECONFIG_IDLE	0x20
+#define QIXIS_RCFG_CTL_RECONFIG_START	0x21
+#define QIXIS_RCFG_CTL_WATCHDOG_ENBLE	0x08
+#define QIXIS_RCW_SRC_NAND		0x107
+#define	QIXIS_RST_FORCE_MEM		0x01
+
+#define CONFIG_SYS_CSPR3_EXT	(0x0)
+#define CONFIG_SYS_CSPR3	(CSPR_PHYS_ADDR(QIXIS_BASE_PHYS_EARLY) \
+				| CSPR_PORT_SIZE_8 \
+				| CSPR_MSEL_GPCM \
+				| CSPR_V)
+#define CONFIG_SYS_CSPR3_FINAL	(CSPR_PHYS_ADDR(QIXIS_BASE_PHYS) \
+				| CSPR_PORT_SIZE_8 \
+				| CSPR_MSEL_GPCM \
+				| CSPR_V)
+
+#define CONFIG_SYS_AMASK3	IFC_AMASK(64*1024)
+#define CONFIG_SYS_CSOR3	CSOR_GPCM_ADM_SHIFT(12)
+/* QIXIS Timing parameters for IFC CS3 */
+#define CONFIG_SYS_CS3_FTIM0		(FTIM0_GPCM_TACSE(0x0e) | \
+					FTIM0_GPCM_TEADC(0x0e) | \
+					FTIM0_GPCM_TEAHC(0x0e))
+#define CONFIG_SYS_CS3_FTIM1		(FTIM1_GPCM_TACO(0xff) | \
+					FTIM1_GPCM_TRAD(0x3f))
+#define CONFIG_SYS_CS3_FTIM2		(FTIM2_GPCM_TCS(0xf) | \
+					FTIM2_GPCM_TCH(0xf) | \
+					FTIM2_GPCM_TWP(0x3E))
+#define CONFIG_SYS_CS3_FTIM3		0x0
+
+#if defined(CONFIG_SPL) && defined(CONFIG_NAND)
+#define CONFIG_SYS_CSPR1_EXT		CONFIG_SYS_NOR0_CSPR_EXT
+#define CONFIG_SYS_CSPR1		CONFIG_SYS_NOR0_CSPR_EARLY
+#define CONFIG_SYS_CSPR1_FINAL		CONFIG_SYS_NOR0_CSPR
+#define CONFIG_SYS_AMASK1		CONFIG_SYS_NOR_AMASK
+#define CONFIG_SYS_CSOR1		CONFIG_SYS_NOR_CSOR
+#define CONFIG_SYS_CS1_FTIM0		CONFIG_SYS_NOR_FTIM0
+#define CONFIG_SYS_CS1_FTIM1		CONFIG_SYS_NOR_FTIM1
+#define CONFIG_SYS_CS1_FTIM2		CONFIG_SYS_NOR_FTIM2
+#define CONFIG_SYS_CS1_FTIM3		CONFIG_SYS_NOR_FTIM3
+#define CONFIG_SYS_CSPR2_EXT		CONFIG_SYS_NOR0_CSPR_EXT
+#define CONFIG_SYS_CSPR2		CONFIG_SYS_NOR1_CSPR_EARLY
+#define CONFIG_SYS_CSPR2_FINAL		CONFIG_SYS_NOR1_CSPR
+#define CONFIG_SYS_AMASK2		CONFIG_SYS_NOR_AMASK_EARLY
+#define CONFIG_SYS_AMASK2_FINAL		CONFIG_SYS_NOR_AMASK
+#define CONFIG_SYS_CSOR2		CONFIG_SYS_NOR_CSOR
+#define CONFIG_SYS_CS2_FTIM0		CONFIG_SYS_NOR_FTIM0
+#define CONFIG_SYS_CS2_FTIM1		CONFIG_SYS_NOR_FTIM1
+#define CONFIG_SYS_CS2_FTIM2		CONFIG_SYS_NOR_FTIM2
+#define CONFIG_SYS_CS2_FTIM3		CONFIG_SYS_NOR_FTIM3
+#define CONFIG_SYS_CSPR0_EXT		CONFIG_SYS_NAND_CSPR_EXT
+#define CONFIG_SYS_CSPR0		CONFIG_SYS_NAND_CSPR
+#define CONFIG_SYS_AMASK0		CONFIG_SYS_NAND_AMASK
+#define CONFIG_SYS_CSOR0		CONFIG_SYS_NAND_CSOR
+#define CONFIG_SYS_CS0_FTIM0		CONFIG_SYS_NAND_FTIM0
+#define CONFIG_SYS_CS0_FTIM1		CONFIG_SYS_NAND_FTIM1
+#define CONFIG_SYS_CS0_FTIM2		CONFIG_SYS_NAND_FTIM2
+#define CONFIG_SYS_CS0_FTIM3		CONFIG_SYS_NAND_FTIM3
+
+#define CONFIG_ENV_IS_IN_NAND
+#define CONFIG_ENV_OFFSET		(896 * 1024)
+#define CONFIG_ENV_SECT_SIZE		0x20000
+#define CONFIG_ENV_SIZE			0x2000
+#define CONFIG_SPL_PAD_TO		0x20000
+#define CONFIG_SYS_NAND_U_BOOT_OFFS	(256 * 1024)
+#define CONFIG_SYS_NAND_U_BOOT_SIZE	(512 * 1024)
+#else
+#define CONFIG_SYS_CSPR0_EXT		CONFIG_SYS_NOR0_CSPR_EXT
+#define CONFIG_SYS_CSPR0		CONFIG_SYS_NOR0_CSPR_EARLY
+#define CONFIG_SYS_CSPR0_FINAL		CONFIG_SYS_NOR0_CSPR
+#define CONFIG_SYS_AMASK0		CONFIG_SYS_NOR_AMASK
+#define CONFIG_SYS_CSOR0		CONFIG_SYS_NOR_CSOR
+#define CONFIG_SYS_CS0_FTIM0		CONFIG_SYS_NOR_FTIM0
+#define CONFIG_SYS_CS0_FTIM1		CONFIG_SYS_NOR_FTIM1
+#define CONFIG_SYS_CS0_FTIM2		CONFIG_SYS_NOR_FTIM2
+#define CONFIG_SYS_CS0_FTIM3		CONFIG_SYS_NOR_FTIM3
+#define CONFIG_SYS_CSPR1_EXT		CONFIG_SYS_NOR0_CSPR_EXT
+#define CONFIG_SYS_CSPR1		CONFIG_SYS_NOR1_CSPR_EARLY
+#define CONFIG_SYS_CSPR1_FINAL		CONFIG_SYS_NOR1_CSPR
+#define CONFIG_SYS_AMASK1		CONFIG_SYS_NOR_AMASK_EARLY
+#define CONFIG_SYS_AMASK1_FINAL		CONFIG_SYS_NOR_AMASK
+#define CONFIG_SYS_CSOR1		CONFIG_SYS_NOR_CSOR
+#define CONFIG_SYS_CS1_FTIM0		CONFIG_SYS_NOR_FTIM0
+#define CONFIG_SYS_CS1_FTIM1		CONFIG_SYS_NOR_FTIM1
+#define CONFIG_SYS_CS1_FTIM2		CONFIG_SYS_NOR_FTIM2
+#define CONFIG_SYS_CS1_FTIM3		CONFIG_SYS_NOR_FTIM3
+#define CONFIG_SYS_CSPR2_EXT		CONFIG_SYS_NAND_CSPR_EXT
+#define CONFIG_SYS_CSPR2		CONFIG_SYS_NAND_CSPR
+#define CONFIG_SYS_AMASK2		CONFIG_SYS_NAND_AMASK
+#define CONFIG_SYS_CSOR2		CONFIG_SYS_NAND_CSOR
+#define CONFIG_SYS_CS2_FTIM0		CONFIG_SYS_NAND_FTIM0
+#define CONFIG_SYS_CS2_FTIM1		CONFIG_SYS_NAND_FTIM1
+#define CONFIG_SYS_CS2_FTIM2		CONFIG_SYS_NAND_FTIM2
+#define CONFIG_SYS_CS2_FTIM3		CONFIG_SYS_NAND_FTIM3
+
+#define CONFIG_ENV_IS_IN_FLASH
+#define CONFIG_ENV_ADDR			(CONFIG_SYS_FLASH_BASE + 0x200000)
+#define CONFIG_ENV_SECT_SIZE		0x20000
+#define CONFIG_ENV_SIZE			0x2000
+#endif
+
+/* Debug Server firmware */
+#define CONFIG_SYS_DEBUG_SERVER_FW_IN_NOR
+#define CONFIG_SYS_DEBUG_SERVER_FW_ADDR	0x580D00000ULL
+
+#define CONFIG_SYS_LS_MC_BOOT_TIMEOUT_MS 5000
+
+/*
+ * I2C
+ */
+#define I2C_MUX_PCA_ADDR		0x77
+#define I2C_MUX_PCA_ADDR_PRI		0x77 /* Primary Mux*/
+
+/* I2C bus multiplexer */
+#define I2C_MUX_CH_DEFAULT      0x8
+
+/* SPI */
+#ifdef CONFIG_FSL_DSPI
+#define CONFIG_CMD_SF
+#define CONFIG_SPI_FLASH
+#define CONFIG_SPI_FLASH_STMICRO
+#define CONFIG_SPI_FLASH_SST
+#define CONFIG_SPI_FLASH_EON
+#endif
+
+/*
+ * MMC
+ */
+#ifdef CONFIG_MMC
+#define CONFIG_ESDHC_DETECT_QUIRK ((readb(QIXIS_BASE + QIXIS_STAT_PRES1) & \
+	QIXIS_SDID_MASK) != QIXIS_ESDHC_NO_ADAPTER)
+#endif
+
+/*
+ * RTC configuration
+ */
+#define RTC
+#define CONFIG_RTC_DS3231               1
+#define CONFIG_SYS_I2C_RTC_ADDR         0x68
+#define CONFIG_CMD_DATE
+
+/* EEPROM */
+#define CONFIG_ID_EEPROM
+#define CONFIG_CMD_EEPROM
+#define CONFIG_SYS_I2C_EEPROM_NXID
+#define CONFIG_SYS_EEPROM_BUS_NUM	0
+#define CONFIG_SYS_I2C_EEPROM_ADDR	0x57
+#define CONFIG_SYS_I2C_EEPROM_ADDR_LEN	1
+#define CONFIG_SYS_EEPROM_PAGE_WRITE_BITS 3
+#define CONFIG_SYS_EEPROM_PAGE_WRITE_DELAY_MS 5
+
+#define CONFIG_FSL_MEMAC
+#define CONFIG_PCI		/* Enable PCIE */
+#define CONFIG_PCIE_LAYERSCAPE	/* Use common FSL Layerscape PCIe code */
+
+#ifdef CONFIG_PCI
+#define CONFIG_PCI_PNP
+#define CONFIG_PCI_SCAN_SHOW
+#define CONFIG_CMD_PCI
+#endif
+
+/*  MMC  */
+#define CONFIG_MMC
+#ifdef CONFIG_MMC
+#define CONFIG_CMD_MMC
+#define CONFIG_FSL_ESDHC
+#define CONFIG_SYS_FSL_MMC_HAS_CAPBLT_VS33
+#define CONFIG_GENERIC_MMC
+#define CONFIG_CMD_FAT
+#define CONFIG_DOS_PARTITION
+#endif
+
+/* Initial environment variables */
+#undef CONFIG_EXTRA_ENV_SETTINGS
+#define CONFIG_EXTRA_ENV_SETTINGS		\
+	"hwconfig=fsl_ddr:bank_intlv=auto\0"	\
+	"loadaddr=0x80100000\0"			\
+	"kernel_addr=0x100000\0"		\
+	"ramdisk_addr=0x800000\0"		\
+	"ramdisk_size=0x2000000\0"		\
+	"fdt_high=0xa0000000\0"			\
+	"initrd_high=0xffffffffffffffff\0"	\
+	"kernel_start=0x581100000\0"		\
+	"kernel_load=0xa0000000\0"		\
+	"kernel_size=0x28000000\0"
+
+#ifdef CONFIG_FSL_MC_ENET
+#define CONFIG_FSL_MEMAC
+#define	CONFIG_PHYLIB
+#define CONFIG_PHYLIB_10G
+#define	CONFIG_CMD_MII
+#define CONFIG_PHY_VITESSE
+#define CONFIG_PHY_REALTEK
+#define CONFIG_PHY_TERANETICS
+#define SGMII_CARD_PORT1_PHY_ADDR 0x1C
+#define SGMII_CARD_PORT2_PHY_ADDR 0x1d
+#define SGMII_CARD_PORT3_PHY_ADDR 0x1E
+#define SGMII_CARD_PORT4_PHY_ADDR 0x1F
+
+#define XQSGMII_CARD_PHY1_PORT0_ADDR 0x0
+#define XQSGMII_CARD_PHY1_PORT1_ADDR 0x1
+#define XQSGMII_CARD_PHY1_PORT2_ADDR 0x2
+#define XQSGMII_CARD_PHY1_PORT3_ADDR 0x3
+#define XQSGMII_CARD_PHY2_PORT0_ADDR 0x4
+#define XQSGMII_CARD_PHY2_PORT1_ADDR 0x5
+#define XQSGMII_CARD_PHY2_PORT2_ADDR 0x6
+#define XQSGMII_CARD_PHY2_PORT3_ADDR 0x7
+#define XQSGMII_CARD_PHY3_PORT0_ADDR 0x8
+#define XQSGMII_CARD_PHY3_PORT1_ADDR 0x9
+#define XQSGMII_CARD_PHY3_PORT2_ADDR 0xa
+#define XQSGMII_CARD_PHY3_PORT3_ADDR 0xb
+#define XQSGMII_CARD_PHY4_PORT0_ADDR 0xc
+#define XQSGMII_CARD_PHY4_PORT1_ADDR 0xd
+#define XQSGMII_CARD_PHY4_PORT2_ADDR 0xe
+#define XQSGMII_CARD_PHY4_PORT3_ADDR 0xf
+
+#define CONFIG_MII		/* MII PHY management */
+#define CONFIG_ETHPRIME		"DPNI1"
+#define CONFIG_PHY_GIGE		/* Include GbE speed/duplex detection */
+
+#endif
+
+/*
+ * USB
+ */
+#define CONFIG_HAS_FSL_XHCI_USB
+#define CONFIG_USB_XHCI
+#define CONFIG_USB_XHCI_FSL
+#define CONFIG_USB_XHCI_DWC3
+#define CONFIG_USB_MAX_CONTROLLER_COUNT		2
+#define CONFIG_SYS_USB_XHCI_MAX_ROOT_PORTS	2
+#define CONFIG_CMD_USB
+#define CONFIG_USB_STORAGE
+#define CONFIG_CMD_EXT2
+
+#endif /* __LS2_QDS_H */
diff --git a/include/configs/ls2080ardb.h b/include/configs/ls2080ardb.h
new file mode 100644
index 0000000..90f97d5
--- /dev/null
+++ b/include/configs/ls2080ardb.h
@@ -0,0 +1,345 @@
+/*
+ * Copyright 2015 Freescale Semiconductor
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __LS2_RDB_H
+#define __LS2_RDB_H
+
+#include "ls2080a_common.h"
+
+#undef CONFIG_CONS_INDEX
+#define CONFIG_CONS_INDEX       2
+
+#define CONFIG_DISPLAY_BOARDINFO
+
+#ifndef __ASSEMBLY__
+unsigned long get_board_sys_clk(void);
+#endif
+
+#define CONFIG_SYS_CLK_FREQ		get_board_sys_clk()
+#define CONFIG_DDR_CLK_FREQ		133333333
+#define COUNTER_FREQUENCY_REAL		(CONFIG_SYS_CLK_FREQ/4)
+
+#define CONFIG_DDR_SPD
+#define CONFIG_DDR_ECC
+#define CONFIG_ECC_INIT_VIA_DDRCONTROLLER
+#define CONFIG_MEM_INIT_VALUE		0xdeadbeef
+#define SPD_EEPROM_ADDRESS1	0x51
+#define SPD_EEPROM_ADDRESS2	0x52
+#define SPD_EEPROM_ADDRESS3	0x53
+#define SPD_EEPROM_ADDRESS4	0x54
+#define SPD_EEPROM_ADDRESS5	0x55
+#define SPD_EEPROM_ADDRESS6	0x56	/* dummy address */
+#define SPD_EEPROM_ADDRESS	SPD_EEPROM_ADDRESS1
+#define CONFIG_SYS_SPD_BUS_NUM	0	/* SPD on I2C bus 0 */
+#define CONFIG_DIMM_SLOTS_PER_CTLR		2
+#define CONFIG_CHIP_SELECTS_PER_CTRL		4
+#ifdef CONFIG_SYS_FSL_HAS_DP_DDR
+#define CONFIG_DP_DDR_DIMM_SLOTS_PER_CTLR	1
+#endif
+#define CONFIG_FSL_DDR_BIST	/* enable built-in memory test */
+
+/* undefined CONFIG_FSL_DDR_SYNC_REFRESH for simulator */
+
+#define CONFIG_SYS_NOR0_CSPR_EXT	(0x0)
+#define CONFIG_SYS_NOR_AMASK		IFC_AMASK(128*1024*1024)
+#define CONFIG_SYS_NOR_AMASK_EARLY	IFC_AMASK(64*1024*1024)
+
+#define CONFIG_SYS_NOR0_CSPR					\
+	(CSPR_PHYS_ADDR(CONFIG_SYS_FLASH_BASE_PHYS)		| \
+	CSPR_PORT_SIZE_16					| \
+	CSPR_MSEL_NOR						| \
+	CSPR_V)
+#define CONFIG_SYS_NOR0_CSPR_EARLY				\
+	(CSPR_PHYS_ADDR(CONFIG_SYS_FLASH_BASE_PHYS_EARLY)	| \
+	CSPR_PORT_SIZE_16					| \
+	CSPR_MSEL_NOR						| \
+	CSPR_V)
+#define CONFIG_SYS_NOR_CSOR	CSOR_NOR_ADM_SHIFT(12)
+#define CONFIG_SYS_NOR_FTIM0	(FTIM0_NOR_TACSE(0x4) | \
+				FTIM0_NOR_TEADC(0x5) | \
+				FTIM0_NOR_TEAHC(0x5))
+#define CONFIG_SYS_NOR_FTIM1	(FTIM1_NOR_TACO(0x35) | \
+				FTIM1_NOR_TRAD_NOR(0x1a) |\
+				FTIM1_NOR_TSEQRAD_NOR(0x13))
+#define CONFIG_SYS_NOR_FTIM2	(FTIM2_NOR_TCS(0x4) | \
+				FTIM2_NOR_TCH(0x4) | \
+				FTIM2_NOR_TWPH(0x0E) | \
+				FTIM2_NOR_TWP(0x1c))
+#define CONFIG_SYS_NOR_FTIM3	0x04000000
+#define CONFIG_SYS_IFC_CCR	0x01000000
+
+#ifndef CONFIG_SYS_NO_FLASH
+#define CONFIG_FLASH_CFI_DRIVER
+#define CONFIG_SYS_FLASH_CFI
+#define CONFIG_SYS_FLASH_USE_BUFFER_WRITE
+#define CONFIG_SYS_FLASH_QUIET_TEST
+#define CONFIG_FLASH_SHOW_PROGRESS	45 /* count down from 45/5: 9..1 */
+
+#define CONFIG_SYS_MAX_FLASH_BANKS	1	/* number of banks */
+#define CONFIG_SYS_MAX_FLASH_SECT	1024	/* sectors per device */
+#define CONFIG_SYS_FLASH_ERASE_TOUT	60000	/* Flash Erase Timeout (ms) */
+#define CONFIG_SYS_FLASH_WRITE_TOUT	500	/* Flash Write Timeout (ms) */
+
+#define CONFIG_SYS_FLASH_EMPTY_INFO
+#define CONFIG_SYS_FLASH_BANKS_LIST	{ CONFIG_SYS_FLASH_BASE,\
+					 CONFIG_SYS_FLASH_BASE + 0x40000000}
+#endif
+
+#define CONFIG_NAND_FSL_IFC
+#define CONFIG_SYS_NAND_MAX_ECCPOS	256
+#define CONFIG_SYS_NAND_MAX_OOBFREE	2
+
+
+#define CONFIG_SYS_NAND_CSPR_EXT	(0x0)
+#define CONFIG_SYS_NAND_CSPR	(CSPR_PHYS_ADDR(CONFIG_SYS_NAND_BASE_PHYS) \
+				| CSPR_PORT_SIZE_8 /* Port Size = 8 bit */ \
+				| CSPR_MSEL_NAND	/* MSEL = NAND */ \
+				| CSPR_V)
+#define CONFIG_SYS_NAND_AMASK	IFC_AMASK(64 * 1024)
+
+#define CONFIG_SYS_NAND_CSOR    (CSOR_NAND_ECC_ENC_EN   /* ECC on encode */ \
+				| CSOR_NAND_ECC_DEC_EN  /* ECC on decode */ \
+				| CSOR_NAND_ECC_MODE_4  /* 4-bit ECC */ \
+				| CSOR_NAND_RAL_3	/* RAL = 3Byes */ \
+				| CSOR_NAND_PGS_4K	/* Page Size = 4K */ \
+				| CSOR_NAND_SPRZ_224	/* Spare size = 224 */ \
+				| CSOR_NAND_PB(128))	/* Pages Per Block 128*/
+
+#define CONFIG_SYS_NAND_ONFI_DETECTION
+
+/* ONFI NAND Flash mode0 Timing Params */
+#define CONFIG_SYS_NAND_FTIM0		(FTIM0_NAND_TCCST(0x0e) | \
+					FTIM0_NAND_TWP(0x30)   | \
+					FTIM0_NAND_TWCHT(0x0e) | \
+					FTIM0_NAND_TWH(0x14))
+#define CONFIG_SYS_NAND_FTIM1		(FTIM1_NAND_TADLE(0x64) | \
+					FTIM1_NAND_TWBE(0xab)  | \
+					FTIM1_NAND_TRR(0x1c)   | \
+					FTIM1_NAND_TRP(0x30))
+#define CONFIG_SYS_NAND_FTIM2		(FTIM2_NAND_TRAD(0x1e) | \
+					FTIM2_NAND_TREH(0x14) | \
+					FTIM2_NAND_TWHRE(0x3c))
+#define CONFIG_SYS_NAND_FTIM3		0x0
+
+#define CONFIG_SYS_NAND_BASE_LIST	{ CONFIG_SYS_NAND_BASE }
+#define CONFIG_SYS_MAX_NAND_DEVICE	1
+#define CONFIG_MTD_NAND_VERIFY_WRITE
+#define CONFIG_CMD_NAND
+
+#define CONFIG_SYS_NAND_BLOCK_SIZE	(512 * 1024)
+
+#define CONFIG_FSL_QIXIS	/* use common QIXIS code */
+#define QIXIS_LBMAP_SWITCH		0x06
+#define QIXIS_LBMAP_MASK		0x0f
+#define QIXIS_LBMAP_SHIFT		0
+#define QIXIS_LBMAP_DFLTBANK		0x00
+#define QIXIS_LBMAP_ALTBANK		0x04
+#define QIXIS_LBMAP_NAND		0x09
+#define QIXIS_RST_CTL_RESET		0x31
+#define QIXIS_RST_CTL_RESET_EN		0x30
+#define QIXIS_RCFG_CTL_RECONFIG_IDLE	0x20
+#define QIXIS_RCFG_CTL_RECONFIG_START	0x21
+#define QIXIS_RCFG_CTL_WATCHDOG_ENBLE	0x08
+#define QIXIS_RCW_SRC_NAND		0x119
+#define	QIXIS_RST_FORCE_MEM		0x01
+
+#define CONFIG_SYS_CSPR3_EXT	(0x0)
+#define CONFIG_SYS_CSPR3	(CSPR_PHYS_ADDR(QIXIS_BASE_PHYS_EARLY) \
+				| CSPR_PORT_SIZE_8 \
+				| CSPR_MSEL_GPCM \
+				| CSPR_V)
+#define CONFIG_SYS_CSPR3_FINAL	(CSPR_PHYS_ADDR(QIXIS_BASE_PHYS) \
+				| CSPR_PORT_SIZE_8 \
+				| CSPR_MSEL_GPCM \
+				| CSPR_V)
+
+#define CONFIG_SYS_AMASK3	IFC_AMASK(64*1024)
+#define CONFIG_SYS_CSOR3	CSOR_GPCM_ADM_SHIFT(12)
+/* QIXIS Timing parameters for IFC CS3 */
+#define CONFIG_SYS_CS3_FTIM0		(FTIM0_GPCM_TACSE(0x0e) | \
+					FTIM0_GPCM_TEADC(0x0e) | \
+					FTIM0_GPCM_TEAHC(0x0e))
+#define CONFIG_SYS_CS3_FTIM1		(FTIM1_GPCM_TACO(0xff) | \
+					FTIM1_GPCM_TRAD(0x3f))
+#define CONFIG_SYS_CS3_FTIM2		(FTIM2_GPCM_TCS(0xf) | \
+					FTIM2_GPCM_TCH(0xf) | \
+					FTIM2_GPCM_TWP(0x3E))
+#define CONFIG_SYS_CS3_FTIM3		0x0
+
+#if defined(CONFIG_SPL) && defined(CONFIG_NAND)
+#define CONFIG_SYS_CSPR2_EXT		CONFIG_SYS_NOR0_CSPR_EXT
+#define CONFIG_SYS_CSPR2		CONFIG_SYS_NOR0_CSPR_EARLY
+#define CONFIG_SYS_CSPR2_FINAL		CONFIG_SYS_NOR0_CSPR
+#define CONFIG_SYS_AMASK2		CONFIG_SYS_NOR_AMASK
+#define CONFIG_SYS_CSOR2		CONFIG_SYS_NOR_CSOR
+#define CONFIG_SYS_CS2_FTIM0		CONFIG_SYS_NOR_FTIM0
+#define CONFIG_SYS_CS2_FTIM1		CONFIG_SYS_NOR_FTIM1
+#define CONFIG_SYS_CS2_FTIM2		CONFIG_SYS_NOR_FTIM2
+#define CONFIG_SYS_CS2_FTIM3		CONFIG_SYS_NOR_FTIM3
+#define CONFIG_SYS_CSPR0_EXT		CONFIG_SYS_NAND_CSPR_EXT
+#define CONFIG_SYS_CSPR0		CONFIG_SYS_NAND_CSPR
+#define CONFIG_SYS_AMASK0		CONFIG_SYS_NAND_AMASK
+#define CONFIG_SYS_CSOR0		CONFIG_SYS_NAND_CSOR
+#define CONFIG_SYS_CS0_FTIM0		CONFIG_SYS_NAND_FTIM0
+#define CONFIG_SYS_CS0_FTIM1		CONFIG_SYS_NAND_FTIM1
+#define CONFIG_SYS_CS0_FTIM2		CONFIG_SYS_NAND_FTIM2
+#define CONFIG_SYS_CS0_FTIM3		CONFIG_SYS_NAND_FTIM3
+
+#define CONFIG_ENV_IS_IN_NAND
+#define CONFIG_ENV_OFFSET		(2048 * 1024)
+#define CONFIG_ENV_SECT_SIZE		0x20000
+#define CONFIG_ENV_SIZE			0x2000
+#define CONFIG_SPL_PAD_TO		0x80000
+#define CONFIG_SYS_NAND_U_BOOT_OFFS	(1024 * 1024)
+#define CONFIG_SYS_NAND_U_BOOT_SIZE	(512 * 1024)
+#else
+#define CONFIG_SYS_CSPR0_EXT		CONFIG_SYS_NOR0_CSPR_EXT
+#define CONFIG_SYS_CSPR0		CONFIG_SYS_NOR0_CSPR_EARLY
+#define CONFIG_SYS_CSPR0_FINAL		CONFIG_SYS_NOR0_CSPR
+#define CONFIG_SYS_AMASK0		CONFIG_SYS_NOR_AMASK
+#define CONFIG_SYS_CSOR0		CONFIG_SYS_NOR_CSOR
+#define CONFIG_SYS_CS0_FTIM0		CONFIG_SYS_NOR_FTIM0
+#define CONFIG_SYS_CS0_FTIM1		CONFIG_SYS_NOR_FTIM1
+#define CONFIG_SYS_CS0_FTIM2		CONFIG_SYS_NOR_FTIM2
+#define CONFIG_SYS_CS0_FTIM3		CONFIG_SYS_NOR_FTIM3
+#define CONFIG_SYS_CSPR2_EXT		CONFIG_SYS_NAND_CSPR_EXT
+#define CONFIG_SYS_CSPR2		CONFIG_SYS_NAND_CSPR
+#define CONFIG_SYS_AMASK2		CONFIG_SYS_NAND_AMASK
+#define CONFIG_SYS_CSOR2		CONFIG_SYS_NAND_CSOR
+#define CONFIG_SYS_CS2_FTIM0		CONFIG_SYS_NAND_FTIM0
+#define CONFIG_SYS_CS2_FTIM1		CONFIG_SYS_NAND_FTIM1
+#define CONFIG_SYS_CS2_FTIM2		CONFIG_SYS_NAND_FTIM2
+#define CONFIG_SYS_CS2_FTIM3		CONFIG_SYS_NAND_FTIM3
+
+#define CONFIG_ENV_IS_IN_FLASH
+#define CONFIG_ENV_ADDR			(CONFIG_SYS_FLASH_BASE + 0x200000)
+#define CONFIG_ENV_SECT_SIZE		0x20000
+#define CONFIG_ENV_SIZE			0x2000
+#endif
+
+/* Debug Server firmware */
+#define CONFIG_SYS_DEBUG_SERVER_FW_IN_NOR
+#define CONFIG_SYS_DEBUG_SERVER_FW_ADDR	0x580D00000ULL
+
+#define CONFIG_SYS_LS_MC_BOOT_TIMEOUT_MS 5000
+
+/*
+ * I2C
+ */
+#define I2C_MUX_PCA_ADDR		0x75
+#define I2C_MUX_PCA_ADDR_PRI		0x75 /* Primary Mux*/
+
+/* I2C bus multiplexer */
+#define I2C_MUX_CH_DEFAULT      0x8
+
+/* SPI */
+#ifdef CONFIG_FSL_DSPI
+#define CONFIG_CMD_SF
+#define CONFIG_SPI_FLASH
+#define CONFIG_SPI_FLASH_STMICRO
+#define CONFIG_SPI_FLASH_BAR
+#endif
+
+/*
+ * RTC configuration
+ */
+#define RTC
+#define CONFIG_RTC_DS3231               1
+#define CONFIG_SYS_I2C_RTC_ADDR         0x68
+#define CONFIG_CMD_DATE
+
+/* EEPROM */
+#define CONFIG_ID_EEPROM
+#define CONFIG_CMD_EEPROM
+#define CONFIG_SYS_I2C_EEPROM_NXID
+#define CONFIG_SYS_EEPROM_BUS_NUM	0
+#define CONFIG_SYS_I2C_EEPROM_ADDR	0x57
+#define CONFIG_SYS_I2C_EEPROM_ADDR_LEN	1
+#define CONFIG_SYS_EEPROM_PAGE_WRITE_BITS 3
+#define CONFIG_SYS_EEPROM_PAGE_WRITE_DELAY_MS 5
+
+#define CONFIG_FSL_MEMAC
+#define CONFIG_PCI		/* Enable PCIE */
+#define CONFIG_PCIE_LAYERSCAPE	/* Use common FSL Layerscape PCIe code */
+
+#ifdef CONFIG_PCI
+#define CONFIG_PCI_PNP
+#define CONFIG_PCI_SCAN_SHOW
+#define CONFIG_CMD_PCI
+#endif
+
+/*  MMC  */
+#define CONFIG_MMC
+#ifdef CONFIG_MMC
+#define CONFIG_CMD_MMC
+#define CONFIG_FSL_ESDHC
+#define CONFIG_SYS_FSL_MMC_HAS_CAPBLT_VS33
+#define CONFIG_GENERIC_MMC
+#define CONFIG_CMD_FAT
+#define CONFIG_DOS_PARTITION
+#endif
+
+#define CONFIG_MISC_INIT_R
+
+/*
+ * USB
+ */
+#define CONFIG_HAS_FSL_XHCI_USB
+#define CONFIG_USB_XHCI
+#define CONFIG_USB_XHCI_FSL
+#define CONFIG_USB_XHCI_DWC3
+#define CONFIG_USB_MAX_CONTROLLER_COUNT         2
+#define CONFIG_SYS_USB_XHCI_MAX_ROOT_PORTS      2
+#define CONFIG_CMD_USB
+#define CONFIG_USB_STORAGE
+#define CONFIG_CMD_EXT2
+
+/* Initial environment variables */
+#undef CONFIG_EXTRA_ENV_SETTINGS
+#define CONFIG_EXTRA_ENV_SETTINGS		\
+	"hwconfig=fsl_ddr:bank_intlv=auto\0"	\
+	"loadaddr=0x80100000\0"			\
+	"kernel_addr=0x100000\0"		\
+	"ramdisk_addr=0x800000\0"		\
+	"ramdisk_size=0x2000000\0"		\
+	"fdt_high=0xa0000000\0"			\
+	"initrd_high=0xffffffffffffffff\0"	\
+	"kernel_start=0x581100000\0"		\
+	"kernel_load=0xa0000000\0"		\
+	"kernel_size=0x2800000\0"
+
+#undef CONFIG_BOOTARGS
+#define CONFIG_BOOTARGS		"console=ttyS1,115200 root=/dev/ram0 " \
+				"earlycon=uart8250,mmio,0x21c0600,115200 " \
+				"ramdisk_size=0x2000000 default_hugepagesz=2m" \
+				" hugepagesz=2m hugepages=16"
+
+/* MAC/PHY configuration */
+#ifdef CONFIG_FSL_MC_ENET
+#define CONFIG_PHYLIB_10G
+#define CONFIG_PHY_AQUANTIA
+#define CONFIG_PHY_CORTINA
+#define CONFIG_PHYLIB
+#define	CONFIG_SYS_CORTINA_FW_IN_NOR
+#define CONFIG_CORTINA_FW_ADDR		0x581000000
+#define CONFIG_CORTINA_FW_LENGTH	0x40000
+
+#define CORTINA_PHY_ADDR1	0x10
+#define CORTINA_PHY_ADDR2	0x11
+#define CORTINA_PHY_ADDR3	0x12
+#define CORTINA_PHY_ADDR4	0x13
+#define AQ_PHY_ADDR1		0x00
+#define AQ_PHY_ADDR2		0x01
+#define AQ_PHY_ADDR3		0x02
+#define AQ_PHY_ADDR4		0x03
+
+#define CONFIG_MII
+#define CONFIG_ETHPRIME		"DPNI1"
+#define CONFIG_PHY_GIGE
+#define CONFIG_PHY_AQUANTIA
+#endif
+
+#endif /* __LS2_RDB_H */
diff --git a/include/configs/ls2085a_common.h b/include/configs/ls2085a_common.h
deleted file mode 100644
index 9755cae..0000000
--- a/include/configs/ls2085a_common.h
+++ /dev/null
@@ -1,313 +0,0 @@
-/*
- * Copyright (C) 2014 Freescale Semiconductor
- *
- * SPDX-License-Identifier:	GPL-2.0+
- */
-
-#ifndef __LS2_COMMON_H
-#define __LS2_COMMON_H
-
-
-#define CONFIG_REMAKE_ELF
-#define CONFIG_FSL_LAYERSCAPE
-#define CONFIG_FSL_LSCH3
-#define CONFIG_LS2085A
-#define CONFIG_MP
-#define CONFIG_GICV3
-#define CONFIG_FSL_TZPC_BP147
-
-/* Errata fixes */
-#define CONFIG_ARM_ERRATA_828024
-#define CONFIG_ARM_ERRATA_826974
-
-#include <asm/arch/ls2085a_stream_id.h>
-#include <asm/arch/config.h>
-#if (defined(CONFIG_SYS_FSL_SRDS_1) || defined(CONFIG_SYS_FSL_SRDS_2))
-#define	CONFIG_SYS_HAS_SERDES
-#endif
-
-/* Link Definitions */
-#define CONFIG_SYS_INIT_SP_ADDR		(CONFIG_SYS_FSL_OCRAM_BASE + 0xfff0)
-
-/* We need architecture specific misc initializations */
-#define CONFIG_ARCH_MISC_INIT
-
-/* Link Definitions */
-#ifdef CONFIG_SPL
-#define CONFIG_SYS_TEXT_BASE		0x80400000
-#else
-#define CONFIG_SYS_TEXT_BASE		0x30100000
-#endif
-
-#ifdef CONFIG_EMU
-#define CONFIG_SYS_NO_FLASH
-#endif
-
-#define CONFIG_SUPPORT_RAW_INITRD
-
-#define CONFIG_SKIP_LOWLEVEL_INIT
-#define CONFIG_BOARD_EARLY_INIT_F	1
-
-/* Flat Device Tree Definitions */
-#define CONFIG_OF_LIBFDT
-#define CONFIG_OF_BOARD_SETUP
-
-/* new uImage format support */
-#define CONFIG_FIT
-#define CONFIG_FIT_VERBOSE	/* enable fit_format_{error,warning}() */
-
-#ifndef CONFIG_SPL
-#define CONFIG_FSL_DDR_INTERACTIVE	/* Interactive debugging */
-#endif
-#ifndef CONFIG_SYS_FSL_DDR4
-#define CONFIG_SYS_FSL_DDR3		/* Use DDR3 memory */
-#define CONFIG_SYS_DDR_RAW_TIMING
-#endif
-
-#define CONFIG_SYS_FSL_DDR_INTLV_256B	/* force 256 byte interleaving */
-
-#define CONFIG_VERY_BIG_RAM
-#define CONFIG_SYS_DDR_SDRAM_BASE	0x80000000UL
-#define CONFIG_SYS_FSL_DDR_SDRAM_BASE_PHY	0
-#define CONFIG_SYS_SDRAM_BASE		CONFIG_SYS_DDR_SDRAM_BASE
-#define CONFIG_SYS_DDR_BLOCK2_BASE	0x8080000000ULL
-#define CONFIG_SYS_FSL_DDR_MAIN_NUM_CTRLS	2
-
-/*
- * SMP Definitinos
- */
-#define CPU_RELEASE_ADDR		secondary_boot_func
-
-#define CONFIG_SYS_FSL_OTHER_DDR_NUM_CTRLS
-#define CONFIG_SYS_DP_DDR_BASE		0x6000000000ULL
-/*
- * DDR controller use 0 as the base address for binding.
- * It is mapped to CONFIG_SYS_DP_DDR_BASE for core to access.
- */
-#define CONFIG_SYS_DP_DDR_BASE_PHY	0
-#define CONFIG_DP_DDR_CTRL		2
-#define CONFIG_DP_DDR_NUM_CTRLS		1
-
-/* Generic Timer Definitions */
-/*
- * This is not an accurate number. It is used in start.S. The frequency
- * will be udpated later when get_bus_freq(0) is available.
- */
-#define COUNTER_FREQUENCY		25000000	/* 25MHz */
-
-/* Size of malloc() pool */
-#define CONFIG_SYS_MALLOC_LEN		(CONFIG_ENV_SIZE + 2048 * 1024)
-
-/* I2C */
-#define CONFIG_CMD_I2C
-#define CONFIG_SYS_I2C
-#define CONFIG_SYS_I2C_MXC
-#define CONFIG_SYS_I2C_MXC_I2C1		/* enable I2C bus 1 */
-#define CONFIG_SYS_I2C_MXC_I2C2		/* enable I2C bus 2 */
-#define CONFIG_SYS_I2C_MXC_I2C3		/* enable I2C bus 3 */
-#define CONFIG_SYS_I2C_MXC_I2C4		/* enable I2C bus 4 */
-
-/* Serial Port */
-#define CONFIG_CONS_INDEX       1
-#define CONFIG_SYS_NS16550
-#define CONFIG_SYS_NS16550_SERIAL
-#define CONFIG_SYS_NS16550_REG_SIZE     1
-#define CONFIG_SYS_NS16550_CLK          (get_bus_freq(0)/2)
-
-#define CONFIG_BAUDRATE			115200
-#define CONFIG_SYS_BAUDRATE_TABLE	{ 9600, 19200, 38400, 57600, 115200 }
-
-/* IFC */
-#define CONFIG_FSL_IFC
-
-/*
- * During booting, IFC is mapped at the region of 0x30000000.
- * But this region is limited to 256MB. To accommodate NOR, promjet
- * and FPGA. This region is divided as below:
- * 0x30000000 - 0x37ffffff : 128MB : NOR flash
- * 0x38000000 - 0x3BFFFFFF : 64MB  : Promjet
- * 0x3C000000 - 0x40000000 : 64MB  : FPGA etc
- *
- * To accommodate bigger NOR flash and other devices, we will map IFC
- * chip selects to as below:
- * 0x5_1000_0000..0x5_1fff_ffff	Memory Hole
- * 0x5_2000_0000..0x5_3fff_ffff	IFC CSx (FPGA, NAND and others 512MB)
- * 0x5_4000_0000..0x5_7fff_ffff	ASIC or others 1GB
- * 0x5_8000_0000..0x5_bfff_ffff	IFC CS0 1GB (NOR/Promjet)
- * 0x5_C000_0000..0x5_ffff_ffff	IFC CS1 1GB (NOR/Promjet)
- *
- * For e.g. NOR flash at CS0 will be mapped to 0x580000000 after relocation.
- * CONFIG_SYS_FLASH_BASE has the final address (core view)
- * CONFIG_SYS_FLASH_BASE_PHYS has the final address (IFC view)
- * CONFIG_SYS_FLASH_BASE_PHYS_EARLY has the temporary IFC address
- * CONFIG_SYS_TEXT_BASE is linked to 0x30000000 for booting
- */
-
-#define CONFIG_SYS_FLASH_BASE			0x580000000ULL
-#define CONFIG_SYS_FLASH_BASE_PHYS		0x80000000
-#define CONFIG_SYS_FLASH_BASE_PHYS_EARLY	0x00000000
-
-#define CONFIG_SYS_FLASH1_BASE_PHYS		0xC0000000
-#define CONFIG_SYS_FLASH1_BASE_PHYS_EARLY	0x8000000
-
-#ifndef CONFIG_SYS_NO_FLASH
-#define CONFIG_FLASH_CFI_DRIVER
-#define CONFIG_SYS_FLASH_CFI
-#define CONFIG_SYS_FLASH_USE_BUFFER_WRITE
-#define CONFIG_SYS_FLASH_QUIET_TEST
-#endif
-
-#ifndef __ASSEMBLY__
-unsigned long long get_qixis_addr(void);
-#endif
-#define QIXIS_BASE				get_qixis_addr()
-#define QIXIS_BASE_PHYS				0x20000000
-#define QIXIS_BASE_PHYS_EARLY			0xC000000
-#define QIXIS_STAT_PRES1			0xb
-#define QIXIS_SDID_MASK				0x07
-#define QIXIS_ESDHC_NO_ADAPTER			0x7
-
-#define CONFIG_SYS_NAND_BASE			0x530000000ULL
-#define CONFIG_SYS_NAND_BASE_PHYS		0x30000000
-
-/* Debug Server firmware */
-#define CONFIG_FSL_DEBUG_SERVER
-/* 2 sec timeout */
-#define CONFIG_SYS_DEBUG_SERVER_TIMEOUT			(2 * 1000 * 1000)
-
-/* MC firmware */
-#define CONFIG_FSL_MC_ENET
-/* TODO Actual DPL max length needs to be confirmed with the MC FW team */
-#define CONFIG_SYS_LS_MC_DPC_MAX_LENGTH	    0x20000
-#define CONFIG_SYS_LS_MC_DRAM_DPC_OFFSET    0x00F00000
-#define CONFIG_SYS_LS_MC_DPL_MAX_LENGTH	    0x20000
-#define CONFIG_SYS_LS_MC_DRAM_DPL_OFFSET    0x00F20000
-#define CONFIG_SYS_LS_MC_AIOP_IMG_MAX_LENGTH	0x200000
-#define CONFIG_SYS_LS_MC_DRAM_AIOP_IMG_OFFSET	0x07000000
-
-/*
- * Carve out a DDR region which will not be used by u-boot/Linux
- *
- * It will be used by MC and Debug Server. The MC region must be
- * 512MB aligned, so the min size to hide is 512MB.
- */
-#if defined(CONFIG_FSL_MC_ENET) || defined(CONFIG_FSL_DEBUG_SERVER)
-#define CONFIG_SYS_DEBUG_SERVER_DRAM_BLOCK_MIN_SIZE	(256UL * 1024 * 1024)
-#define CONFIG_SYS_LS_MC_DRAM_BLOCK_MIN_SIZE		(256UL * 1024 * 1024)
-#define CONFIG_SYS_MEM_TOP_HIDE_MIN			(512UL * 1024 * 1024)
-#define CONFIG_SYS_MEM_TOP_HIDE		get_dram_size_to_hide()
-#endif
-
-/* PCIe */
-#define CONFIG_PCIE1		/* PCIE controler 1 */
-#define CONFIG_PCIE2		/* PCIE controler 2 */
-#define CONFIG_PCIE3		/* PCIE controler 3 */
-#define CONFIG_PCIE4		/* PCIE controler 4 */
-#define CONFIG_PCIE_LAYERSCAPE	/* Use common FSL Layerscape PCIe code */
-#define FSL_PCIE_COMPAT "fsl,ls2085a-pcie"
-
-#define CONFIG_SYS_PCI_64BIT
-
-#define CONFIG_SYS_PCIE_CFG0_PHYS_OFF	0x00000000
-#define CONFIG_SYS_PCIE_CFG0_SIZE	0x00001000	/* 4k */
-#define CONFIG_SYS_PCIE_CFG1_PHYS_OFF	0x00001000
-#define CONFIG_SYS_PCIE_CFG1_SIZE	0x00001000	/* 4k */
-
-#define CONFIG_SYS_PCIE_IO_BUS		0x00000000
-#define CONFIG_SYS_PCIE_IO_PHYS_OFF	0x00010000
-#define CONFIG_SYS_PCIE_IO_SIZE		0x00010000	/* 64k */
-
-#define CONFIG_SYS_PCIE_MEM_BUS		0x40000000
-#define CONFIG_SYS_PCIE_MEM_PHYS_OFF	0x40000000
-#define CONFIG_SYS_PCIE_MEM_SIZE	0x40000000	/* 1G */
-
-/* Command line configuration */
-#define CONFIG_CMD_CACHE
-#define CONFIG_CMD_DHCP
-#define CONFIG_CMD_ENV
-#define CONFIG_CMD_GREPENV
-#define CONFIG_CMD_MII
-#define CONFIG_CMD_PING
-
-/* Miscellaneous configurable options */
-#define CONFIG_SYS_LOAD_ADDR	(CONFIG_SYS_DDR_SDRAM_BASE + 0x10000000)
-#define CONFIG_ARCH_EARLY_INIT_R
-
-/* Physical Memory Map */
-/* fixme: these need to be checked against the board */
-#define CONFIG_CHIP_SELECTS_PER_CTRL	4
-
-#define CONFIG_NR_DRAM_BANKS		3
-
-#define CONFIG_HWCONFIG
-#define HWCONFIG_BUFFER_SIZE		128
-
-#define CONFIG_DISPLAY_CPUINFO
-
-/* Initial environment variables */
-#define CONFIG_EXTRA_ENV_SETTINGS		\
-	"hwconfig=fsl_ddr:bank_intlv=auto\0"	\
-	"loadaddr=0x80100000\0"			\
-	"kernel_addr=0x100000\0"		\
-	"ramdisk_addr=0x800000\0"		\
-	"ramdisk_size=0x2000000\0"		\
-	"fdt_high=0xa0000000\0"			\
-	"initrd_high=0xffffffffffffffff\0"	\
-	"kernel_start=0x581200000\0"		\
-	"kernel_load=0xa0000000\0"		\
-	"kernel_size=0x2800000\0"		\
-	"console=ttyAMA0,38400n8\0"
-
-#define CONFIG_BOOTARGS		"console=ttyS0,115200 root=/dev/ram0 " \
-				"earlycon=uart8250,mmio,0x21c0500,115200 " \
-				"ramdisk_size=0x2000000 default_hugepagesz=2m" \
-				" hugepagesz=2m hugepages=16"
-#define CONFIG_BOOTCOMMAND		"cp.b $kernel_start $kernel_load "     \
-					"$kernel_size && bootm $kernel_load"
-#define CONFIG_BOOTDELAY		10
-
-/* Monitor Command Prompt */
-#define CONFIG_SYS_CBSIZE		512	/* Console I/O Buffer Size */
-#define CONFIG_SYS_PBSIZE		(CONFIG_SYS_CBSIZE + \
-					sizeof(CONFIG_SYS_PROMPT) + 16)
-#define CONFIG_SYS_HUSH_PARSER
-#define CONFIG_SYS_PROMPT_HUSH_PS2	"> "
-#define CONFIG_SYS_BARGSIZE		CONFIG_SYS_CBSIZE /* Boot args buffer */
-#define CONFIG_SYS_LONGHELP
-#define CONFIG_CMDLINE_EDITING		1
-#define CONFIG_AUTO_COMPLETE
-#define CONFIG_SYS_MAXARGS		64	/* max command args */
-
-#ifndef __ASSEMBLY__
-unsigned long get_dram_size_to_hide(void);
-#endif
-
-#define CONFIG_PANIC_HANG	/* do not reset board on panic */
-
-#define CONFIG_SPL_BSS_START_ADDR	0x80100000
-#define CONFIG_SPL_BSS_MAX_SIZE		0x00100000
-#define CONFIG_SPL_DRIVERS_MISC_SUPPORT
-#define CONFIG_SPL_ENV_SUPPORT
-#define CONFIG_SPL_FRAMEWORK
-#define CONFIG_SPL_I2C_SUPPORT
-#define CONFIG_SPL_LDSCRIPT "arch/arm/cpu/armv8/u-boot-spl.lds"
-#define CONFIG_SPL_LIBCOMMON_SUPPORT
-#define CONFIG_SPL_LIBGENERIC_SUPPORT
-#define CONFIG_SPL_MAX_SIZE		0x16000
-#define CONFIG_SPL_MPC8XXX_INIT_DDR_SUPPORT
-#define CONFIG_SPL_NAND_SUPPORT
-#define CONFIG_SPL_SERIAL_SUPPORT
-#define CONFIG_SPL_STACK		(CONFIG_SYS_FSL_OCRAM_BASE + 0x9ff0)
-#define CONFIG_SPL_TARGET		"u-boot-with-spl.bin"
-#define CONFIG_SPL_TEXT_BASE		0x1800a000
-
-#define CONFIG_SYS_NAND_U_BOOT_DST	0x80400000
-#define CONFIG_SYS_NAND_U_BOOT_START	CONFIG_SYS_NAND_U_BOOT_DST
-#define CONFIG_SYS_SPL_MALLOC_SIZE	0x00100000
-#define CONFIG_SYS_SPL_MALLOC_START	0x80200000
-#define CONFIG_SYS_MONITOR_LEN		(512 * 1024)
-
-#define CONFIG_SYS_BOOTM_LEN   (64 << 20)      /* Increase max gunzip size */
-
-
-#endif /* __LS2_COMMON_H */
diff --git a/include/configs/ls2085a_emu.h b/include/configs/ls2085a_emu.h
deleted file mode 100644
index 2d68e1b..0000000
--- a/include/configs/ls2085a_emu.h
+++ /dev/null
@@ -1,89 +0,0 @@
-/*
- * Copyright 2014 Freescale Semiconductor
- *
- * SPDX-License-Identifier:	GPL-2.0+
- */
-
-#ifndef __LS2_EMU_H
-#define __LS2_EMU_H
-
-#include "ls2085a_common.h"
-
-#define CONFIG_IDENT_STRING		" LS2085A-EMU"
-#define CONFIG_BOOTP_VCI_STRING		"U-boot.LS2085A-EMU"
-
-#define CONFIG_SYS_CLK_FREQ	100000000
-#define CONFIG_DDR_CLK_FREQ	133333333
-
-#define CONFIG_SYS_MXC_I2C1_SPEED	40000000
-#define CONFIG_SYS_MXC_I2C2_SPEED	40000000
-
-#define CONFIG_DDR_SPD
-#define CONFIG_SYS_FSL_DDR_EMU		/* Support emulator */
-#define SPD_EEPROM_ADDRESS1	0x51
-#define SPD_EEPROM_ADDRESS2	0x52
-#define SPD_EEPROM_ADDRESS3	0x53
-#define SPD_EEPROM_ADDRESS	SPD_EEPROM_ADDRESS1
-#define CONFIG_SYS_SPD_BUS_NUM	1	/* SPD on I2C bus 1 */
-#define CONFIG_DIMM_SLOTS_PER_CTLR		1
-#define CONFIG_CHIP_SELECTS_PER_CTRL		4
-#define CONFIG_DP_DDR_DIMM_SLOTS_PER_CTLR	1
-
-#define CONFIG_FSL_DDR_SYNC_REFRESH
-
-#define CONFIG_SYS_NOR0_CSPR_EXT	(0x0)
-#define CONFIG_SYS_NOR_AMASK	IFC_AMASK(128*1024*1024)
-/*
- * NOR Flash Timing Params
- */
-#define CONFIG_SYS_NOR0_CSPR					\
-	(CSPR_PHYS_ADDR(CONFIG_SYS_FLASH_BASE_PHYS)		| \
-	CSPR_PORT_SIZE_16					| \
-	CSPR_MSEL_NOR						| \
-	CSPR_V)
-#define CONFIG_SYS_NOR0_CSPR_EARLY				\
-	(CSPR_PHYS_ADDR(CONFIG_SYS_FLASH_BASE_PHYS_EARLY)	| \
-	CSPR_PORT_SIZE_16					| \
-	CSPR_MSEL_NOR						| \
-	CSPR_V)
-#define CONFIG_SYS_NOR_CSOR	CSOR_NOR_ADM_SHIFT(12)
-#define CONFIG_SYS_NOR_FTIM0	(FTIM0_NOR_TACSE(0x1) | \
-				FTIM0_NOR_TEADC(0x1) | \
-				FTIM0_NOR_TEAHC(0x1))
-#define CONFIG_SYS_NOR_FTIM1	(FTIM1_NOR_TACO(0x1) | \
-				FTIM1_NOR_TRAD_NOR(0x1))
-#define CONFIG_SYS_NOR_FTIM2	(FTIM2_NOR_TCS(0x0) | \
-				FTIM2_NOR_TCH(0x0) | \
-				FTIM2_NOR_TWP(0x1))
-#define CONFIG_SYS_NOR_FTIM3	0x04000000
-#define CONFIG_SYS_IFC_CCR	0x01000000
-
-#define CONFIG_SYS_CSPR0_EXT		CONFIG_SYS_NOR0_CSPR_EXT
-#define CONFIG_SYS_CSPR0		CONFIG_SYS_NOR0_CSPR_EARLY
-#define CONFIG_SYS_CSPR0_FINAL		CONFIG_SYS_NOR0_CSPR
-#define CONFIG_SYS_AMASK0		CONFIG_SYS_NOR_AMASK
-#define CONFIG_SYS_CSOR0		CONFIG_SYS_NOR_CSOR
-#define CONFIG_SYS_CS0_FTIM0		CONFIG_SYS_NOR_FTIM0
-#define CONFIG_SYS_CS0_FTIM1		CONFIG_SYS_NOR_FTIM1
-#define CONFIG_SYS_CS0_FTIM2		CONFIG_SYS_NOR_FTIM2
-#define CONFIG_SYS_CS0_FTIM3		CONFIG_SYS_NOR_FTIM3
-
-/* Debug Server firmware */
-#define CONFIG_SYS_DEBUG_SERVER_FW_IN_NOR
-#define CONFIG_SYS_DEBUG_SERVER_FW_ADDR	0x580C00000ULL
-
-/*
- * This trick allows users to load MC images into DDR directly without
- * copying from NOR flash. It dramatically improves speed.
- */
-#define CONFIG_SYS_LS_MC_FW_IN_DDR
-#define CONFIG_SYS_LS_MC_DPL_IN_DDR
-#define CONFIG_SYS_LS_MC_DPC_IN_DDR
-
-#define CONFIG_SYS_LS_MC_BOOT_TIMEOUT_MS 200000
-
-/* Store environment at top of flash */
-#define CONFIG_ENV_IS_NOWHERE		1
-#define CONFIG_ENV_SIZE			0x1000
-
-#endif /* __LS2_EMU_H */
diff --git a/include/configs/ls2085a_simu.h b/include/configs/ls2085a_simu.h
deleted file mode 100644
index bd15b3d..0000000
--- a/include/configs/ls2085a_simu.h
+++ /dev/null
@@ -1,161 +0,0 @@
-/*
- * Copyright (C) 2014 Freescale Semiconductor
- *
- * SPDX-License-Identifier:	GPL-2.0+
- */
-
-#ifndef __LS2_SIMU_H
-#define __LS2_SIMU_H
-
-#include "ls2085a_common.h"
-
-#define CONFIG_IDENT_STRING		" LS2085A-SIMU"
-#define CONFIG_BOOTP_VCI_STRING		"U-boot.LS2085A-SIMU"
-
-#define CONFIG_SYS_CLK_FREQ	100000000
-#define CONFIG_DDR_CLK_FREQ	133333333
-
-#define CONFIG_SYS_MXC_I2C1_SPEED	40000000
-#define CONFIG_SYS_MXC_I2C2_SPEED	40000000
-
-#define CONFIG_DIMM_SLOTS_PER_CTLR		1
-#define CONFIG_CHIP_SELECTS_PER_CTRL		4
-#define CONFIG_DP_DDR_DIMM_SLOTS_PER_CTLR	1
-
-/* SMSC 91C111 ethernet configuration */
-#define CONFIG_SMC91111
-#define CONFIG_SMC91111_BASE	(0x2210000)
-
-#define CONFIG_SYS_NOR0_CSPR_EXT	(0x0)
-#define CONFIG_SYS_NOR_AMASK	IFC_AMASK(128*1024*1024)
-
-/*
- * NOR Flash Timing Params
- */
-#define CONFIG_SYS_NOR0_CSPR					\
-	(CSPR_PHYS_ADDR(CONFIG_SYS_FLASH_BASE_PHYS)		| \
-	CSPR_PORT_SIZE_16					| \
-	CSPR_MSEL_NOR						| \
-	CSPR_V)
-#define CONFIG_SYS_NOR0_CSPR_EARLY				\
-	(CSPR_PHYS_ADDR(CONFIG_SYS_FLASH_BASE_PHYS_EARLY)	| \
-	CSPR_PORT_SIZE_16					| \
-	CSPR_MSEL_NOR						| \
-	CSPR_V)
-#define CONFIG_SYS_NOR_CSOR	CSOR_NOR_ADM_SHIFT(12)
-#define CONFIG_SYS_NOR_FTIM0	(FTIM0_NOR_TACSE(0x1) | \
-				FTIM0_NOR_TEADC(0x1) | \
-				FTIM0_NOR_TEAHC(0x1))
-#define CONFIG_SYS_NOR_FTIM1	(FTIM1_NOR_TACO(0x1) | \
-				FTIM1_NOR_TRAD_NOR(0x1))
-#define CONFIG_SYS_NOR_FTIM2	(FTIM2_NOR_TCS(0x0) | \
-				FTIM2_NOR_TCH(0x0) | \
-				FTIM2_NOR_TWP(0x1))
-#define CONFIG_SYS_NOR_FTIM3	0x04000000
-#define CONFIG_SYS_IFC_CCR	0x01000000
-
-#ifndef CONFIG_SYS_NO_FLASH
-#define CONFIG_FLASH_SHOW_PROGRESS	45 /* count down from 45/5: 9..1 */
-
-#define CONFIG_SYS_MAX_FLASH_BANKS	1	/* number of banks */
-#define CONFIG_SYS_MAX_FLASH_SECT	1024	/* sectors per device */
-#define CONFIG_SYS_FLASH_ERASE_TOUT	60000	/* Flash Erase Timeout (ms) */
-#define CONFIG_SYS_FLASH_WRITE_TOUT	500	/* Flash Write Timeout (ms) */
-
-#define CONFIG_SYS_FLASH_EMPTY_INFO
-#define CONFIG_SYS_FLASH_BANKS_LIST	{ CONFIG_SYS_FLASH_BASE }
-#endif
-
-#define CONFIG_NAND_FSL_IFC
-#define CONFIG_SYS_NAND_MAX_ECCPOS	256
-#define CONFIG_SYS_NAND_MAX_OOBFREE	2
-
-
-#define CONFIG_SYS_NAND_CSPR_EXT	(0x0)
-#define CONFIG_SYS_NAND_CSPR	(CSPR_PHYS_ADDR(CONFIG_SYS_NAND_BASE_PHYS) \
-				| CSPR_PORT_SIZE_8 /* Port Size = 8 bit */ \
-				| CSPR_MSEL_NAND	/* MSEL = NAND */ \
-				| CSPR_V)
-#define CONFIG_SYS_NAND_AMASK	IFC_AMASK(64 * 1024)
-
-#define CONFIG_SYS_NAND_CSOR    (CSOR_NAND_ECC_ENC_EN   /* ECC on encode */ \
-				| CSOR_NAND_ECC_DEC_EN  /* ECC on decode */ \
-				| CSOR_NAND_ECC_MODE_4  /* 4-bit ECC */ \
-				| CSOR_NAND_RAL_3	/* RAL = 2Byes */ \
-				| CSOR_NAND_PGS_2K	/* Page Size = 2K */ \
-				| CSOR_NAND_SPRZ_64/* Spare size = 64 */ \
-				| CSOR_NAND_PB(64))	/*Pages Per Block = 64*/
-
-#define CONFIG_SYS_NAND_ONFI_DETECTION
-
-/* ONFI NAND Flash mode0 Timing Params */
-#define CONFIG_SYS_NAND_FTIM0		(FTIM0_NAND_TCCST(0x07) | \
-					FTIM0_NAND_TWP(0x18)   | \
-					FTIM0_NAND_TWCHT(0x07) | \
-					FTIM0_NAND_TWH(0x0a))
-#define CONFIG_SYS_NAND_FTIM1		(FTIM1_NAND_TADLE(0x32) | \
-					FTIM1_NAND_TWBE(0x39)  | \
-					FTIM1_NAND_TRR(0x0e)   | \
-					FTIM1_NAND_TRP(0x18))
-#define CONFIG_SYS_NAND_FTIM2		(FTIM2_NAND_TRAD(0x0f) | \
-					FTIM2_NAND_TREH(0x0a) | \
-					FTIM2_NAND_TWHRE(0x1e))
-#define CONFIG_SYS_NAND_FTIM3		0x0
-
-#define CONFIG_SYS_NAND_BASE_LIST	{ CONFIG_SYS_NAND_BASE }
-#define CONFIG_SYS_MAX_NAND_DEVICE	1
-#define CONFIG_MTD_NAND_VERIFY_WRITE
-#define CONFIG_CMD_NAND
-
-#define CONFIG_SYS_NAND_BLOCK_SIZE	(128 * 1024)
-
-#define CONFIG_SYS_CSPR0_EXT		CONFIG_SYS_NOR0_CSPR_EXT
-#define CONFIG_SYS_CSPR0		CONFIG_SYS_NOR0_CSPR_EARLY
-#define CONFIG_SYS_CSPR0_FINAL		CONFIG_SYS_NOR0_CSPR
-#define CONFIG_SYS_AMASK0		CONFIG_SYS_NOR_AMASK
-#define CONFIG_SYS_CSOR0		CONFIG_SYS_NOR_CSOR
-#define CONFIG_SYS_CS0_FTIM0		CONFIG_SYS_NOR_FTIM0
-#define CONFIG_SYS_CS0_FTIM1		CONFIG_SYS_NOR_FTIM1
-#define CONFIG_SYS_CS0_FTIM2		CONFIG_SYS_NOR_FTIM2
-#define CONFIG_SYS_CS0_FTIM3		CONFIG_SYS_NOR_FTIM3
-#define CONFIG_SYS_CSPR1_EXT		CONFIG_SYS_NAND_CSPR_EXT
-#define CONFIG_SYS_CSPR1		CONFIG_SYS_NAND_CSPR
-#define CONFIG_SYS_AMASK1		CONFIG_SYS_NAND_AMASK
-#define CONFIG_SYS_CSOR1		CONFIG_SYS_NAND_CSOR
-#define CONFIG_SYS_CS1_FTIM0		CONFIG_SYS_NAND_FTIM0
-#define CONFIG_SYS_CS1_FTIM1		CONFIG_SYS_NAND_FTIM1
-#define CONFIG_SYS_CS1_FTIM2		CONFIG_SYS_NAND_FTIM2
-#define CONFIG_SYS_CS1_FTIM3		CONFIG_SYS_NAND_FTIM3
-
-/*  MMC  */
-#define CONFIG_MMC
-#ifdef CONFIG_MMC
-#define CONFIG_CMD_MMC
-#define CONFIG_FSL_ESDHC
-#define CONFIG_SYS_FSL_MMC_HAS_CAPBLT_VS33
-#define CONFIG_GENERIC_MMC
-#define CONFIG_CMD_FAT
-#define CONFIG_DOS_PARTITION
-#endif
-
-/* Debug Server firmware */
-#define CONFIG_SYS_DEBUG_SERVER_FW_IN_NOR
-#define CONFIG_SYS_DEBUG_SERVER_FW_ADDR	0x580C00000ULL
-
-/* MC firmware */
-#define CONFIG_SYS_LS_MC_FW_IN_NOR
-#define CONFIG_SYS_LS_MC_FW_ADDR	0x580200000ULL
-
-#define CONFIG_SYS_LS_MC_DPL_IN_NOR
-#define CONFIG_SYS_LS_MC_DPL_ADDR	0x5806C0000ULL
-
-#define CONFIG_SYS_LS_MC_DPC_IN_NOR
-#define CONFIG_SYS_LS_MC_DPC_ADDR	0x5806F8000ULL
-
-#define CONFIG_SYS_LS_MC_BOOT_TIMEOUT_MS 200000
-
-/* Store environment at top of flash */
-#define CONFIG_ENV_IS_NOWHERE		1
-#define CONFIG_ENV_SIZE			0x1000
-
-#endif /* __LS2_SIMU_H */
diff --git a/include/configs/ls2085aqds.h b/include/configs/ls2085aqds.h
deleted file mode 100644
index 717ef80..0000000
--- a/include/configs/ls2085aqds.h
+++ /dev/null
@@ -1,382 +0,0 @@
-/*
- * Copyright 2015 Freescale Semiconductor
- *
- * SPDX-License-Identifier:	GPL-2.0+
- */
-
-#ifndef __LS2_QDS_H
-#define __LS2_QDS_H
-
-#include "ls2085a_common.h"
-
-#define CONFIG_DISPLAY_BOARDINFO
-
-#ifndef __ASSEMBLY__
-unsigned long get_board_sys_clk(void);
-unsigned long get_board_ddr_clk(void);
-#endif
-
-#define CONFIG_SYS_CLK_FREQ		get_board_sys_clk()
-#define CONFIG_DDR_CLK_FREQ		get_board_ddr_clk()
-#define COUNTER_FREQUENCY_REAL		(CONFIG_SYS_CLK_FREQ/4)
-
-#define CONFIG_DDR_SPD
-#define CONFIG_DDR_ECC
-#define CONFIG_ECC_INIT_VIA_DDRCONTROLLER
-#define CONFIG_MEM_INIT_VALUE		0xdeadbeef
-#define SPD_EEPROM_ADDRESS1	0x51
-#define SPD_EEPROM_ADDRESS2	0x52
-#define SPD_EEPROM_ADDRESS3	0x53
-#define SPD_EEPROM_ADDRESS4	0x54
-#define SPD_EEPROM_ADDRESS5	0x55
-#define SPD_EEPROM_ADDRESS6	0x56	/* dummy address */
-#define SPD_EEPROM_ADDRESS	SPD_EEPROM_ADDRESS1
-#define CONFIG_SYS_SPD_BUS_NUM	0	/* SPD on I2C bus 0 */
-#define CONFIG_DIMM_SLOTS_PER_CTLR		2
-#define CONFIG_CHIP_SELECTS_PER_CTRL		4
-#define CONFIG_DP_DDR_DIMM_SLOTS_PER_CTLR	1
-#define CONFIG_FSL_DDR_BIST	/* enable built-in memory test */
-
-/* undefined CONFIG_FSL_DDR_SYNC_REFRESH for simulator */
-
-#define CONFIG_SYS_NOR0_CSPR_EXT	(0x0)
-#define CONFIG_SYS_NOR_AMASK		IFC_AMASK(128*1024*1024)
-#define CONFIG_SYS_NOR_AMASK_EARLY	IFC_AMASK(64*1024*1024)
-
-#define CONFIG_SYS_NOR0_CSPR					\
-	(CSPR_PHYS_ADDR(CONFIG_SYS_FLASH_BASE_PHYS)		| \
-	CSPR_PORT_SIZE_16					| \
-	CSPR_MSEL_NOR						| \
-	CSPR_V)
-#define CONFIG_SYS_NOR0_CSPR_EARLY				\
-	(CSPR_PHYS_ADDR(CONFIG_SYS_FLASH_BASE_PHYS_EARLY)	| \
-	CSPR_PORT_SIZE_16					| \
-	CSPR_MSEL_NOR						| \
-	CSPR_V)
-#define CONFIG_SYS_NOR1_CSPR					\
-	(CSPR_PHYS_ADDR(CONFIG_SYS_FLASH1_BASE_PHYS)		| \
-	CSPR_PORT_SIZE_16					| \
-	CSPR_MSEL_NOR						| \
-	CSPR_V)
-#define CONFIG_SYS_NOR1_CSPR_EARLY				\
-	(CSPR_PHYS_ADDR(CONFIG_SYS_FLASH1_BASE_PHYS_EARLY)	| \
-	CSPR_PORT_SIZE_16					| \
-	CSPR_MSEL_NOR						| \
-	CSPR_V)
-#define CONFIG_SYS_NOR_CSOR	CSOR_NOR_ADM_SHIFT(12)
-#define CONFIG_SYS_NOR_FTIM0	(FTIM0_NOR_TACSE(0x4) | \
-				FTIM0_NOR_TEADC(0x5) | \
-				FTIM0_NOR_TEAHC(0x5))
-#define CONFIG_SYS_NOR_FTIM1	(FTIM1_NOR_TACO(0x35) | \
-				FTIM1_NOR_TRAD_NOR(0x1a) |\
-				FTIM1_NOR_TSEQRAD_NOR(0x13))
-#define CONFIG_SYS_NOR_FTIM2	(FTIM2_NOR_TCS(0x4) | \
-				FTIM2_NOR_TCH(0x4) | \
-				FTIM2_NOR_TWPH(0x0E) | \
-				FTIM2_NOR_TWP(0x1c))
-#define CONFIG_SYS_NOR_FTIM3	0x04000000
-#define CONFIG_SYS_IFC_CCR	0x01000000
-
-#ifndef CONFIG_SYS_NO_FLASH
-#define CONFIG_FLASH_CFI_DRIVER
-#define CONFIG_SYS_FLASH_CFI
-#define CONFIG_SYS_FLASH_USE_BUFFER_WRITE
-#define CONFIG_SYS_FLASH_QUIET_TEST
-#define CONFIG_FLASH_SHOW_PROGRESS	45 /* count down from 45/5: 9..1 */
-
-#define CONFIG_SYS_MAX_FLASH_BANKS	2	/* number of banks */
-#define CONFIG_SYS_MAX_FLASH_SECT	1024	/* sectors per device */
-#define CONFIG_SYS_FLASH_ERASE_TOUT	60000	/* Flash Erase Timeout (ms) */
-#define CONFIG_SYS_FLASH_WRITE_TOUT	500	/* Flash Write Timeout (ms) */
-
-#define CONFIG_SYS_FLASH_EMPTY_INFO
-#define CONFIG_SYS_FLASH_BANKS_LIST	{ CONFIG_SYS_FLASH_BASE,\
-					 CONFIG_SYS_FLASH_BASE + 0x40000000}
-#endif
-
-#define CONFIG_NAND_FSL_IFC
-#define CONFIG_SYS_NAND_MAX_ECCPOS	256
-#define CONFIG_SYS_NAND_MAX_OOBFREE	2
-
-
-#define CONFIG_SYS_NAND_CSPR_EXT	(0x0)
-#define CONFIG_SYS_NAND_CSPR	(CSPR_PHYS_ADDR(CONFIG_SYS_NAND_BASE_PHYS) \
-				| CSPR_PORT_SIZE_8 /* Port Size = 8 bit */ \
-				| CSPR_MSEL_NAND	/* MSEL = NAND */ \
-				| CSPR_V)
-#define CONFIG_SYS_NAND_AMASK	IFC_AMASK(64 * 1024)
-
-#define CONFIG_SYS_NAND_CSOR    (CSOR_NAND_ECC_ENC_EN   /* ECC on encode */ \
-				| CSOR_NAND_ECC_DEC_EN  /* ECC on decode */ \
-				| CSOR_NAND_ECC_MODE_4  /* 4-bit ECC */ \
-				| CSOR_NAND_RAL_3	/* RAL = 3Byes */ \
-				| CSOR_NAND_PGS_2K	/* Page Size = 2K */ \
-				| CSOR_NAND_SPRZ_64/* Spare size = 64 */ \
-				| CSOR_NAND_PB(64))	/*Pages Per Block = 64*/
-
-#define CONFIG_SYS_NAND_ONFI_DETECTION
-
-/* ONFI NAND Flash mode0 Timing Params */
-#define CONFIG_SYS_NAND_FTIM0		(FTIM0_NAND_TCCST(0x07) | \
-					FTIM0_NAND_TWP(0x18)   | \
-					FTIM0_NAND_TWCHT(0x07) | \
-					FTIM0_NAND_TWH(0x0a))
-#define CONFIG_SYS_NAND_FTIM1		(FTIM1_NAND_TADLE(0x32) | \
-					FTIM1_NAND_TWBE(0x39)  | \
-					FTIM1_NAND_TRR(0x0e)   | \
-					FTIM1_NAND_TRP(0x18))
-#define CONFIG_SYS_NAND_FTIM2		(FTIM2_NAND_TRAD(0x0f) | \
-					FTIM2_NAND_TREH(0x0a) | \
-					FTIM2_NAND_TWHRE(0x1e))
-#define CONFIG_SYS_NAND_FTIM3		0x0
-
-#define CONFIG_SYS_NAND_BASE_LIST	{ CONFIG_SYS_NAND_BASE }
-#define CONFIG_SYS_MAX_NAND_DEVICE	1
-#define CONFIG_MTD_NAND_VERIFY_WRITE
-#define CONFIG_CMD_NAND
-
-#define CONFIG_SYS_NAND_BLOCK_SIZE	(128 * 1024)
-
-#define CONFIG_FSL_QIXIS	/* use common QIXIS code */
-#define QIXIS_LBMAP_SWITCH		0x06
-#define QIXIS_LBMAP_MASK		0x0f
-#define QIXIS_LBMAP_SHIFT		0
-#define QIXIS_LBMAP_DFLTBANK		0x00
-#define QIXIS_LBMAP_ALTBANK		0x04
-#define QIXIS_LBMAP_NAND		0x09
-#define QIXIS_RST_CTL_RESET		0x31
-#define QIXIS_RCFG_CTL_RECONFIG_IDLE	0x20
-#define QIXIS_RCFG_CTL_RECONFIG_START	0x21
-#define QIXIS_RCFG_CTL_WATCHDOG_ENBLE	0x08
-#define QIXIS_RCW_SRC_NAND		0x107
-#define	QIXIS_RST_FORCE_MEM		0x01
-
-#define CONFIG_SYS_CSPR3_EXT	(0x0)
-#define CONFIG_SYS_CSPR3	(CSPR_PHYS_ADDR(QIXIS_BASE_PHYS_EARLY) \
-				| CSPR_PORT_SIZE_8 \
-				| CSPR_MSEL_GPCM \
-				| CSPR_V)
-#define CONFIG_SYS_CSPR3_FINAL	(CSPR_PHYS_ADDR(QIXIS_BASE_PHYS) \
-				| CSPR_PORT_SIZE_8 \
-				| CSPR_MSEL_GPCM \
-				| CSPR_V)
-
-#define CONFIG_SYS_AMASK3	IFC_AMASK(64*1024)
-#define CONFIG_SYS_CSOR3	CSOR_GPCM_ADM_SHIFT(12)
-/* QIXIS Timing parameters for IFC CS3 */
-#define CONFIG_SYS_CS3_FTIM0		(FTIM0_GPCM_TACSE(0x0e) | \
-					FTIM0_GPCM_TEADC(0x0e) | \
-					FTIM0_GPCM_TEAHC(0x0e))
-#define CONFIG_SYS_CS3_FTIM1		(FTIM1_GPCM_TACO(0xff) | \
-					FTIM1_GPCM_TRAD(0x3f))
-#define CONFIG_SYS_CS3_FTIM2		(FTIM2_GPCM_TCS(0xf) | \
-					FTIM2_GPCM_TCH(0xf) | \
-					FTIM2_GPCM_TWP(0x3E))
-#define CONFIG_SYS_CS3_FTIM3		0x0
-
-#if defined(CONFIG_SPL) && defined(CONFIG_NAND)
-#define CONFIG_SYS_CSPR1_EXT		CONFIG_SYS_NOR0_CSPR_EXT
-#define CONFIG_SYS_CSPR1		CONFIG_SYS_NOR0_CSPR_EARLY
-#define CONFIG_SYS_CSPR1_FINAL		CONFIG_SYS_NOR0_CSPR
-#define CONFIG_SYS_AMASK1		CONFIG_SYS_NOR_AMASK
-#define CONFIG_SYS_CSOR1		CONFIG_SYS_NOR_CSOR
-#define CONFIG_SYS_CS1_FTIM0		CONFIG_SYS_NOR_FTIM0
-#define CONFIG_SYS_CS1_FTIM1		CONFIG_SYS_NOR_FTIM1
-#define CONFIG_SYS_CS1_FTIM2		CONFIG_SYS_NOR_FTIM2
-#define CONFIG_SYS_CS1_FTIM3		CONFIG_SYS_NOR_FTIM3
-#define CONFIG_SYS_CSPR2_EXT		CONFIG_SYS_NOR0_CSPR_EXT
-#define CONFIG_SYS_CSPR2		CONFIG_SYS_NOR1_CSPR_EARLY
-#define CONFIG_SYS_CSPR2_FINAL		CONFIG_SYS_NOR1_CSPR
-#define CONFIG_SYS_AMASK2		CONFIG_SYS_NOR_AMASK_EARLY
-#define CONFIG_SYS_AMASK2_FINAL		CONFIG_SYS_NOR_AMASK
-#define CONFIG_SYS_CSOR2		CONFIG_SYS_NOR_CSOR
-#define CONFIG_SYS_CS2_FTIM0		CONFIG_SYS_NOR_FTIM0
-#define CONFIG_SYS_CS2_FTIM1		CONFIG_SYS_NOR_FTIM1
-#define CONFIG_SYS_CS2_FTIM2		CONFIG_SYS_NOR_FTIM2
-#define CONFIG_SYS_CS2_FTIM3		CONFIG_SYS_NOR_FTIM3
-#define CONFIG_SYS_CSPR0_EXT		CONFIG_SYS_NAND_CSPR_EXT
-#define CONFIG_SYS_CSPR0		CONFIG_SYS_NAND_CSPR
-#define CONFIG_SYS_AMASK0		CONFIG_SYS_NAND_AMASK
-#define CONFIG_SYS_CSOR0		CONFIG_SYS_NAND_CSOR
-#define CONFIG_SYS_CS0_FTIM0		CONFIG_SYS_NAND_FTIM0
-#define CONFIG_SYS_CS0_FTIM1		CONFIG_SYS_NAND_FTIM1
-#define CONFIG_SYS_CS0_FTIM2		CONFIG_SYS_NAND_FTIM2
-#define CONFIG_SYS_CS0_FTIM3		CONFIG_SYS_NAND_FTIM3
-
-#define CONFIG_ENV_IS_IN_NAND
-#define CONFIG_ENV_OFFSET		(896 * 1024)
-#define CONFIG_ENV_SECT_SIZE		0x20000
-#define CONFIG_ENV_SIZE			0x2000
-#define CONFIG_SPL_PAD_TO		0x20000
-#define CONFIG_SYS_NAND_U_BOOT_OFFS	(256 * 1024)
-#define CONFIG_SYS_NAND_U_BOOT_SIZE	(512 * 1024)
-#else
-#define CONFIG_SYS_CSPR0_EXT		CONFIG_SYS_NOR0_CSPR_EXT
-#define CONFIG_SYS_CSPR0		CONFIG_SYS_NOR0_CSPR_EARLY
-#define CONFIG_SYS_CSPR0_FINAL		CONFIG_SYS_NOR0_CSPR
-#define CONFIG_SYS_AMASK0		CONFIG_SYS_NOR_AMASK
-#define CONFIG_SYS_CSOR0		CONFIG_SYS_NOR_CSOR
-#define CONFIG_SYS_CS0_FTIM0		CONFIG_SYS_NOR_FTIM0
-#define CONFIG_SYS_CS0_FTIM1		CONFIG_SYS_NOR_FTIM1
-#define CONFIG_SYS_CS0_FTIM2		CONFIG_SYS_NOR_FTIM2
-#define CONFIG_SYS_CS0_FTIM3		CONFIG_SYS_NOR_FTIM3
-#define CONFIG_SYS_CSPR1_EXT		CONFIG_SYS_NOR0_CSPR_EXT
-#define CONFIG_SYS_CSPR1		CONFIG_SYS_NOR1_CSPR_EARLY
-#define CONFIG_SYS_CSPR1_FINAL		CONFIG_SYS_NOR1_CSPR
-#define CONFIG_SYS_AMASK1		CONFIG_SYS_NOR_AMASK_EARLY
-#define CONFIG_SYS_AMASK1_FINAL		CONFIG_SYS_NOR_AMASK
-#define CONFIG_SYS_CSOR1		CONFIG_SYS_NOR_CSOR
-#define CONFIG_SYS_CS1_FTIM0		CONFIG_SYS_NOR_FTIM0
-#define CONFIG_SYS_CS1_FTIM1		CONFIG_SYS_NOR_FTIM1
-#define CONFIG_SYS_CS1_FTIM2		CONFIG_SYS_NOR_FTIM2
-#define CONFIG_SYS_CS1_FTIM3		CONFIG_SYS_NOR_FTIM3
-#define CONFIG_SYS_CSPR2_EXT		CONFIG_SYS_NAND_CSPR_EXT
-#define CONFIG_SYS_CSPR2		CONFIG_SYS_NAND_CSPR
-#define CONFIG_SYS_AMASK2		CONFIG_SYS_NAND_AMASK
-#define CONFIG_SYS_CSOR2		CONFIG_SYS_NAND_CSOR
-#define CONFIG_SYS_CS2_FTIM0		CONFIG_SYS_NAND_FTIM0
-#define CONFIG_SYS_CS2_FTIM1		CONFIG_SYS_NAND_FTIM1
-#define CONFIG_SYS_CS2_FTIM2		CONFIG_SYS_NAND_FTIM2
-#define CONFIG_SYS_CS2_FTIM3		CONFIG_SYS_NAND_FTIM3
-
-#define CONFIG_ENV_IS_IN_FLASH
-#define CONFIG_ENV_ADDR			(CONFIG_SYS_FLASH_BASE + 0x200000)
-#define CONFIG_ENV_SECT_SIZE		0x20000
-#define CONFIG_ENV_SIZE			0x2000
-#endif
-
-/* Debug Server firmware */
-#define CONFIG_SYS_DEBUG_SERVER_FW_IN_NOR
-#define CONFIG_SYS_DEBUG_SERVER_FW_ADDR	0x580D00000ULL
-
-#define CONFIG_SYS_LS_MC_BOOT_TIMEOUT_MS 5000
-
-/*
- * I2C
- */
-#define I2C_MUX_PCA_ADDR		0x77
-#define I2C_MUX_PCA_ADDR_PRI		0x77 /* Primary Mux*/
-
-/* I2C bus multiplexer */
-#define I2C_MUX_CH_DEFAULT      0x8
-
-/* SPI */
-#ifdef CONFIG_FSL_DSPI
-#define CONFIG_CMD_SF
-#define CONFIG_SPI_FLASH
-#define CONFIG_SPI_FLASH_STMICRO
-#define CONFIG_SPI_FLASH_SST
-#define CONFIG_SPI_FLASH_EON
-#endif
-
-/*
- * MMC
- */
-#ifdef CONFIG_MMC
-#define CONFIG_ESDHC_DETECT_QUIRK ((readb(QIXIS_BASE + QIXIS_STAT_PRES1) & \
-	QIXIS_SDID_MASK) != QIXIS_ESDHC_NO_ADAPTER)
-#endif
-
-/*
- * RTC configuration
- */
-#define RTC
-#define CONFIG_RTC_DS3231               1
-#define CONFIG_SYS_I2C_RTC_ADDR         0x68
-#define CONFIG_CMD_DATE
-
-/* EEPROM */
-#define CONFIG_ID_EEPROM
-#define CONFIG_CMD_EEPROM
-#define CONFIG_SYS_I2C_EEPROM_NXID
-#define CONFIG_SYS_EEPROM_BUS_NUM	0
-#define CONFIG_SYS_I2C_EEPROM_ADDR	0x57
-#define CONFIG_SYS_I2C_EEPROM_ADDR_LEN	1
-#define CONFIG_SYS_EEPROM_PAGE_WRITE_BITS 3
-#define CONFIG_SYS_EEPROM_PAGE_WRITE_DELAY_MS 5
-
-#define CONFIG_FSL_MEMAC
-#define CONFIG_PCI		/* Enable PCIE */
-#define CONFIG_PCIE_LAYERSCAPE	/* Use common FSL Layerscape PCIe code */
-
-#ifdef CONFIG_PCI
-#define CONFIG_PCI_PNP
-#define CONFIG_PCI_SCAN_SHOW
-#define CONFIG_CMD_PCI
-#endif
-
-/*  MMC  */
-#define CONFIG_MMC
-#ifdef CONFIG_MMC
-#define CONFIG_CMD_MMC
-#define CONFIG_FSL_ESDHC
-#define CONFIG_SYS_FSL_MMC_HAS_CAPBLT_VS33
-#define CONFIG_GENERIC_MMC
-#define CONFIG_CMD_FAT
-#define CONFIG_DOS_PARTITION
-#endif
-
-/* Initial environment variables */
-#undef CONFIG_EXTRA_ENV_SETTINGS
-#define CONFIG_EXTRA_ENV_SETTINGS		\
-	"hwconfig=fsl_ddr:bank_intlv=auto\0"	\
-	"loadaddr=0x80100000\0"			\
-	"kernel_addr=0x100000\0"		\
-	"ramdisk_addr=0x800000\0"		\
-	"ramdisk_size=0x2000000\0"		\
-	"fdt_high=0xa0000000\0"			\
-	"initrd_high=0xffffffffffffffff\0"	\
-	"kernel_start=0x581100000\0"		\
-	"kernel_load=0xa0000000\0"		\
-	"kernel_size=0x28000000\0"
-
-#ifdef CONFIG_FSL_MC_ENET
-#define CONFIG_FSL_MEMAC
-#define	CONFIG_PHYLIB
-#define CONFIG_PHYLIB_10G
-#define	CONFIG_CMD_MII
-#define CONFIG_PHY_VITESSE
-#define CONFIG_PHY_REALTEK
-#define CONFIG_PHY_TERANETICS
-#define SGMII_CARD_PORT1_PHY_ADDR 0x1C
-#define SGMII_CARD_PORT2_PHY_ADDR 0x1d
-#define SGMII_CARD_PORT3_PHY_ADDR 0x1E
-#define SGMII_CARD_PORT4_PHY_ADDR 0x1F
-
-#define XQSGMII_CARD_PHY1_PORT0_ADDR 0x0
-#define XQSGMII_CARD_PHY1_PORT1_ADDR 0x1
-#define XQSGMII_CARD_PHY1_PORT2_ADDR 0x2
-#define XQSGMII_CARD_PHY1_PORT3_ADDR 0x3
-#define XQSGMII_CARD_PHY2_PORT0_ADDR 0x4
-#define XQSGMII_CARD_PHY2_PORT1_ADDR 0x5
-#define XQSGMII_CARD_PHY2_PORT2_ADDR 0x6
-#define XQSGMII_CARD_PHY2_PORT3_ADDR 0x7
-#define XQSGMII_CARD_PHY3_PORT0_ADDR 0x8
-#define XQSGMII_CARD_PHY3_PORT1_ADDR 0x9
-#define XQSGMII_CARD_PHY3_PORT2_ADDR 0xa
-#define XQSGMII_CARD_PHY3_PORT3_ADDR 0xb
-#define XQSGMII_CARD_PHY4_PORT0_ADDR 0xc
-#define XQSGMII_CARD_PHY4_PORT1_ADDR 0xd
-#define XQSGMII_CARD_PHY4_PORT2_ADDR 0xe
-#define XQSGMII_CARD_PHY4_PORT3_ADDR 0xf
-
-#define CONFIG_MII		/* MII PHY management */
-#define CONFIG_ETHPRIME		"DPNI1"
-#define CONFIG_PHY_GIGE		/* Include GbE speed/duplex detection */
-
-#endif
-
-/*
- * USB
- */
-#define CONFIG_HAS_FSL_XHCI_USB
-#define CONFIG_USB_XHCI
-#define CONFIG_USB_XHCI_FSL
-#define CONFIG_USB_XHCI_DWC3
-#define CONFIG_USB_MAX_CONTROLLER_COUNT		2
-#define CONFIG_SYS_USB_XHCI_MAX_ROOT_PORTS	2
-#define CONFIG_CMD_USB
-#define CONFIG_USB_STORAGE
-#define CONFIG_CMD_EXT2
-
-#endif /* __LS2_QDS_H */
diff --git a/include/configs/ls2085ardb.h b/include/configs/ls2085ardb.h
deleted file mode 100644
index 5188dea..0000000
--- a/include/configs/ls2085ardb.h
+++ /dev/null
@@ -1,343 +0,0 @@
-/*
- * Copyright 2015 Freescale Semiconductor
- *
- * SPDX-License-Identifier:	GPL-2.0+
- */
-
-#ifndef __LS2_RDB_H
-#define __LS2_RDB_H
-
-#include "ls2085a_common.h"
-
-#undef CONFIG_CONS_INDEX
-#define CONFIG_CONS_INDEX       2
-
-#define CONFIG_DISPLAY_BOARDINFO
-
-#ifndef __ASSEMBLY__
-unsigned long get_board_sys_clk(void);
-#endif
-
-#define CONFIG_SYS_CLK_FREQ		get_board_sys_clk()
-#define CONFIG_DDR_CLK_FREQ		133333333
-#define COUNTER_FREQUENCY_REAL		(CONFIG_SYS_CLK_FREQ/4)
-
-#define CONFIG_DDR_SPD
-#define CONFIG_DDR_ECC
-#define CONFIG_ECC_INIT_VIA_DDRCONTROLLER
-#define CONFIG_MEM_INIT_VALUE		0xdeadbeef
-#define SPD_EEPROM_ADDRESS1	0x51
-#define SPD_EEPROM_ADDRESS2	0x52
-#define SPD_EEPROM_ADDRESS3	0x53
-#define SPD_EEPROM_ADDRESS4	0x54
-#define SPD_EEPROM_ADDRESS5	0x55
-#define SPD_EEPROM_ADDRESS6	0x56	/* dummy address */
-#define SPD_EEPROM_ADDRESS	SPD_EEPROM_ADDRESS1
-#define CONFIG_SYS_SPD_BUS_NUM	0	/* SPD on I2C bus 0 */
-#define CONFIG_DIMM_SLOTS_PER_CTLR		2
-#define CONFIG_CHIP_SELECTS_PER_CTRL		4
-#define CONFIG_DP_DDR_DIMM_SLOTS_PER_CTLR	1
-#define CONFIG_FSL_DDR_BIST	/* enable built-in memory test */
-
-/* undefined CONFIG_FSL_DDR_SYNC_REFRESH for simulator */
-
-#define CONFIG_SYS_NOR0_CSPR_EXT	(0x0)
-#define CONFIG_SYS_NOR_AMASK		IFC_AMASK(128*1024*1024)
-#define CONFIG_SYS_NOR_AMASK_EARLY	IFC_AMASK(64*1024*1024)
-
-#define CONFIG_SYS_NOR0_CSPR					\
-	(CSPR_PHYS_ADDR(CONFIG_SYS_FLASH_BASE_PHYS)		| \
-	CSPR_PORT_SIZE_16					| \
-	CSPR_MSEL_NOR						| \
-	CSPR_V)
-#define CONFIG_SYS_NOR0_CSPR_EARLY				\
-	(CSPR_PHYS_ADDR(CONFIG_SYS_FLASH_BASE_PHYS_EARLY)	| \
-	CSPR_PORT_SIZE_16					| \
-	CSPR_MSEL_NOR						| \
-	CSPR_V)
-#define CONFIG_SYS_NOR_CSOR	CSOR_NOR_ADM_SHIFT(12)
-#define CONFIG_SYS_NOR_FTIM0	(FTIM0_NOR_TACSE(0x4) | \
-				FTIM0_NOR_TEADC(0x5) | \
-				FTIM0_NOR_TEAHC(0x5))
-#define CONFIG_SYS_NOR_FTIM1	(FTIM1_NOR_TACO(0x35) | \
-				FTIM1_NOR_TRAD_NOR(0x1a) |\
-				FTIM1_NOR_TSEQRAD_NOR(0x13))
-#define CONFIG_SYS_NOR_FTIM2	(FTIM2_NOR_TCS(0x4) | \
-				FTIM2_NOR_TCH(0x4) | \
-				FTIM2_NOR_TWPH(0x0E) | \
-				FTIM2_NOR_TWP(0x1c))
-#define CONFIG_SYS_NOR_FTIM3	0x04000000
-#define CONFIG_SYS_IFC_CCR	0x01000000
-
-#ifndef CONFIG_SYS_NO_FLASH
-#define CONFIG_FLASH_CFI_DRIVER
-#define CONFIG_SYS_FLASH_CFI
-#define CONFIG_SYS_FLASH_USE_BUFFER_WRITE
-#define CONFIG_SYS_FLASH_QUIET_TEST
-#define CONFIG_FLASH_SHOW_PROGRESS	45 /* count down from 45/5: 9..1 */
-
-#define CONFIG_SYS_MAX_FLASH_BANKS	1	/* number of banks */
-#define CONFIG_SYS_MAX_FLASH_SECT	1024	/* sectors per device */
-#define CONFIG_SYS_FLASH_ERASE_TOUT	60000	/* Flash Erase Timeout (ms) */
-#define CONFIG_SYS_FLASH_WRITE_TOUT	500	/* Flash Write Timeout (ms) */
-
-#define CONFIG_SYS_FLASH_EMPTY_INFO
-#define CONFIG_SYS_FLASH_BANKS_LIST	{ CONFIG_SYS_FLASH_BASE,\
-					 CONFIG_SYS_FLASH_BASE + 0x40000000}
-#endif
-
-#define CONFIG_NAND_FSL_IFC
-#define CONFIG_SYS_NAND_MAX_ECCPOS	256
-#define CONFIG_SYS_NAND_MAX_OOBFREE	2
-
-
-#define CONFIG_SYS_NAND_CSPR_EXT	(0x0)
-#define CONFIG_SYS_NAND_CSPR	(CSPR_PHYS_ADDR(CONFIG_SYS_NAND_BASE_PHYS) \
-				| CSPR_PORT_SIZE_8 /* Port Size = 8 bit */ \
-				| CSPR_MSEL_NAND	/* MSEL = NAND */ \
-				| CSPR_V)
-#define CONFIG_SYS_NAND_AMASK	IFC_AMASK(64 * 1024)
-
-#define CONFIG_SYS_NAND_CSOR    (CSOR_NAND_ECC_ENC_EN   /* ECC on encode */ \
-				| CSOR_NAND_ECC_DEC_EN  /* ECC on decode */ \
-				| CSOR_NAND_ECC_MODE_4  /* 4-bit ECC */ \
-				| CSOR_NAND_RAL_3	/* RAL = 3Byes */ \
-				| CSOR_NAND_PGS_4K	/* Page Size = 4K */ \
-				| CSOR_NAND_SPRZ_224	/* Spare size = 224 */ \
-				| CSOR_NAND_PB(128))	/* Pages Per Block 128*/
-
-#define CONFIG_SYS_NAND_ONFI_DETECTION
-
-/* ONFI NAND Flash mode0 Timing Params */
-#define CONFIG_SYS_NAND_FTIM0		(FTIM0_NAND_TCCST(0x0e) | \
-					FTIM0_NAND_TWP(0x30)   | \
-					FTIM0_NAND_TWCHT(0x0e) | \
-					FTIM0_NAND_TWH(0x14))
-#define CONFIG_SYS_NAND_FTIM1		(FTIM1_NAND_TADLE(0x64) | \
-					FTIM1_NAND_TWBE(0xab)  | \
-					FTIM1_NAND_TRR(0x1c)   | \
-					FTIM1_NAND_TRP(0x30))
-#define CONFIG_SYS_NAND_FTIM2		(FTIM2_NAND_TRAD(0x1e) | \
-					FTIM2_NAND_TREH(0x14) | \
-					FTIM2_NAND_TWHRE(0x3c))
-#define CONFIG_SYS_NAND_FTIM3		0x0
-
-#define CONFIG_SYS_NAND_BASE_LIST	{ CONFIG_SYS_NAND_BASE }
-#define CONFIG_SYS_MAX_NAND_DEVICE	1
-#define CONFIG_MTD_NAND_VERIFY_WRITE
-#define CONFIG_CMD_NAND
-
-#define CONFIG_SYS_NAND_BLOCK_SIZE	(512 * 1024)
-
-#define CONFIG_FSL_QIXIS	/* use common QIXIS code */
-#define QIXIS_LBMAP_SWITCH		0x06
-#define QIXIS_LBMAP_MASK		0x0f
-#define QIXIS_LBMAP_SHIFT		0
-#define QIXIS_LBMAP_DFLTBANK		0x00
-#define QIXIS_LBMAP_ALTBANK		0x04
-#define QIXIS_LBMAP_NAND		0x09
-#define QIXIS_RST_CTL_RESET		0x31
-#define QIXIS_RST_CTL_RESET_EN		0x30
-#define QIXIS_RCFG_CTL_RECONFIG_IDLE	0x20
-#define QIXIS_RCFG_CTL_RECONFIG_START	0x21
-#define QIXIS_RCFG_CTL_WATCHDOG_ENBLE	0x08
-#define QIXIS_RCW_SRC_NAND		0x119
-#define	QIXIS_RST_FORCE_MEM		0x01
-
-#define CONFIG_SYS_CSPR3_EXT	(0x0)
-#define CONFIG_SYS_CSPR3	(CSPR_PHYS_ADDR(QIXIS_BASE_PHYS_EARLY) \
-				| CSPR_PORT_SIZE_8 \
-				| CSPR_MSEL_GPCM \
-				| CSPR_V)
-#define CONFIG_SYS_CSPR3_FINAL	(CSPR_PHYS_ADDR(QIXIS_BASE_PHYS) \
-				| CSPR_PORT_SIZE_8 \
-				| CSPR_MSEL_GPCM \
-				| CSPR_V)
-
-#define CONFIG_SYS_AMASK3	IFC_AMASK(64*1024)
-#define CONFIG_SYS_CSOR3	CSOR_GPCM_ADM_SHIFT(12)
-/* QIXIS Timing parameters for IFC CS3 */
-#define CONFIG_SYS_CS3_FTIM0		(FTIM0_GPCM_TACSE(0x0e) | \
-					FTIM0_GPCM_TEADC(0x0e) | \
-					FTIM0_GPCM_TEAHC(0x0e))
-#define CONFIG_SYS_CS3_FTIM1		(FTIM1_GPCM_TACO(0xff) | \
-					FTIM1_GPCM_TRAD(0x3f))
-#define CONFIG_SYS_CS3_FTIM2		(FTIM2_GPCM_TCS(0xf) | \
-					FTIM2_GPCM_TCH(0xf) | \
-					FTIM2_GPCM_TWP(0x3E))
-#define CONFIG_SYS_CS3_FTIM3		0x0
-
-#if defined(CONFIG_SPL) && defined(CONFIG_NAND)
-#define CONFIG_SYS_CSPR2_EXT		CONFIG_SYS_NOR0_CSPR_EXT
-#define CONFIG_SYS_CSPR2		CONFIG_SYS_NOR0_CSPR_EARLY
-#define CONFIG_SYS_CSPR2_FINAL		CONFIG_SYS_NOR0_CSPR
-#define CONFIG_SYS_AMASK2		CONFIG_SYS_NOR_AMASK
-#define CONFIG_SYS_CSOR2		CONFIG_SYS_NOR_CSOR
-#define CONFIG_SYS_CS2_FTIM0		CONFIG_SYS_NOR_FTIM0
-#define CONFIG_SYS_CS2_FTIM1		CONFIG_SYS_NOR_FTIM1
-#define CONFIG_SYS_CS2_FTIM2		CONFIG_SYS_NOR_FTIM2
-#define CONFIG_SYS_CS2_FTIM3		CONFIG_SYS_NOR_FTIM3
-#define CONFIG_SYS_CSPR0_EXT		CONFIG_SYS_NAND_CSPR_EXT
-#define CONFIG_SYS_CSPR0		CONFIG_SYS_NAND_CSPR
-#define CONFIG_SYS_AMASK0		CONFIG_SYS_NAND_AMASK
-#define CONFIG_SYS_CSOR0		CONFIG_SYS_NAND_CSOR
-#define CONFIG_SYS_CS0_FTIM0		CONFIG_SYS_NAND_FTIM0
-#define CONFIG_SYS_CS0_FTIM1		CONFIG_SYS_NAND_FTIM1
-#define CONFIG_SYS_CS0_FTIM2		CONFIG_SYS_NAND_FTIM2
-#define CONFIG_SYS_CS0_FTIM3		CONFIG_SYS_NAND_FTIM3
-
-#define CONFIG_ENV_IS_IN_NAND
-#define CONFIG_ENV_OFFSET		(2048 * 1024)
-#define CONFIG_ENV_SECT_SIZE		0x20000
-#define CONFIG_ENV_SIZE			0x2000
-#define CONFIG_SPL_PAD_TO		0x80000
-#define CONFIG_SYS_NAND_U_BOOT_OFFS	(1024 * 1024)
-#define CONFIG_SYS_NAND_U_BOOT_SIZE	(512 * 1024)
-#else
-#define CONFIG_SYS_CSPR0_EXT		CONFIG_SYS_NOR0_CSPR_EXT
-#define CONFIG_SYS_CSPR0		CONFIG_SYS_NOR0_CSPR_EARLY
-#define CONFIG_SYS_CSPR0_FINAL		CONFIG_SYS_NOR0_CSPR
-#define CONFIG_SYS_AMASK0		CONFIG_SYS_NOR_AMASK
-#define CONFIG_SYS_CSOR0		CONFIG_SYS_NOR_CSOR
-#define CONFIG_SYS_CS0_FTIM0		CONFIG_SYS_NOR_FTIM0
-#define CONFIG_SYS_CS0_FTIM1		CONFIG_SYS_NOR_FTIM1
-#define CONFIG_SYS_CS0_FTIM2		CONFIG_SYS_NOR_FTIM2
-#define CONFIG_SYS_CS0_FTIM3		CONFIG_SYS_NOR_FTIM3
-#define CONFIG_SYS_CSPR2_EXT		CONFIG_SYS_NAND_CSPR_EXT
-#define CONFIG_SYS_CSPR2		CONFIG_SYS_NAND_CSPR
-#define CONFIG_SYS_AMASK2		CONFIG_SYS_NAND_AMASK
-#define CONFIG_SYS_CSOR2		CONFIG_SYS_NAND_CSOR
-#define CONFIG_SYS_CS2_FTIM0		CONFIG_SYS_NAND_FTIM0
-#define CONFIG_SYS_CS2_FTIM1		CONFIG_SYS_NAND_FTIM1
-#define CONFIG_SYS_CS2_FTIM2		CONFIG_SYS_NAND_FTIM2
-#define CONFIG_SYS_CS2_FTIM3		CONFIG_SYS_NAND_FTIM3
-
-#define CONFIG_ENV_IS_IN_FLASH
-#define CONFIG_ENV_ADDR			(CONFIG_SYS_FLASH_BASE + 0x200000)
-#define CONFIG_ENV_SECT_SIZE		0x20000
-#define CONFIG_ENV_SIZE			0x2000
-#endif
-
-/* Debug Server firmware */
-#define CONFIG_SYS_DEBUG_SERVER_FW_IN_NOR
-#define CONFIG_SYS_DEBUG_SERVER_FW_ADDR	0x580D00000ULL
-
-#define CONFIG_SYS_LS_MC_BOOT_TIMEOUT_MS 5000
-
-/*
- * I2C
- */
-#define I2C_MUX_PCA_ADDR		0x75
-#define I2C_MUX_PCA_ADDR_PRI		0x75 /* Primary Mux*/
-
-/* I2C bus multiplexer */
-#define I2C_MUX_CH_DEFAULT      0x8
-
-/* SPI */
-#ifdef CONFIG_FSL_DSPI
-#define CONFIG_CMD_SF
-#define CONFIG_SPI_FLASH
-#define CONFIG_SPI_FLASH_STMICRO
-#define CONFIG_SPI_FLASH_BAR
-#endif
-
-/*
- * RTC configuration
- */
-#define RTC
-#define CONFIG_RTC_DS3231               1
-#define CONFIG_SYS_I2C_RTC_ADDR         0x68
-#define CONFIG_CMD_DATE
-
-/* EEPROM */
-#define CONFIG_ID_EEPROM
-#define CONFIG_CMD_EEPROM
-#define CONFIG_SYS_I2C_EEPROM_NXID
-#define CONFIG_SYS_EEPROM_BUS_NUM	0
-#define CONFIG_SYS_I2C_EEPROM_ADDR	0x57
-#define CONFIG_SYS_I2C_EEPROM_ADDR_LEN	1
-#define CONFIG_SYS_EEPROM_PAGE_WRITE_BITS 3
-#define CONFIG_SYS_EEPROM_PAGE_WRITE_DELAY_MS 5
-
-#define CONFIG_FSL_MEMAC
-#define CONFIG_PCI		/* Enable PCIE */
-#define CONFIG_PCIE_LAYERSCAPE	/* Use common FSL Layerscape PCIe code */
-
-#ifdef CONFIG_PCI
-#define CONFIG_PCI_PNP
-#define CONFIG_PCI_SCAN_SHOW
-#define CONFIG_CMD_PCI
-#endif
-
-/*  MMC  */
-#define CONFIG_MMC
-#ifdef CONFIG_MMC
-#define CONFIG_CMD_MMC
-#define CONFIG_FSL_ESDHC
-#define CONFIG_SYS_FSL_MMC_HAS_CAPBLT_VS33
-#define CONFIG_GENERIC_MMC
-#define CONFIG_CMD_FAT
-#define CONFIG_DOS_PARTITION
-#endif
-
-#define CONFIG_MISC_INIT_R
-
-/*
- * USB
- */
-#define CONFIG_HAS_FSL_XHCI_USB
-#define CONFIG_USB_XHCI
-#define CONFIG_USB_XHCI_FSL
-#define CONFIG_USB_XHCI_DWC3
-#define CONFIG_USB_MAX_CONTROLLER_COUNT         2
-#define CONFIG_SYS_USB_XHCI_MAX_ROOT_PORTS      2
-#define CONFIG_CMD_USB
-#define CONFIG_USB_STORAGE
-#define CONFIG_CMD_EXT2
-
-/* Initial environment variables */
-#undef CONFIG_EXTRA_ENV_SETTINGS
-#define CONFIG_EXTRA_ENV_SETTINGS		\
-	"hwconfig=fsl_ddr:bank_intlv=auto\0"	\
-	"loadaddr=0x80100000\0"			\
-	"kernel_addr=0x100000\0"		\
-	"ramdisk_addr=0x800000\0"		\
-	"ramdisk_size=0x2000000\0"		\
-	"fdt_high=0xa0000000\0"			\
-	"initrd_high=0xffffffffffffffff\0"	\
-	"kernel_start=0x581100000\0"		\
-	"kernel_load=0xa0000000\0"		\
-	"kernel_size=0x2800000\0"
-
-#undef CONFIG_BOOTARGS
-#define CONFIG_BOOTARGS		"console=ttyS1,115200 root=/dev/ram0 " \
-				"earlycon=uart8250,mmio,0x21c0600,115200 " \
-				"ramdisk_size=0x2000000 default_hugepagesz=2m" \
-				" hugepagesz=2m hugepages=16"
-
-/* MAC/PHY configuration */
-#ifdef CONFIG_FSL_MC_ENET
-#define CONFIG_PHYLIB_10G
-#define CONFIG_PHY_AQUANTIA
-#define CONFIG_PHY_CORTINA
-#define CONFIG_PHYLIB
-#define	CONFIG_SYS_CORTINA_FW_IN_NOR
-#define CONFIG_CORTINA_FW_ADDR		0x581000000
-#define CONFIG_CORTINA_FW_LENGTH	0x40000
-
-#define CORTINA_PHY_ADDR1	0x10
-#define CORTINA_PHY_ADDR2	0x11
-#define CORTINA_PHY_ADDR3	0x12
-#define CORTINA_PHY_ADDR4	0x13
-#define AQ_PHY_ADDR1		0x00
-#define AQ_PHY_ADDR2		0x01
-#define AQ_PHY_ADDR3		0x02
-#define AQ_PHY_ADDR4		0x03
-
-#define CONFIG_MII
-#define CONFIG_ETHPRIME		"DPNI1"
-#define CONFIG_PHY_GIGE
-#define CONFIG_PHY_AQUANTIA
-#endif
-
-#endif /* __LS2_RDB_H */
diff --git a/include/linux/usb/xhci-fsl.h b/include/linux/usb/xhci-fsl.h
index b0ff129..c5e42e6 100644
--- a/include/linux/usb/xhci-fsl.h
+++ b/include/linux/usb/xhci-fsl.h
@@ -55,9 +55,9 @@ struct fsl_xhci {
 #define CONFIG_SYS_FSL_XHCI_USB1_ADDR CONFIG_SYS_LS102XA_XHCI_USB1_ADDR
 #define CONFIG_SYS_FSL_XHCI_USB2_ADDR 0
 #define CONFIG_SYS_FSL_XHCI_USB3_ADDR 0
-#elif defined(CONFIG_LS2085A)
-#define CONFIG_SYS_FSL_XHCI_USB1_ADDR CONFIG_SYS_LS2085A_XHCI_USB1_ADDR
-#define CONFIG_SYS_FSL_XHCI_USB2_ADDR CONFIG_SYS_LS2085A_XHCI_USB2_ADDR
+#elif defined(CONFIG_LS2080A)
+#define CONFIG_SYS_FSL_XHCI_USB1_ADDR CONFIG_SYS_LS2080A_XHCI_USB1_ADDR
+#define CONFIG_SYS_FSL_XHCI_USB2_ADDR CONFIG_SYS_LS2080A_XHCI_USB2_ADDR
 #define CONFIG_SYS_FSL_XHCI_USB3_ADDR 0
 #elif defined(CONFIG_LS1043A)
 #define CONFIG_SYS_FSL_XHCI_USB1_ADDR CONFIG_SYS_LS1043A_XHCI_USB1_ADDR
-- 
2.1.0.27.g96db324

