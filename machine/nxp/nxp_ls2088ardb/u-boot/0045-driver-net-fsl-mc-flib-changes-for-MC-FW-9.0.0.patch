From 7e7f3fe7a81f7ab5b229ef0f21697a8f64e77428 Mon Sep 17 00:00:00 2001
From: Prabhakar Kushwaha <prabhakar@freescale.com>
Date: Thu, 24 Dec 2015 15:32:49 +0530
Subject: [PATCH 45/74] driver: net: fsl-mc: flib changes for MC FW 9.0.0

MC firmware version 9.0.0 contains
 - Support of new APIs
 - Update in existing APIs
 - Change in Major and minor version of DPAA2 objects

This patch contains modifications in FLIB files to support new MC firmware
version.

Signed-off-by: Prabhakar Kushwaha <prabhakar.kushwaha@nxp.com>
---
 drivers/net/fsl-mc/dpni.c         |  81 ++++++
 drivers/net/ldpaa_eth/ldpaa_eth.c |   4 +-
 include/fsl-mc/fsl_dpbp.h         |   2 +-
 include/fsl-mc/fsl_dpio.h         |   5 +-
 include/fsl-mc/fsl_dpmac.h        |   2 +-
 include/fsl-mc/fsl_dpmng.h        |   2 +-
 include/fsl-mc/fsl_dpni.h         | 539 +++++++++++++++++++++++++++-----------
 include/fsl-mc/fsl_dprc.h         |  94 ++++++-
 include/fsl-mc/fsl_mc_cmd.h       |   5 +-
 9 files changed, 565 insertions(+), 169 deletions(-)

diff --git a/drivers/net/fsl-mc/dpni.c b/drivers/net/fsl-mc/dpni.c
index eacb3c8..41bf56a 100644
--- a/drivers/net/fsl-mc/dpni.c
+++ b/drivers/net/fsl-mc/dpni.c
@@ -8,6 +8,26 @@
 #include <fsl-mc/fsl_mc_cmd.h>
 #include <fsl-mc/fsl_dpni.h>
 
+int dpni_prepare_extended_cfg(const struct dpni_extended_cfg	*cfg,
+			      uint8_t			*ext_cfg_buf)
+{
+	uint64_t *ext_params = (uint64_t *)ext_cfg_buf;
+
+	DPNI_PREP_EXTENDED_CFG(ext_params, cfg);
+
+	return 0;
+}
+
+int dpni_extract_extended_cfg(struct dpni_extended_cfg	*cfg,
+			      const uint8_t		*ext_cfg_buf)
+{
+	uint64_t *ext_params = (uint64_t *)ext_cfg_buf;
+
+	DPNI_EXT_EXTENDED_CFG(ext_params, cfg);
+
+	return 0;
+}
+
 int dpni_open(struct fsl_mc_io *mc_io,
 	      uint32_t cmd_flags,
 	      int dpni_id,
@@ -162,6 +182,7 @@ int dpni_get_attributes(struct fsl_mc_io *mc_io,
 	cmd.header = mc_encode_cmd_header(DPNI_CMDID_GET_ATTR,
 					  cmd_flags,
 					  token);
+	DPNI_CMD_GET_ATTR(cmd, attr);
 
 	/* send command to mc*/
 	err = mc_send_command(mc_io, &cmd);
@@ -174,6 +195,23 @@ int dpni_get_attributes(struct fsl_mc_io *mc_io,
 	return 0;
 }
 
+int dpni_set_errors_behavior(struct fsl_mc_io *mc_io,
+			     uint32_t cmd_flags,
+			     uint16_t token,
+			      struct dpni_error_cfg *cfg)
+{
+	struct mc_command cmd = { 0 };
+
+	/* prepare command */
+	cmd.header = mc_encode_cmd_header(DPNI_CMDID_SET_ERRORS_BEHAVIOR,
+					  cmd_flags,
+					  token);
+	DPNI_CMD_SET_ERRORS_BEHAVIOR(cmd, cfg);
+
+	/* send command to mc*/
+	return mc_send_command(mc_io, &cmd);
+}
+
 int dpni_get_rx_buffer_layout(struct fsl_mc_io *mc_io,
 			      uint32_t cmd_flags,
 			      uint16_t token,
@@ -602,3 +640,46 @@ int dpni_get_rx_flow(struct fsl_mc_io *mc_io,
 
 	return 0;
 }
+
+int dpni_set_tx_conf(struct fsl_mc_io	*mc_io,
+		     uint32_t		cmd_flags,
+		     uint16_t		token,
+		     uint16_t		flow_id,
+		     const struct dpni_tx_conf_cfg	*cfg)
+{
+	struct mc_command cmd = { 0 };
+
+	/* prepare command */
+	cmd.header = mc_encode_cmd_header(DPNI_CMDID_SET_TX_CONF,
+					  cmd_flags,
+					  token);
+	DPNI_CMD_SET_TX_CONF(cmd, flow_id, cfg);
+
+	/* send command to mc*/
+	return mc_send_command(mc_io, &cmd);
+}
+
+int dpni_get_tx_conf(struct fsl_mc_io		*mc_io,
+		     uint32_t			cmd_flags,
+		     uint16_t			token,
+		     uint16_t			flow_id,
+		     struct dpni_tx_conf_attr	*attr)
+{
+	struct mc_command cmd = { 0 };
+	int err;
+
+	/* prepare command */
+	cmd.header = mc_encode_cmd_header(DPNI_CMDID_GET_TX_CONF,
+					  cmd_flags,
+					  token);
+	DPNI_CMD_GET_TX_CONF(cmd, flow_id);
+
+	/* send command to mc*/
+	err = mc_send_command(mc_io, &cmd);
+	if (err)
+		return err;
+
+	DPNI_RSP_GET_TX_CONF(cmd, attr);
+
+	return 0;
+}
diff --git a/drivers/net/ldpaa_eth/ldpaa_eth.c b/drivers/net/ldpaa_eth/ldpaa_eth.c
index 47a3a23..85eb2c4 100644
--- a/drivers/net/ldpaa_eth/ldpaa_eth.c
+++ b/drivers/net/ldpaa_eth/ldpaa_eth.c
@@ -798,9 +798,7 @@ static int ldpaa_dpni_bind(struct ldpaa_eth_priv *priv)
 	priv->tx_flow_id = DPNI_NEW_FLOW_ID;
 	memset(&dflt_tx_flow, 0, sizeof(dflt_tx_flow));
 
-	dflt_tx_flow.options = DPNI_TX_FLOW_OPT_ONLY_TX_ERROR;
-	dflt_tx_flow.conf_err_cfg.use_default_queue = 0;
-	dflt_tx_flow.conf_err_cfg.errors_only = 1;
+	dflt_tx_flow.use_common_tx_conf_queue = 0;
 	err = dpni_set_tx_flow(dflt_mc_io, MC_CMD_NO_FLAGS,
 			       dflt_dpni->dpni_handle, &priv->tx_flow_id,
 			       &dflt_tx_flow);
diff --git a/include/fsl-mc/fsl_dpbp.h b/include/fsl-mc/fsl_dpbp.h
index 92c5437..b1ad46e 100644
--- a/include/fsl-mc/fsl_dpbp.h
+++ b/include/fsl-mc/fsl_dpbp.h
@@ -15,7 +15,7 @@
 
 /* DPBP Version */
 #define DPBP_VER_MAJOR				2
-#define DPBP_VER_MINOR				1
+#define DPBP_VER_MINOR				2
 
 /* Command IDs */
 #define DPBP_CMDID_CLOSE				0x800
diff --git a/include/fsl-mc/fsl_dpio.h b/include/fsl-mc/fsl_dpio.h
index 0bc0b44..d8c458f 100644
--- a/include/fsl-mc/fsl_dpio.h
+++ b/include/fsl-mc/fsl_dpio.h
@@ -9,7 +9,7 @@
 
 /* DPIO Version */
 #define DPIO_VER_MAJOR				3
-#define DPIO_VER_MINOR				1
+#define DPIO_VER_MINOR				2
 
 /* Command IDs */
 #define DPIO_CMDID_CLOSE					0x800
@@ -45,6 +45,7 @@ do { \
 	MC_RSP_OP(cmd, 2, 0,  64, uint64_t, attr->qbman_portal_ci_offset);\
 	MC_RSP_OP(cmd, 3, 0,  16, uint16_t, attr->version.major);\
 	MC_RSP_OP(cmd, 3, 16, 16, uint16_t, attr->version.minor);\
+	MC_RSP_OP(cmd, 3, 32, 32, uint32_t, attr->qbman_version);\
 } while (0)
 
 /* Data Path I/O Portal API
@@ -195,6 +196,7 @@ int dpio_reset(struct fsl_mc_io	*mc_io,
  * @channel_mode: Notification channel mode
  * @num_priorities: Number of priorities for the notification channel (1-8);
  *			relevant only if 'channel_mode = DPIO_LOCAL_CHANNEL'
+ * @qbman_version: QBMAN version
  */
 struct dpio_attr {
 	int id;
@@ -212,6 +214,7 @@ struct dpio_attr {
 	uint16_t qbman_portal_id;
 	enum dpio_channel_mode channel_mode;
 	uint8_t num_priorities;
+	uint32_t		qbman_version;
 };
 
 /**
diff --git a/include/fsl-mc/fsl_dpmac.h b/include/fsl-mc/fsl_dpmac.h
index 24f0b48..296f3ae 100644
--- a/include/fsl-mc/fsl_dpmac.h
+++ b/include/fsl-mc/fsl_dpmac.h
@@ -12,7 +12,7 @@
 
 /* DPMAC Version */
 #define DPMAC_VER_MAJOR				3
-#define DPMAC_VER_MINOR				1
+#define DPMAC_VER_MINOR				2
 
 /* Command IDs */
 #define DPMAC_CMDID_CLOSE			0x800
diff --git a/include/fsl-mc/fsl_dpmng.h b/include/fsl-mc/fsl_dpmng.h
index b0a87a9..023b5bb 100644
--- a/include/fsl-mc/fsl_dpmng.h
+++ b/include/fsl-mc/fsl_dpmng.h
@@ -14,7 +14,7 @@ struct fsl_mc_io;
 /**
  * Management Complex firmware version information
  */
-#define MC_VER_MAJOR 8
+#define MC_VER_MAJOR 9
 #define MC_VER_MINOR 0
 
 /**
diff --git a/include/fsl-mc/fsl_dpni.h b/include/fsl-mc/fsl_dpni.h
index 140a009..f396dc3 100644
--- a/include/fsl-mc/fsl_dpni.h
+++ b/include/fsl-mc/fsl_dpni.h
@@ -7,8 +7,8 @@
 #define _FSL_DPNI_H
 
 /* DPNI Version */
-#define DPNI_VER_MAJOR				5
-#define DPNI_VER_MINOR				1
+#define DPNI_VER_MAJOR				6
+#define DPNI_VER_MINOR				0
 
 /* Command IDs */
 #define DPNI_CMDID_OPEN				0x801
@@ -28,6 +28,7 @@
 #define DPNI_CMDID_SET_TX_BUFFER_LAYOUT		0x204
 #define DPNI_CMDID_SET_TX_CONF_BUFFER_LAYOUT	0x205
 #define DPNI_CMDID_GET_TX_CONF_BUFFER_LAYOUT	0x206
+#define DPNI_CMDID_SET_ERRORS_BEHAVIOR		0x20B
 
 #define DPNI_CMDID_GET_QDID			0x210
 #define DPNI_CMDID_GET_TX_DATA_OFFSET		0x212
@@ -45,11 +46,73 @@
 #define DPNI_CMDID_GET_TX_FLOW			0x237
 #define DPNI_CMDID_SET_RX_FLOW			0x238
 #define DPNI_CMDID_GET_RX_FLOW			0x239
+#define DPNI_CMDID_SET_TX_CONF						0x257
+#define DPNI_CMDID_GET_TX_CONF						0x258
 
 /*                cmd, param, offset, width, type, arg_name */
 #define DPNI_CMD_OPEN(cmd, dpni_id) \
 	MC_CMD_OP(cmd,	 0,	0,	32,	int,	dpni_id)
 
+#define DPNI_PREP_EXTENDED_CFG(ext, cfg) \
+do { \
+	MC_PREP_OP(ext, 0, 0,   16, uint16_t, cfg->tc_cfg[0].max_dist); \
+	MC_PREP_OP(ext, 0, 16,  16, uint16_t, cfg->tc_cfg[0].max_fs_entries); \
+	MC_PREP_OP(ext, 0, 32,  16, uint16_t, cfg->tc_cfg[1].max_dist); \
+	MC_PREP_OP(ext, 0, 48,  16, uint16_t, cfg->tc_cfg[1].max_fs_entries); \
+	MC_PREP_OP(ext, 1, 0,   16, uint16_t, cfg->tc_cfg[2].max_dist); \
+	MC_PREP_OP(ext, 1, 16,  16, uint16_t, cfg->tc_cfg[2].max_fs_entries); \
+	MC_PREP_OP(ext, 1, 32,  16, uint16_t, cfg->tc_cfg[3].max_dist); \
+	MC_PREP_OP(ext, 1, 48,  16, uint16_t, cfg->tc_cfg[3].max_fs_entries); \
+	MC_PREP_OP(ext, 2, 0,   16, uint16_t, cfg->tc_cfg[4].max_dist); \
+	MC_PREP_OP(ext, 2, 16,  16, uint16_t, cfg->tc_cfg[4].max_fs_entries); \
+	MC_PREP_OP(ext, 2, 32,  16, uint16_t, cfg->tc_cfg[5].max_dist); \
+	MC_PREP_OP(ext, 2, 48,  16, uint16_t, cfg->tc_cfg[5].max_fs_entries); \
+	MC_PREP_OP(ext, 3, 0,   16, uint16_t, cfg->tc_cfg[6].max_dist); \
+	MC_PREP_OP(ext, 3, 16,  16, uint16_t, cfg->tc_cfg[6].max_fs_entries); \
+	MC_PREP_OP(ext, 3, 32,  16, uint16_t, cfg->tc_cfg[7].max_dist); \
+	MC_PREP_OP(ext, 3, 48,  16, uint16_t, cfg->tc_cfg[7].max_fs_entries); \
+	MC_PREP_OP(ext, 4, 0,   16, uint16_t, \
+		   cfg->ipr_cfg.max_open_frames_ipv4); \
+	MC_PREP_OP(ext, 4, 16,  16, uint16_t, \
+		   cfg->ipr_cfg.max_open_frames_ipv6); \
+	MC_PREP_OP(ext, 4, 32,  16, uint16_t, \
+		   cfg->ipr_cfg.max_reass_frm_size); \
+	MC_PREP_OP(ext, 5, 0,   16, uint16_t, \
+		   cfg->ipr_cfg.min_frag_size_ipv4); \
+	MC_PREP_OP(ext, 5, 16,  16, uint16_t, \
+		   cfg->ipr_cfg.min_frag_size_ipv6); \
+} while (0)
+
+#define DPNI_EXT_EXTENDED_CFG(ext, cfg) \
+do { \
+	MC_EXT_OP(ext, 0, 0,   16, uint16_t, cfg->tc_cfg[0].max_dist); \
+	MC_EXT_OP(ext, 0, 16,  16, uint16_t, cfg->tc_cfg[0].max_fs_entries); \
+	MC_EXT_OP(ext, 0, 32,  16, uint16_t, cfg->tc_cfg[1].max_dist); \
+	MC_EXT_OP(ext, 0, 48,  16, uint16_t, cfg->tc_cfg[1].max_fs_entries); \
+	MC_EXT_OP(ext, 1, 0,   16, uint16_t, cfg->tc_cfg[2].max_dist); \
+	MC_EXT_OP(ext, 1, 16,  16, uint16_t, cfg->tc_cfg[2].max_fs_entries); \
+	MC_EXT_OP(ext, 1, 32,  16, uint16_t, cfg->tc_cfg[3].max_dist); \
+	MC_EXT_OP(ext, 1, 48,  16, uint16_t, cfg->tc_cfg[3].max_fs_entries); \
+	MC_EXT_OP(ext, 2, 0,   16, uint16_t, cfg->tc_cfg[4].max_dist); \
+	MC_EXT_OP(ext, 2, 16,  16, uint16_t, cfg->tc_cfg[4].max_fs_entries); \
+	MC_EXT_OP(ext, 2, 32,  16, uint16_t, cfg->tc_cfg[5].max_dist); \
+	MC_EXT_OP(ext, 2, 48,  16, uint16_t, cfg->tc_cfg[5].max_fs_entries); \
+	MC_EXT_OP(ext, 3, 0,   16, uint16_t, cfg->tc_cfg[6].max_dist); \
+	MC_EXT_OP(ext, 3, 16,  16, uint16_t, cfg->tc_cfg[6].max_fs_entries); \
+	MC_EXT_OP(ext, 3, 32,  16, uint16_t, cfg->tc_cfg[7].max_dist); \
+	MC_EXT_OP(ext, 3, 48,  16, uint16_t, cfg->tc_cfg[7].max_fs_entries); \
+	MC_EXT_OP(ext, 4, 0,   16, uint16_t, \
+		  cfg->ipr_cfg.max_open_frames_ipv4); \
+	MC_EXT_OP(ext, 4, 16,  16, uint16_t, \
+		  cfg->ipr_cfg.max_open_frames_ipv6); \
+	MC_EXT_OP(ext, 4, 32,  16, uint16_t, \
+		  cfg->ipr_cfg.max_reass_frm_size); \
+	MC_EXT_OP(ext, 5, 0,   16, uint16_t, \
+		  cfg->ipr_cfg.min_frag_size_ipv4); \
+	MC_EXT_OP(ext, 5, 16,  16, uint16_t, \
+		  cfg->ipr_cfg.min_frag_size_ipv6); \
+} while (0)
+
 /*                cmd, param, offset, width, type, arg_name */
 #define DPNI_CMD_CREATE(cmd, cfg) \
 do { \
@@ -69,32 +132,23 @@ do { \
 	MC_CMD_OP(cmd, 2, 32,	8,  uint8_t,  cfg->adv.max_qos_key_size); \
 	MC_CMD_OP(cmd, 2, 48,	8,  uint8_t,  cfg->adv.max_dist_key_size); \
 	MC_CMD_OP(cmd, 2, 56,	8,  enum net_prot, cfg->adv.start_hdr); \
-	MC_CMD_OP(cmd, 3, 0,	8,  uint8_t,  cfg->adv.max_dist_per_tc[0]); \
-	MC_CMD_OP(cmd, 3, 8,	8,  uint8_t,  cfg->adv.max_dist_per_tc[1]); \
-	MC_CMD_OP(cmd, 3, 16,	8,  uint8_t,  cfg->adv.max_dist_per_tc[2]); \
-	MC_CMD_OP(cmd, 3, 24,	8,  uint8_t,  cfg->adv.max_dist_per_tc[3]); \
-	MC_CMD_OP(cmd, 3, 32,	8,  uint8_t,  cfg->adv.max_dist_per_tc[4]); \
-	MC_CMD_OP(cmd, 3, 40,	8,  uint8_t,  cfg->adv.max_dist_per_tc[5]); \
-	MC_CMD_OP(cmd, 3, 48,	8,  uint8_t,  cfg->adv.max_dist_per_tc[6]); \
-	MC_CMD_OP(cmd, 3, 56,	8,  uint8_t,  cfg->adv.max_dist_per_tc[7]); \
-	MC_CMD_OP(cmd, 4, 0,	16, uint16_t, \
-				    cfg->adv.ipr_cfg.max_reass_frm_size); \
-	MC_CMD_OP(cmd, 4, 16,	16, uint16_t, \
-				    cfg->adv.ipr_cfg.min_frag_size_ipv4); \
-	MC_CMD_OP(cmd, 4, 32,	16, uint16_t, \
-				    cfg->adv.ipr_cfg.min_frag_size_ipv6); \
 	MC_CMD_OP(cmd, 4, 48,	8,  uint8_t, cfg->adv.max_policers); \
 	MC_CMD_OP(cmd, 4, 56,	8,  uint8_t, cfg->adv.max_congestion_ctrl); \
-	MC_CMD_OP(cmd, 5, 0,	16, uint16_t, \
-				  cfg->adv.ipr_cfg.max_open_frames_ipv4); \
-	MC_CMD_OP(cmd, 5, 16,	16, uint16_t, \
-				  cfg->adv.ipr_cfg.max_open_frames_ipv6); \
+	MC_CMD_OP(cmd, 5, 0,	64, uint64_t, cfg->adv.ext_cfg_iova); \
 } while (0)
 
 /*                cmd, param, offset, width, type, arg_name */
 #define DPNI_CMD_SET_POOLS(cmd, cfg) \
 do { \
 	MC_CMD_OP(cmd, 0, 0,  8,  uint8_t,  cfg->num_dpbp); \
+	MC_CMD_OP(cmd, 0, 8,  1,  int,      cfg->pools[0].backup_pool); \
+	MC_CMD_OP(cmd, 0, 9,  1,  int,      cfg->pools[1].backup_pool); \
+	MC_CMD_OP(cmd, 0, 10, 1,  int,      cfg->pools[2].backup_pool); \
+	MC_CMD_OP(cmd, 0, 11, 1,  int,      cfg->pools[3].backup_pool); \
+	MC_CMD_OP(cmd, 0, 12, 1,  int,      cfg->pools[4].backup_pool); \
+	MC_CMD_OP(cmd, 0, 13, 1,  int,      cfg->pools[5].backup_pool); \
+	MC_CMD_OP(cmd, 0, 14, 1,  int,      cfg->pools[6].backup_pool); \
+	MC_CMD_OP(cmd, 0, 15, 1,  int,      cfg->pools[7].backup_pool); \
 	MC_CMD_OP(cmd, 0, 32, 32, int,      cfg->pools[0].dpbp_id); \
 	MC_CMD_OP(cmd, 4, 32, 16, uint16_t, cfg->pools[0].buffer_size);\
 	MC_CMD_OP(cmd, 1, 0,  32, int,      cfg->pools[1].dpbp_id); \
@@ -114,6 +168,10 @@ do { \
 } while (0)
 
 /*                cmd, param, offset, width, type, arg_name */
+#define DPNI_CMD_GET_ATTR(cmd, attr) \
+	MC_CMD_OP(cmd, 6, 0,  64, uint64_t, attr->ext_cfg_iova)
+
+/*                cmd, param, offset, width, type, arg_name */
 #define DPNI_RSP_GET_ATTR(cmd, attr) \
 do { \
 	MC_RSP_OP(cmd, 0, 0,  32, int,	    attr->id);\
@@ -127,31 +185,21 @@ do { \
 	MC_RSP_OP(cmd, 2, 24, 8,  uint8_t,  attr->max_qos_entries); \
 	MC_RSP_OP(cmd, 2, 32, 8,  uint8_t,  attr->max_qos_key_size); \
 	MC_RSP_OP(cmd, 2, 40, 8,  uint8_t,  attr->max_dist_key_size); \
-	MC_RSP_OP(cmd, 3, 0,  8,  uint8_t,  attr->max_dist_per_tc[0]); \
-	MC_RSP_OP(cmd, 3, 8,  8,  uint8_t,  attr->max_dist_per_tc[1]); \
-	MC_RSP_OP(cmd, 3, 16, 8,  uint8_t,  attr->max_dist_per_tc[2]); \
-	MC_RSP_OP(cmd, 3, 24, 8,  uint8_t,  attr->max_dist_per_tc[3]); \
-	MC_RSP_OP(cmd, 3, 32, 8,  uint8_t,  attr->max_dist_per_tc[4]); \
-	MC_RSP_OP(cmd, 3, 40, 8,  uint8_t,  attr->max_dist_per_tc[5]); \
-	MC_RSP_OP(cmd, 3, 48, 8,  uint8_t,  attr->max_dist_per_tc[6]); \
-	MC_RSP_OP(cmd, 3, 56, 8,  uint8_t,  attr->max_dist_per_tc[7]); \
-	MC_RSP_OP(cmd, 4, 0,	16, uint16_t, \
-				    attr->ipr_cfg.max_reass_frm_size); \
-	MC_RSP_OP(cmd, 4, 16,	16, uint16_t, \
-				    attr->ipr_cfg.min_frag_size_ipv4); \
-	MC_RSP_OP(cmd, 4, 32,	16, uint16_t, \
-				    attr->ipr_cfg.min_frag_size_ipv6);\
-	MC_RSP_OP(cmd, 4, 48,	8,  uint8_t, attr->max_policers); \
-	MC_RSP_OP(cmd, 4, 56,	8,  uint8_t, attr->max_congestion_ctrl); \
-	MC_RSP_OP(cmd, 5, 0,	16, uint16_t, \
-				  attr->ipr_cfg.max_open_frames_ipv4); \
-	MC_RSP_OP(cmd, 5, 16,	16, uint16_t, \
-				  attr->ipr_cfg.max_open_frames_ipv6); \
+	MC_RSP_OP(cmd, 4, 48, 8,  uint8_t, attr->max_policers); \
+	MC_RSP_OP(cmd, 4, 56, 8,  uint8_t, attr->max_congestion_ctrl); \
 	MC_RSP_OP(cmd, 5, 32, 16, uint16_t, attr->version.major);\
 	MC_RSP_OP(cmd, 5, 48, 16, uint16_t, attr->version.minor);\
 } while (0)
 
 /*                cmd, param, offset, width, type, arg_name */
+#define DPNI_CMD_SET_ERRORS_BEHAVIOR(cmd, cfg) \
+do { \
+	MC_CMD_OP(cmd, 0, 0,  32, uint32_t, cfg->errors); \
+	MC_CMD_OP(cmd, 0, 32, 4,  enum dpni_error_action, cfg->error_action); \
+	MC_CMD_OP(cmd, 0, 36, 1,  int,      cfg->set_frame_annotation); \
+} while (0)
+
+/*                cmd, param, offset, width, type, arg_name */
 #define DPNI_RSP_GET_RX_BUFFER_LAYOUT(cmd, layout) \
 do { \
 	MC_RSP_OP(cmd, 0, 0,  16, uint16_t, layout->private_data_size); \
@@ -313,23 +361,11 @@ do { \
 /*                cmd, param, offset, width, type, arg_name */
 #define DPNI_CMD_SET_TX_FLOW(cmd, flow_id, cfg) \
 do { \
-	MC_CMD_OP(cmd, 0, 0,  32, int,     \
-			   cfg->conf_err_cfg.queue_cfg.dest_cfg.dest_id);\
-	MC_CMD_OP(cmd, 0, 32, 8,  uint8_t, \
-			   cfg->conf_err_cfg.queue_cfg.dest_cfg.priority);\
-	MC_CMD_OP(cmd, 0, 40, 2,  enum dpni_dest, \
-			   cfg->conf_err_cfg.queue_cfg.dest_cfg.dest_type);\
-	MC_CMD_OP(cmd, 0, 42, 1,  int,	    cfg->conf_err_cfg.errors_only);\
 	MC_CMD_OP(cmd, 0, 43, 1,  int,	    cfg->l3_chksum_gen);\
 	MC_CMD_OP(cmd, 0, 44, 1,  int,	    cfg->l4_chksum_gen);\
-	MC_CMD_OP(cmd, 0, 45, 1,  int,	    \
-			   cfg->conf_err_cfg.use_default_queue);\
+	MC_CMD_OP(cmd, 0, 45, 1,  int,	    cfg->use_common_tx_conf_queue);\
 	MC_CMD_OP(cmd, 0, 48, 16, uint16_t, flow_id);\
-	MC_CMD_OP(cmd, 1, 0,  64, uint64_t, \
-			   cfg->conf_err_cfg.queue_cfg.user_ctx);\
 	MC_CMD_OP(cmd, 2, 0,  32, uint32_t, cfg->options);\
-	MC_CMD_OP(cmd, 2, 32,  32, uint32_t, \
-			   cfg->conf_err_cfg.queue_cfg.options);\
 } while (0)
 
 /*                cmd, param, offset, width, type, arg_name */
@@ -343,21 +379,9 @@ do { \
 /*                cmd, param, offset, width, type, arg_name */
 #define DPNI_RSP_GET_TX_FLOW(cmd, attr) \
 do { \
-	MC_RSP_OP(cmd, 0, 0,  32, int,      \
-			attr->conf_err_attr.queue_attr.dest_cfg.dest_id);\
-	MC_RSP_OP(cmd, 0, 32, 8,  uint8_t,  \
-			attr->conf_err_attr.queue_attr.dest_cfg.priority);\
-	MC_RSP_OP(cmd, 0, 40, 2,  enum dpni_dest, \
-			attr->conf_err_attr.queue_attr.dest_cfg.dest_type);\
-	MC_RSP_OP(cmd, 0, 42, 1,  int,	    attr->conf_err_attr.errors_only);\
 	MC_RSP_OP(cmd, 0, 43, 1,  int,	    attr->l3_chksum_gen);\
 	MC_RSP_OP(cmd, 0, 44, 1,  int,	    attr->l4_chksum_gen);\
-	MC_RSP_OP(cmd, 0, 45, 1,  int,	    \
-			attr->conf_err_attr.use_default_queue);\
-	MC_RSP_OP(cmd, 1, 0,  64, uint64_t, \
-			attr->conf_err_attr.queue_attr.user_ctx);\
-	MC_RSP_OP(cmd, 2, 32, 32, uint32_t, \
-			attr->conf_err_attr.queue_attr.fqid);\
+	MC_RSP_OP(cmd, 0, 45, 1,  int,	    attr->use_common_tx_conf_queue);\
 } while (0)
 
 /*                cmd, param, offset, width, type, arg_name */
@@ -370,7 +394,7 @@ do { \
 	MC_CMD_OP(cmd, 0, 48, 16, uint16_t, flow_id); \
 	MC_CMD_OP(cmd, 1, 0,  64, uint64_t, cfg->user_ctx); \
 	MC_CMD_OP(cmd, 2, 16, 8,  uint8_t,  tc_id); \
-	MC_CMD_OP(cmd, 2, 32,  32, uint32_t, cfg->options); \
+	MC_CMD_OP(cmd, 2, 32, 32, uint32_t, cfg->options); \
 	MC_CMD_OP(cmd, 3, 0,  4,  enum dpni_flc_type, cfg->flc_cfg.flc_type); \
 	MC_CMD_OP(cmd, 3, 4,  4,  enum dpni_stash_size, \
 		cfg->flc_cfg.frame_data_size);\
@@ -378,6 +402,7 @@ do { \
 		cfg->flc_cfg.flow_context_size);\
 	MC_CMD_OP(cmd, 3, 32, 32, uint32_t, cfg->flc_cfg.options);\
 	MC_CMD_OP(cmd, 4, 0,  64, uint64_t, cfg->flc_cfg.flow_context);\
+	MC_CMD_OP(cmd, 5, 0,  32, uint32_t, cfg->tail_drop_threshold); \
 } while (0)
 
 /*                cmd, param, offset, width, type, arg_name */
@@ -393,8 +418,9 @@ do { \
 	MC_RSP_OP(cmd, 0, 0,  32, int,      attr->dest_cfg.dest_id); \
 	MC_RSP_OP(cmd, 0, 32, 8,  uint8_t,  attr->dest_cfg.priority);\
 	MC_RSP_OP(cmd, 0, 40, 2,  enum dpni_dest, attr->dest_cfg.dest_type); \
-	MC_CMD_OP(cmd, 0, 42, 1,  int,      attr->order_preservation_en);\
+	MC_RSP_OP(cmd, 0, 42, 1,  int,      attr->order_preservation_en);\
 	MC_RSP_OP(cmd, 1, 0,  64, uint64_t, attr->user_ctx); \
+	MC_RSP_OP(cmd, 2, 0,  32, uint32_t, attr->tail_drop_threshold); \
 	MC_RSP_OP(cmd, 2, 32, 32, uint32_t, attr->fqid); \
 	MC_RSP_OP(cmd, 3, 0,  4,  enum dpni_flc_type, attr->flc_cfg.flc_type); \
 	MC_RSP_OP(cmd, 3, 4,  4,  enum dpni_stash_size, \
@@ -405,6 +431,58 @@ do { \
 	MC_RSP_OP(cmd, 4, 0,  64, uint64_t, attr->flc_cfg.flow_context);\
 } while (0)
 
+#define DPNI_CMD_SET_TX_CONF(cmd, flow_id, cfg) \
+do { \
+	MC_CMD_OP(cmd, 0, 32, 8,  uint8_t, cfg->queue_cfg.dest_cfg.priority); \
+	MC_CMD_OP(cmd, 0, 40, 2,  enum dpni_dest, \
+		cfg->queue_cfg.dest_cfg.dest_type); \
+	MC_CMD_OP(cmd, 0, 42, 1,  int, cfg->errors_only); \
+	MC_CMD_OP(cmd, 0, 46, 1,  int, cfg->queue_cfg.order_preservation_en); \
+	MC_CMD_OP(cmd, 0, 48, 16, uint16_t, flow_id); \
+	MC_CMD_OP(cmd, 1, 0,  64, uint64_t, cfg->queue_cfg.user_ctx); \
+	MC_CMD_OP(cmd, 2, 0,  32, uint32_t, cfg->queue_cfg.options); \
+	MC_CMD_OP(cmd, 2, 32, 32, int,	    cfg->queue_cfg.dest_cfg.dest_id); \
+	MC_CMD_OP(cmd, 3, 0,  32, uint32_t, \
+		cfg->queue_cfg.tail_drop_threshold); \
+	MC_CMD_OP(cmd, 4, 0,  4,  enum dpni_flc_type, \
+		cfg->queue_cfg.flc_cfg.flc_type); \
+	MC_CMD_OP(cmd, 4, 4,  4,  enum dpni_stash_size, \
+		cfg->queue_cfg.flc_cfg.frame_data_size); \
+	MC_CMD_OP(cmd, 4, 8,  4,  enum dpni_stash_size, \
+		cfg->queue_cfg.flc_cfg.flow_context_size); \
+	MC_CMD_OP(cmd, 4, 32, 32, uint32_t, cfg->queue_cfg.flc_cfg.options); \
+	MC_CMD_OP(cmd, 5, 0,  64, uint64_t, \
+		cfg->queue_cfg.flc_cfg.flow_context); \
+} while (0)
+
+#define DPNI_CMD_GET_TX_CONF(cmd, flow_id) \
+		MC_CMD_OP(cmd, 0, 48, 16, uint16_t,  flow_id)
+
+#define DPNI_RSP_GET_TX_CONF(cmd, attr) \
+do { \
+	MC_RSP_OP(cmd, 0, 32, 8,  uint8_t, \
+		  attr->queue_attr.dest_cfg.priority); \
+	MC_RSP_OP(cmd, 0, 40, 2,  enum dpni_dest, \
+		attr->queue_attr.dest_cfg.dest_type); \
+	MC_RSP_OP(cmd, 0, 42, 1,  int, attr->errors_only); \
+	MC_RSP_OP(cmd, 0, 46, 1,  int, \
+		  attr->queue_attr.order_preservation_en); \
+	MC_RSP_OP(cmd, 1, 0,  64, uint64_t, attr->queue_attr.user_ctx); \
+	MC_RSP_OP(cmd, 2, 32, 32, int,	attr->queue_attr.dest_cfg.dest_id); \
+	MC_RSP_OP(cmd, 3, 0,  32, uint32_t, \
+		attr->queue_attr.tail_drop_threshold); \
+	MC_RSP_OP(cmd, 3, 32, 32, uint32_t, attr->queue_attr.fqid); \
+	MC_RSP_OP(cmd, 4, 0,  4,  enum dpni_flc_type, \
+		attr->queue_attr.flc_cfg.flc_type); \
+	MC_RSP_OP(cmd, 4, 4,  4,  enum dpni_stash_size, \
+		attr->queue_attr.flc_cfg.frame_data_size); \
+	MC_RSP_OP(cmd, 4, 8,  4,  enum dpni_stash_size, \
+		attr->queue_attr.flc_cfg.flow_context_size); \
+	MC_RSP_OP(cmd, 4, 32, 32, uint32_t, attr->queue_attr.flc_cfg.options); \
+	MC_RSP_OP(cmd, 5, 0,  64, uint64_t, \
+		attr->queue_attr.flc_cfg.flow_context); \
+} while (0)
+
 enum net_prot {
 	NET_PROT_NONE = 0,
 	NET_PROT_PAYLOAD,
@@ -479,6 +557,8 @@ struct fsl_mc_io;
 #define DPNI_ALL_TC_FLOWS			(uint16_t)(-1)
 /* Generate new flow ID; see dpni_set_tx_flow() */
 #define DPNI_NEW_FLOW_ID			(uint16_t)(-1)
+/* use for common tx-conf queue; see dpni_set_tx_conf_<x>() */
+#define DPNI_COMMON_TX_CONF			(uint16_t)(-1)
 
 /**
  * dpni_open() - Open a control session for the specified object
@@ -565,22 +645,56 @@ int dpni_close(struct fsl_mc_io	*mc_io,
 #define DPNI_OPT_FS_MASK_SUPPORT		0x00040000
 
 /**
- * struct dpni_ipr_cfg - Structure representing IP reassembly configuration
- * @max_reass_frm_size: Maximum size of the reassembled frame
- * @min_frag_size_ipv4: Minimum fragment size of IPv4 fragments
- * @min_frag_size_ipv6: Minimum fragment size of IPv6 fragments
- * @max_open_frames_ipv4: Maximum concurrent IPv4 packets in reassembly process
- * @max_open_frames_ipv6: Maximum concurrent IPv6 packets in reassembly process
+ * struct dpni_extended_cfg - Structure representing extended DPNI configuration
+ * @tc_cfg: TCs configuration
+ * @ipr_cfg: IP reassembly configuration
  */
-struct dpni_ipr_cfg {
-	uint16_t max_reass_frm_size;
-	uint16_t min_frag_size_ipv4;
-	uint16_t min_frag_size_ipv6;
-	uint16_t max_open_frames_ipv4;
-	uint16_t max_open_frames_ipv6;
+struct dpni_extended_cfg {
+	/**
+	 * struct tc_cfg - TC configuration
+	 * @max_dist: Maximum distribution size for Rx traffic class;
+	 *	supported values: 1,2,3,4,6,7,8,12,14,16,24,28,32,48,56,64,96,
+	 *	112,128,192,224,256,384,448,512,768,896,1024;
+	 *	value '0' will be treated as '1'.
+	 *	other unsupported values will be round down to the nearest
+	 *	supported value.
+	 * @max_fs_entries: Maximum FS entries for Rx traffic class;
+	 *	'0' means no support for this TC;
+	 */
+	struct {
+		uint16_t	max_dist;
+		uint16_t	max_fs_entries;
+	} tc_cfg[DPNI_MAX_TC];
+	/**
+	 * struct ipr_cfg - Structure representing IP reassembly configuration
+	 * @max_reass_frm_size: Maximum size of the reassembled frame
+	 * @min_frag_size_ipv4: Minimum fragment size of IPv4 fragments
+	 * @min_frag_size_ipv6: Minimum fragment size of IPv6 fragments
+	 * @max_open_frames_ipv4: Maximum concurrent IPv4 packets in reassembly
+	 *		process
+	 * @max_open_frames_ipv6: Maximum concurrent IPv6 packets in reassembly
+	 *		process
+	 */
+	struct {
+		uint16_t max_reass_frm_size;
+		uint16_t min_frag_size_ipv4;
+		uint16_t min_frag_size_ipv6;
+		uint16_t max_open_frames_ipv4;
+		uint16_t max_open_frames_ipv6;
+	} ipr_cfg;
 };
 
 /**
+ * dpni_prepare_extended_cfg() - function prepare extended parameters
+ * @cfg: extended structure
+ * @ext_cfg_buf: Zeroed 256 bytes of memory before mapping it to DMA
+ *
+ * This function has to be called before dpni_create()
+ */
+int dpni_prepare_extended_cfg(const struct dpni_extended_cfg	*cfg,
+			      uint8_t			*ext_cfg_buf);
+
+/**
  * struct dpni_cfg - Structure representing DPNI configuration
  * @mac_addr: Primary MAC address
  * @adv: Advanced parameters; default is all zeros;
@@ -599,11 +713,6 @@ struct dpni_cfg {
 	 *		'0' will be treated as '1'
 	 * @max_tcs: Maximum number of traffic classes (for both Tx and Rx);
 	 *		'0' will e treated as '1'
-	 * @max_dist_per_tc: Maximum distribution size per Rx traffic class;
-	 *			Must be set to the required value minus 1;
-	 *			i.e. 0->1, 1->2, ... ,255->256;
-	 *			Non-power-of-2 values are rounded up to the next
-	 *			power-of-2 value as hardware demands it
 	 * @max_unicast_filters: Maximum number of unicast filters;
 	 *			'0' is treated	as '16'
 	 * @max_multicast_filters: Maximum number of multicast filters;
@@ -619,16 +728,17 @@ struct dpni_cfg {
 	 *		should be between '0' and max_tcs
 	 * @max_congestion_ctrl: Maximum number of congestion control groups
 	 *		(CGs); covers early drop and congestion notification
-	 *		requirements for traffic classes;
-	 *		should be between '0' and max_tcs
-	 * @ipr_cfg: IP reassembly configuration
+	 *		requirements;
+	 *		should be between '0' and ('max_tcs' + 'max_senders')
+	 * @ext_cfg_iova: I/O virtual address of 256 bytes DMA-able memory
+	 *		filled with the extended configuration by calling
+	 *		dpni_prepare_extended_cfg()
 	 */
 	struct {
 		uint32_t		options;
 		enum net_prot		start_hdr;
 		uint8_t		max_senders;
 		uint8_t		max_tcs;
-		uint8_t			max_dist_per_tc[DPNI_MAX_TC];
 		uint8_t		max_unicast_filters;
 		uint8_t		max_multicast_filters;
 		uint8_t			max_vlan_filters;
@@ -637,7 +747,7 @@ struct dpni_cfg {
 		uint8_t		max_dist_key_size;
 		uint8_t		max_policers;
 		uint8_t		max_congestion_ctrl;
-		struct dpni_ipr_cfg	ipr_cfg;
+		uint64_t	ext_cfg_iova;
 	} adv;
 };
 
@@ -765,8 +875,6 @@ int dpni_reset(struct fsl_mc_io	*mc_io,
  * @max_senders: Maximum number of different senders; used as the number
  *		of dedicated Tx flows;
  * @max_tcs: Maximum number of traffic classes (for both Tx and Rx)
- * @max_dist_per_tc: Maximum distribution size per Rx traffic class;
- *			Set to the required value minus 1
  * @max_unicast_filters: Maximum number of unicast filters
  * @max_multicast_filters: Maximum number of multicast filters
  * @max_vlan_filters: Maximum number of VLAN filters
@@ -775,7 +883,8 @@ int dpni_reset(struct fsl_mc_io	*mc_io,
  * @max_dist_key_size: Maximum key size for the distribution look-up
  * @max_policers: Maximum number of policers;
  * @max_congestion_ctrl: Maximum number of congestion control groups (CGs);
- * @ipr_cfg: IP reassembly configuration
+ * @ext_cfg_iova: I/O virtual address of 256 bytes DMA-able memory;
+ *	call dpni_extract_extended_cfg() to extract the extended configuration
  */
 struct dpni_attr {
 	int id;
@@ -792,7 +901,6 @@ struct dpni_attr {
 	uint32_t options;
 	uint8_t max_senders;
 	uint8_t max_tcs;
-	uint8_t max_dist_per_tc[DPNI_MAX_TC];
 	uint8_t max_unicast_filters;
 	uint8_t max_multicast_filters;
 	uint8_t max_vlan_filters;
@@ -801,7 +909,7 @@ struct dpni_attr {
 	uint8_t max_dist_key_size;
 	uint8_t max_policers;
 	uint8_t max_congestion_ctrl;
-	struct dpni_ipr_cfg ipr_cfg;
+	uint64_t	ext_cfg_iova;
 };
 
 /**
@@ -809,7 +917,7 @@ struct dpni_attr {
  * @mc_io:	Pointer to MC portal's I/O object
  * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:	Token of DPNI object
- * @attr:	Returned object's attributes
+ * @attr:	Object's attributes
  *
  * Return:	'0' on Success; Error code otherwise.
  */
@@ -818,6 +926,87 @@ int dpni_get_attributes(struct fsl_mc_io	*mc_io,
 			uint16_t		token,
 			struct dpni_attr	*attr);
 
+/**
+ * dpni_extract_extended_cfg() - extract the extended parameters
+ * @cfg: extended structure
+ * @ext_cfg_buf: 256 bytes of DMA-able memory
+ *
+ * This function has to be called after dpni_get_attributes()
+ */
+int dpni_extract_extended_cfg(struct dpni_extended_cfg	*cfg,
+			      const uint8_t		*ext_cfg_buf);
+
+/**
+ * DPNI errors
+ */
+
+/**
+ * Extract out of frame header error
+ */
+#define DPNI_ERROR_EOFHE	0x00020000
+/**
+ * Frame length error
+ */
+#define DPNI_ERROR_FLE		0x00002000
+/**
+ * Frame physical error
+ */
+#define DPNI_ERROR_FPE		0x00001000
+/**
+ * Parsing header error
+ */
+#define DPNI_ERROR_PHE		0x00000020
+/**
+ * Parser L3 checksum error
+ */
+#define DPNI_ERROR_L3CE		0x00000004
+/**
+ * Parser L3 checksum error
+ */
+#define DPNI_ERROR_L4CE		0x00000001
+
+/**
+ * enum dpni_error_action - Defines DPNI behavior for errors
+ * @DPNI_ERROR_ACTION_DISCARD: Discard the frame
+ * @DPNI_ERROR_ACTION_CONTINUE: Continue with the normal flow
+ * @DPNI_ERROR_ACTION_SEND_TO_ERROR_QUEUE: Send the frame to the error queue
+ */
+enum dpni_error_action {
+	DPNI_ERROR_ACTION_DISCARD = 0,
+	DPNI_ERROR_ACTION_CONTINUE = 1,
+	DPNI_ERROR_ACTION_SEND_TO_ERROR_QUEUE = 2
+};
+
+/**
+ * struct dpni_error_cfg - Structure representing DPNI errors treatment
+ * @errors: Errors mask; use 'DPNI_ERROR__<X>
+ * @error_action: The desired action for the errors mask
+ * @set_frame_annotation: Set to '1' to mark the errors in frame annotation
+ *		status (FAS); relevant only for the non-discard action
+ */
+struct dpni_error_cfg {
+	uint32_t		errors;
+	enum dpni_error_action	error_action;
+	int			set_frame_annotation;
+};
+
+/**
+ * dpni_set_errors_behavior() - Set errors behavior
+ * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
+ * @token:	Token of DPNI object
+ * @cfg:	Errors configuration
+ *
+ * this function may be called numerous times with different
+ * error masks
+ *
+ * Return:	'0' on Success; Error code otherwise.
+ */
+int dpni_set_errors_behavior(struct fsl_mc_io		*mc_io,
+			     uint32_t			cmd_flags,
+			     uint16_t			token,
+			     struct dpni_error_cfg	*cfg);
+
 /* DPNI buffer layout modification options */
 
 /* Select to modify the time-stamp setting */
@@ -1254,6 +1443,8 @@ struct dpni_flc_cfg {
 #define DPNI_QUEUE_OPT_FLC		0x00000004
 /* Select to modify the queue's order preservation */
 #define DPNI_QUEUE_OPT_ORDER_PRESERVATION 0x00000008
+/* Select to modify the queue's tail-drop threshold */
+#define DPNI_QUEUE_OPT_TAILDROP_THRESHOLD 0x00000010
 
 /**
  * struct dpni_queue_cfg - Structure representing queue configuration
@@ -1272,6 +1463,10 @@ struct dpni_flc_cfg {
  * @order_preservation_en: enable/disable order preservation;
  *		valid only if 'DPNI_QUEUE_OPT_ORDER_PRESERVATION' is contained
  *		in 'options'
+ * @tail_drop_threshold: set the queue's tail drop threshold in bytes;
+ *		'0' value disable the threshold; maximum value is 0xE000000;
+ *		valid only if 'DPNI_QUEUE_OPT_TAILDROP_THRESHOLD' is contained
+ *		in 'options'
  */
 struct dpni_queue_cfg {
 	uint32_t options;
@@ -1279,6 +1474,7 @@ struct dpni_queue_cfg {
 	struct dpni_dest_cfg dest_cfg;
 	struct dpni_flc_cfg flc_cfg;
 	int order_preservation_en;
+	uint32_t tail_drop_threshold;
 };
 
 /**
@@ -1288,6 +1484,7 @@ struct dpni_queue_cfg {
  * @dest_cfg: Queue destination configuration
  * @flc_cfg: Flow context configuration
  * @order_preservation_en: enable/disable order preservation
+ * @tail_drop_threshold: queue's tail drop threshold in bytes;
  * @fqid: Virtual fqid value to be used for dequeue operations
  */
 struct dpni_queue_attr {
@@ -1295,6 +1492,7 @@ struct dpni_queue_attr {
 	struct dpni_dest_cfg dest_cfg;
 	struct dpni_flc_cfg flc_cfg;
 	int order_preservation_en;
+	uint32_t tail_drop_threshold;
 	uint32_t fqid;
 };
 
@@ -1302,10 +1500,6 @@ struct dpni_queue_attr {
 
 /* Select to modify the settings for dedicate Tx confirmation/error */
 #define DPNI_TX_FLOW_OPT_TX_CONF_ERROR	0x00000001
-/*!< Select to modify the Tx confirmation and/or error setting */
-#define DPNI_TX_FLOW_OPT_ONLY_TX_ERROR	0x00000002
-/*!< Select to modify the queue configuration */
-#define DPNI_TX_FLOW_OPT_QUEUE		0x00000004
 /*!< Select to modify the L3 checksum generation setting */
 #define DPNI_TX_FLOW_OPT_L3_CHKSUM_GEN	0x00000010
 /*!< Select to modify the L4 checksum generation setting */
@@ -1314,41 +1508,22 @@ struct dpni_queue_attr {
 /**
  * struct dpni_tx_flow_cfg - Structure representing Tx flow configuration
  * @options: Flags representing the suggested modifications to the Tx flow;
- *		Use any combination 'DPNI_TX_FLOW_OPT_<X>' flags
- * @conf_err_cfg: Tx confirmation and error configuration; these settings are
- *		ignored if 'DPNI_OPT_PRIVATE_TX_CONF_ERROR_DISABLED' was set at
- *		DPNI creation
+ *	Use any combination 'DPNI_TX_FLOW_OPT_<X>' flags
+ * @use_common_tx_conf_queue: Set to '1' to use the common (default) Tx
+ *	confirmation and error queue; Set to '0' to use the private
+ *	Tx confirmation and error queue; valid only if
+ *	'DPNI_OPT_PRIVATE_TX_CONF_ERROR_DISABLED' wasn't set at DPNI creation
+ *	and 'DPNI_TX_FLOW_OPT_TX_CONF_ERROR' is contained in 'options'
  * @l3_chksum_gen: Set to '1' to enable L3 checksum generation; '0' to disable;
- *		valid only if 'DPNI_TX_FLOW_OPT_L3_CHKSUM_GEN' is contained in
- *		'options'
+ *	valid only if 'DPNI_TX_FLOW_OPT_L3_CHKSUM_GEN' is contained in 'options'
  * @l4_chksum_gen: Set to '1' to enable L4 checksum generation; '0' to disable;
- *		valid only if 'DPNI_TX_FLOW_OPT_L4_CHKSUM_GEN' is contained in
- *		'options'
+ *	valid only if 'DPNI_TX_FLOW_OPT_L4_CHKSUM_GEN' is contained in 'options'
  */
 struct dpni_tx_flow_cfg {
-	uint32_t options;
-	/**
-	 * struct cnf_err_cfg - Tx confirmation and error configuration
-	 * @use_default_queue: Set to '1' to use the common (default) Tx
-	 *		confirmation and error queue; Set to '0' to use the
-	 *		private Tx confirmation and error queue; valid only if
-	 *		'DPNI_TX_FLOW_OPT_TX_CONF_ERROR' is contained in
-	 *		'options'
-	 * @errors_only: Set to '1' to report back only error frames;
-	 *		Set to '0' to confirm transmission/error for all
-	 *		transmitted frames;
-	 *		valid only if 'DPNI_TX_FLOW_OPT_ONLY_TX_ERROR' is
-	 *		contained in 'options' and 'use_default_queue = 0';
-	 * @queue_cfg: Queue configuration; valid only if
-	 *		'DPNI_TX_FLOW_OPT_QUEUE' is contained in 'options'
-	 */
-	struct {
-		int use_default_queue;
-		int errors_only;
-		struct dpni_queue_cfg queue_cfg;
-	} conf_err_cfg;
-	int l3_chksum_gen;
-	int l4_chksum_gen;
+	uint32_t	options;
+	int		use_common_tx_conf_queue;
+	int		l3_chksum_gen;
+	int		l4_chksum_gen;
 };
 
 /**
@@ -1357,10 +1532,9 @@ struct dpni_tx_flow_cfg {
  * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:	Token of DPNI object
  * @flow_id:	Provides (or returns) the sender's flow ID;
- *				for each new sender set (*flow_id) to
- *				'DPNI_NEW_FLOW_ID' to generate a new flow_id;
- *				this ID should be used as the QDBIN argument
- *				in enqueue operations
+ *	for each new sender set (*flow_id) to 'DPNI_NEW_FLOW_ID' to generate
+ *	a new flow_id;	this ID should be used as the QDBIN argument
+ *	in enqueue operations
  * @cfg:	Tx flow configuration
  *
  * Return:	'0' on Success; Error code otherwise.
@@ -1373,28 +1547,15 @@ int dpni_set_tx_flow(struct fsl_mc_io			*mc_io,
 
 /**
  * struct dpni_tx_flow_attr - Structure representing Tx flow attributes
- * @conf_err_attr: Tx confirmation and error attributes
+ * @use_common_tx_conf_queue: '1' if using common (default) Tx confirmation and
+ *	error queue; '0' if using private Tx confirmation and error queue
  * @l3_chksum_gen: '1' if L3 checksum generation is enabled; '0' if disabled
  * @l4_chksum_gen: '1' if L4 checksum generation is enabled; '0' if disabled
  */
 struct dpni_tx_flow_attr {
-	/**
-	 * struct conf_err_attr - Tx confirmation and error attributes
-	 * @use_default_queue: '1' if using common (default) Tx confirmation and
-	 *			error queue;
-	 *			'0' if using private Tx confirmation and error
-	 *			queue
-	 * @errors_only: '1' if only error frames are reported back; '0' if all
-	 *		transmitted frames are confirmed
-	 * @queue_attr: Queue attributes
-	 */
-	struct {
-		int use_default_queue;
-		int errors_only;
-		struct dpni_queue_attr queue_attr;
-	} conf_err_attr;
-	int l3_chksum_gen;
-	int l4_chksum_gen;
+	int	use_common_tx_conf_queue;
+	int	l3_chksum_gen;
+	int	l4_chksum_gen;
 };
 
 /**
@@ -1403,7 +1564,7 @@ struct dpni_tx_flow_attr {
  * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:	Token of DPNI object
  * @flow_id:	The sender's flow ID, as returned by the
- *			dpni_set_tx_flow() function
+ *	dpni_set_tx_flow() function
  * @attr:	Returned Tx flow attributes
  *
  * Return:	'0' on Success; Error code otherwise.
@@ -1415,6 +1576,76 @@ int dpni_get_tx_flow(struct fsl_mc_io		*mc_io,
 		     struct dpni_tx_flow_attr	*attr);
 
 /**
+ * struct dpni_tx_conf_cfg - Structure representing Tx conf configuration
+ * @errors_only: Set to '1' to report back only error frames;
+ *	Set to '0' to confirm transmission/error for all transmitted frames;
+ * @queue_cfg: Queue configuration
+ */
+struct dpni_tx_conf_cfg {
+	int			errors_only;
+	struct dpni_queue_cfg	queue_cfg;
+};
+
+/**
+ * dpni_set_tx_conf() - Set Tx confirmation and error queue configuration
+ * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
+ * @token:	Token of DPNI object
+ * @flow_id:	The sender's flow ID, as returned by the
+ *	dpni_set_tx_flow() function;
+ *	use 'DPNI_COMMON_TX_CONF' for common tx-conf
+ * @cfg:	Queue configuration
+ *
+ * If either 'DPNI_OPT_TX_CONF_DISABLED' or
+ * 'DPNI_OPT_PRIVATE_TX_CONF_ERROR_DISABLED' were selected at DPNI creation,
+ * this function can ONLY be used with 'flow_id == DPNI_COMMON_TX_CONF';
+ * i.e. only serve the common tx-conf-err queue;
+ * if 'DPNI_OPT_TX_CONF_DISABLED' was selected, only error frames are reported
+ * back - successfully transmitted frames are not confirmed. Otherwise, all
+ * transmitted frames are sent for confirmation.
+ *
+ * Return:	'0' on Success; Error code otherwise.
+ */
+int dpni_set_tx_conf(struct fsl_mc_io	*mc_io,
+		     uint32_t		cmd_flags,
+		     uint16_t		token,
+		     uint16_t		flow_id,
+		     const struct dpni_tx_conf_cfg	*cfg);
+
+/**
+ * struct dpni_tx_conf_attr - Structure representing Tx conf attributes
+ * @errors_only: '1' if only error frames are reported back; '0' if all
+ *		transmitted frames are confirmed
+ * @queue_attr: Queue attributes
+ */
+struct dpni_tx_conf_attr {
+	int			errors_only;
+	struct dpni_queue_attr	queue_attr;
+};
+
+/**
+ * dpni_get_tx_conf() - Get Tx confirmation and error queue attributes
+ * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
+ * @token:	Token of DPNI object
+ * @flow_id:	The sender's flow ID, as returned by the
+ *	dpni_set_tx_flow() function;
+ *	use 'DPNI_COMMON_TX_CONF' for common tx-conf
+ * @attr:	Returned tx-conf attributes
+ *
+ * If either 'DPNI_OPT_TX_CONF_DISABLED' or
+ * 'DPNI_OPT_PRIVATE_TX_CONF_ERROR_DISABLED' were selected at DPNI creation,
+ * this function can ONLY be used with 'flow_id == DPNI_COMMON_TX_CONF';
+ * i.e. only serve the common tx-conf-err queue;
+ *
+ * Return:	'0' on Success; Error code otherwise.
+ */
+int dpni_get_tx_conf(struct fsl_mc_io	*mc_io,
+		     uint32_t		cmd_flags,
+		     uint16_t		token,
+		     uint16_t		flow_id,
+		     struct dpni_tx_conf_attr	*attr);
+/**
  * dpni_set_rx_flow() - Set Rx flow configuration
  * @mc_io:	Pointer to MC portal's I/O object
  * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
diff --git a/include/fsl-mc/fsl_dprc.h b/include/fsl-mc/fsl_dprc.h
index a87179d..535c789 100644
--- a/include/fsl-mc/fsl_dprc.h
+++ b/include/fsl-mc/fsl_dprc.h
@@ -11,7 +11,7 @@
 
 /* DPRC Version */
 #define DPRC_VER_MAJOR				5
-#define DPRC_VER_MINOR				0
+#define DPRC_VER_MINOR				1
 
 /* Command IDs */
 #define DPRC_CMDID_CLOSE			0x800
@@ -110,6 +110,74 @@ do { \
 	MC_RSP_OP(cmd, 1, 32, 32, uint32_t, obj_desc->state);\
 	MC_RSP_OP(cmd, 2, 0,  16, uint16_t, obj_desc->ver_major);\
 	MC_RSP_OP(cmd, 2, 16, 16, uint16_t, obj_desc->ver_minor);\
+	MC_RSP_OP(cmd, 2, 32, 16, uint16_t, obj_desc->flags); \
+	MC_RSP_OP(cmd, 3, 0,  8,  char,	    obj_desc->type[0]);\
+	MC_RSP_OP(cmd, 3, 8,  8,  char,	    obj_desc->type[1]);\
+	MC_RSP_OP(cmd, 3, 16, 8,  char,	    obj_desc->type[2]);\
+	MC_RSP_OP(cmd, 3, 24, 8,  char,	    obj_desc->type[3]);\
+	MC_RSP_OP(cmd, 3, 32, 8,  char,	    obj_desc->type[4]);\
+	MC_RSP_OP(cmd, 3, 40, 8,  char,	    obj_desc->type[5]);\
+	MC_RSP_OP(cmd, 3, 48, 8,  char,	    obj_desc->type[6]);\
+	MC_RSP_OP(cmd, 3, 56, 8,  char,	    obj_desc->type[7]);\
+	MC_RSP_OP(cmd, 4, 0,  8,  char,	    obj_desc->type[8]);\
+	MC_RSP_OP(cmd, 4, 8,  8,  char,	    obj_desc->type[9]);\
+	MC_RSP_OP(cmd, 4, 16, 8,  char,	    obj_desc->type[10]);\
+	MC_RSP_OP(cmd, 4, 24, 8,  char,	    obj_desc->type[11]);\
+	MC_RSP_OP(cmd, 4, 32, 8,  char,	    obj_desc->type[12]);\
+	MC_RSP_OP(cmd, 4, 40, 8,  char,	    obj_desc->type[13]);\
+	MC_RSP_OP(cmd, 4, 48, 8,  char,	    obj_desc->type[14]);\
+	MC_RSP_OP(cmd, 4, 56, 8,  char,	    obj_desc->type[15]);\
+	MC_RSP_OP(cmd, 5, 0,  8,  char,	    obj_desc->label[0]);\
+	MC_RSP_OP(cmd, 5, 8,  8,  char,	    obj_desc->label[1]);\
+	MC_RSP_OP(cmd, 5, 16, 8,  char,	    obj_desc->label[2]);\
+	MC_RSP_OP(cmd, 5, 24, 8,  char,	    obj_desc->label[3]);\
+	MC_RSP_OP(cmd, 5, 32, 8,  char,	    obj_desc->label[4]);\
+	MC_RSP_OP(cmd, 5, 40, 8,  char,	    obj_desc->label[5]);\
+	MC_RSP_OP(cmd, 5, 48, 8,  char,	    obj_desc->label[6]);\
+	MC_RSP_OP(cmd, 5, 56, 8,  char,	    obj_desc->label[7]);\
+	MC_RSP_OP(cmd, 6, 0,  8,  char,	    obj_desc->label[8]);\
+	MC_RSP_OP(cmd, 6, 8,  8,  char,	    obj_desc->label[9]);\
+	MC_RSP_OP(cmd, 6, 16, 8,  char,	    obj_desc->label[10]);\
+	MC_RSP_OP(cmd, 6, 24, 8,  char,	    obj_desc->label[11]);\
+	MC_RSP_OP(cmd, 6, 32, 8,  char,	    obj_desc->label[12]);\
+	MC_RSP_OP(cmd, 6, 40, 8,  char,	    obj_desc->label[13]);\
+	MC_RSP_OP(cmd, 6, 48, 8,  char,	    obj_desc->label[14]);\
+	MC_RSP_OP(cmd, 6, 56, 8,  char,	    obj_desc->label[15]);\
+} while (0)
+
+/*                cmd, param, offset, width, type, arg_name */
+#define DPRC_CMD_GET_OBJ_DESC(cmd, obj_type, obj_id) \
+do { \
+	MC_CMD_OP(cmd, 0, 0,  32, int,	    obj_id);\
+	MC_CMD_OP(cmd, 1, 0,  8,  char,     obj_type[0]);\
+	MC_CMD_OP(cmd, 1, 8,  8,  char,	    obj_type[1]);\
+	MC_CMD_OP(cmd, 1, 16, 8,  char,	    obj_type[2]);\
+	MC_CMD_OP(cmd, 1, 24, 8,  char,	    obj_type[3]);\
+	MC_CMD_OP(cmd, 1, 32, 8,  char,	    obj_type[4]);\
+	MC_CMD_OP(cmd, 1, 40, 8,  char,	    obj_type[5]);\
+	MC_CMD_OP(cmd, 1, 48, 8,  char,	    obj_type[6]);\
+	MC_CMD_OP(cmd, 1, 56, 8,  char,	    obj_type[7]);\
+	MC_CMD_OP(cmd, 2, 0,  8,  char,	    obj_type[8]);\
+	MC_CMD_OP(cmd, 2, 8,  8,  char,	    obj_type[9]);\
+	MC_CMD_OP(cmd, 2, 16, 8,  char,	    obj_type[10]);\
+	MC_CMD_OP(cmd, 2, 24, 8,  char,	    obj_type[11]);\
+	MC_CMD_OP(cmd, 2, 32, 8,  char,	    obj_type[12]);\
+	MC_CMD_OP(cmd, 2, 40, 8,  char,	    obj_type[13]);\
+	MC_CMD_OP(cmd, 2, 48, 8,  char,     obj_type[14]);\
+	MC_CMD_OP(cmd, 2, 56, 8,  char,	    obj_type[15]);\
+} while (0)
+
+/*                cmd, param, offset, width, type, arg_name */
+#define DPRC_RSP_GET_OBJ_DESC(cmd, obj_desc) \
+do { \
+	MC_RSP_OP(cmd, 0, 32, 32, int,	    obj_desc->id); \
+	MC_RSP_OP(cmd, 1, 0,  16, uint16_t, obj_desc->vendor); \
+	MC_RSP_OP(cmd, 1, 16, 8,  uint8_t,  obj_desc->irq_count); \
+	MC_RSP_OP(cmd, 1, 24, 8,  uint8_t,  obj_desc->region_count); \
+	MC_RSP_OP(cmd, 1, 32, 32, uint32_t, obj_desc->state);\
+	MC_RSP_OP(cmd, 2, 0,  16, uint16_t, obj_desc->ver_major);\
+	MC_RSP_OP(cmd, 2, 16, 16, uint16_t, obj_desc->ver_minor);\
+	MC_RSP_OP(cmd, 2, 32, 16, uint16_t, obj_desc->flags); \
 	MC_RSP_OP(cmd, 3, 0,  8,  char,	    obj_desc->type[0]);\
 	MC_RSP_OP(cmd, 3, 8,  8,  char,	    obj_desc->type[1]);\
 	MC_RSP_OP(cmd, 3, 16, 8,  char,	    obj_desc->type[2]);\
@@ -480,14 +548,13 @@ int dprc_close(struct fsl_mc_io	*mc_io,
  */
 #define DPRC_CFG_OPT_TOPOLOGY_CHANGES_ALLOWED	0x00000008
 
-/* IOMMU bypass - indicates whether objects of this container are permitted
- * to bypass the IOMMU.
- */
-#define DPRC_CFG_OPT_IOMMU_BYPASS		0x00000010
 
-/* AIOP - Indicates that container belongs to AIOP.  */
+/* AIOP - Indicates that container belongs to AIOP. */
 #define DPRC_CFG_OPT_AIOP			0x00000020
 
+/* IRQ Config - Indicates that the container allowed to configure its IRQs.*/
+#define DPRC_CFG_OPT_IRQ_CFG_ALLOWED		0x00000040
+
 /**
  * struct dprc_cfg - Container configuration options
  * @icid: Container's ICID; if set to 'DPRC_GET_ICID_FROM_POOL', a free
@@ -637,6 +704,14 @@ int dprc_get_obj_count(struct fsl_mc_io	*mc_io,
 #define DPRC_OBJ_STATE_PLUGGED		0x00000002
 
 /**
+ * Shareability flag - Object flag indicating no memory shareability.
+ *  the object generates memory accesses that are non coherent with other
+ *  masters;
+ *  user is responsible for proper memory handling through IOMMU configuration.
+ */
+#define DPRC_OBJ_FLAG_NO_MEM_SHAREABILITY		0x0001
+
+/**
  * struct dprc_obj_desc - Object descriptor, returned from dprc_get_obj()
  * @type: Type of object: NULL terminated string
  * @id: ID of logical object resource
@@ -647,6 +722,7 @@ int dprc_get_obj_count(struct fsl_mc_io	*mc_io,
  * @region_count: Number of mappable regions supported by the object
  * @state: Object state: combination of DPRC_OBJ_STATE_ states
  * @label: Object label
+ * @flags: Object's flags
  */
 struct dprc_obj_desc {
 	char type[16];
@@ -658,6 +734,7 @@ struct dprc_obj_desc {
 	uint8_t region_count;
 	uint32_t state;
 	char label[16];
+	uint16_t	flags;
 };
 
 /**
@@ -859,7 +936,10 @@ int dprc_disconnect(struct fsl_mc_io		*mc_io,
 * @token:	Token of DPRC object
 * @endpoint1:	Endpoint 1 configuration parameters
 * @endpoint2:	Returned endpoint 2 configuration parameters
-* @state:	Returned link state: 1 - link is up, 0 - link is down
+* @state:	Returned link state:
+*           1 - link is up;
+*           0 - link is down;
+*           -1 - no connection (endpoint2 information is irrelevant)
 *
 * Return:     '0' on Success; -ENAVAIL if connection does not exist.
 */
diff --git a/include/fsl-mc/fsl_mc_cmd.h b/include/fsl-mc/fsl_mc_cmd.h
index 7f87d4e..f3d1498 100644
--- a/include/fsl-mc/fsl_mc_cmd.h
+++ b/include/fsl-mc/fsl_mc_cmd.h
@@ -68,8 +68,11 @@ enum mc_cmd_status {
 #define MC_CMD_HDR_READ_TOKEN(_hdr) \
 	((uint16_t)mc_dec((_hdr), MC_CMD_HDR_TOKEN_O, MC_CMD_HDR_TOKEN_S))
 
+#define MC_PREP_OP(_ext, _param, _offset, _width, _type, _arg) \
+	((_ext)[_param] |= cpu_to_le64(mc_enc((_offset), (_width), _arg)))
+
 #define MC_EXT_OP(_ext, _param, _offset, _width, _type, _arg) \
-	((_ext)[_param] |= mc_enc((_offset), (_width), _arg))
+	(_arg = (_type)mc_dec(cpu_to_le64(_ext[_param]), (_offset), (_width)))
 
 #define MC_CMD_OP(_cmd, _param, _offset, _width, _type, _arg) \
 	((_cmd).params[_param] |= mc_enc((_offset), (_width), _arg))
-- 
2.1.0.27.g96db324

