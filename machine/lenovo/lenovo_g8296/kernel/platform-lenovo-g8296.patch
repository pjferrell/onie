diff --git a/arch/powerpc/boot/dts/lenovo_g8296.dts b/arch/powerpc/boot/dts/lenovo_g8296.dts
new file mode 100644
index 0000000..5e92dad
--- /dev/null
+++ b/arch/powerpc/boot/dts/lenovo_g8296.dts
@@ -0,0 +1,1293 @@
+
+/dts-v1/;
+
+/ {
+	model = "lenovo,g8296";
+	compatible = "lenovo,g8296";
+	#address-cells = <2>;
+	#size-cells = <2>;
+	interrupt-parent = <&mpic>;
+
+	aliases {
+		ccsr = &soc;
+
+		ethernet0 = &enet0;
+		serial0 = &serial0;
+		pci0 = &pci0;
+		pci1 = &pci1;
+		pci2 = &pci2;
+		usb0 = &usb0;
+/*		usb1 = &usb1; */
+		dma0 = &dma0;
+		dma1 = &dma1;
+		bman = &bman;
+		qman = &qman;
+		pme = &pme;
+		sdhc = &sdhc;
+		msi0 = &msi0;
+		msi1 = &msi1;
+		msi2 = &msi2;
+
+		crypto = &crypto;
+/*		sec_jq0 = &sec_jq0;
+		sec_jq1 = &sec_jq1;
+		sec_jq2 = &sec_jq2;
+		sec_jq3 = &sec_jq3;
+		rtic_a = &rtic_a;
+		rtic_b = &rtic_b;
+		rtic_c = &rtic_c;
+		rtic_d = &rtic_d; */
+		snvs = &snvs;
+
+		fman0 = &fman0;
+		fman0_oh0 = &fman0_oh0;
+		fman0_oh1 = &fman0_oh1;
+		fman0_oh2 = &fman0_oh2;
+		fman0_oh3 = &fman0_oh3;
+		fman0_oh4 = &fman0_oh4;
+		fman0_oh5 = &fman0_oh5;
+		fman0_oh6 = &fman0_oh6;
+		fman0_rx0 = &fman0_rx0;
+		fman0_rx1 = &fman0_rx1;
+		fman0_rx2 = &fman0_rx2;
+		fman0_rx3 = &fman0_rx3;
+		fman0_rx4 = &fman0_rx4;
+
+		fman1 = &fman1;
+		fman1_oh0 = &fman1_oh0;
+		fman1_oh1 = &fman1_oh1;
+		fman1_oh2 = &fman1_oh2;
+		fman1_oh3 = &fman1_oh3;
+		fman1_oh4 = &fman1_oh4;
+		fman1_oh5 = &fman1_oh5;
+		fman1_oh6 = &fman1_oh6;
+		fman1_rx0 = &fman1_rx0;
+		fman1_rx1 = &fman1_rx1;
+		fman1_rx2 = &fman1_rx2;
+		fman1_rx3 = &fman1_rx3;
+		fman1_rx4 = &fman1_rx4;
+		/*rio0 = &rapidio0;*/
+	};
+
+	cpus {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		cpu0: PowerPC,e500mc@0 {
+			device_type = "cpu";
+			reg = <0>;
+			next-level-cache = <&L2_0>;
+			L2_0: l2-cache {
+				next-level-cache = <&cpc>;
+			};
+		};
+		cpu1: PowerPC,e500mc@1 {
+			device_type = "cpu";
+			reg = <1>;
+			next-level-cache = <&L2_1>;
+			L2_1: l2-cache {
+				next-level-cache = <&cpc>;
+			};
+		};
+		cpu2: PowerPC,e500mc@2 {
+			device_type = "cpu";
+			reg = <2>;
+			next-level-cache = <&L2_2>;
+			L2_2: l2-cache {
+				next-level-cache = <&cpc>;
+			};
+		};
+		cpu3: PowerPC,e500mc@3 {
+			device_type = "cpu";
+			reg = <3>;
+			next-level-cache = <&L2_3>;
+			L2_3: l2-cache {
+				next-level-cache = <&cpc>;
+			};
+		};
+	};
+
+	memory {
+		device_type = "memory";
+	};
+
+	bman-portals@ff4000000 {
+		#address-cells = <0x1>;
+		#size-cells = <0x1>;
+		compatible = "simple-bus";
+		ranges = <0x0 0xf 0xf4000000 0x200000>;
+		bman-portal@0 {
+			cell-index = <0x0>;
+			compatible = "fsl,p4080-bman-portal", "fsl,bman-portal";
+			reg = <0x0 0x4000 0x100000 0x1000>;
+			cpu-handle = <&cpu0>;
+			interrupts = <105 2 0 0>;
+			interrupt-parent = <&mpic>;
+		};
+		bman-portal@4000 {
+			cell-index = <0x1>;
+			compatible = "fsl,p4080-bman-portal", "fsl,bman-portal";
+			reg = <0x4000 0x4000 0x101000 0x1000>;
+			cpu-handle = <&cpu1>;
+			interrupts = <107 2 0 0>;
+			interrupt-parent = <&mpic>;
+		};
+		bman-portal@8000 {
+			cell-index = <2>;
+			compatible = "fsl,p4080-bman-portal", "fsl,bman-portal";
+			reg = <0x8000 0x4000 0x102000 0x1000>;
+			cpu-handle = <&cpu2>;
+			interrupts = <109 2 0 0>;
+			interrupt-parent = <&mpic>;
+		};
+		bman-portal@c000 {
+			cell-index = <0x3>;
+			compatible = "fsl,p4080-bman-portal", "fsl,bman-portal";
+			reg = <0xc000 0x4000 0x103000 0x1000>;
+			cpu-handle = <&cpu3>;
+			interrupts = <111 2 0 0>;
+			interrupt-parent = <&mpic>;
+		};
+
+		buffer-pool@0 {
+			compatible = "fsl,p4080-bpool", "fsl,bpool";
+			fsl,bpid = <0>;
+			fsl,bpool-cfg = <0 0x100 0 1 0 0x100>;
+		};
+                bman-bpids@0 {
+                    compatible = "fsl,bpid-range";
+                    fsl,bpid-range = <32 32>;
+                };
+	};
+
+	qman-portals@ff4200000 {
+		#address-cells = <0x1>;
+		#size-cells = <0x1>;
+		compatible = "simple-bus";
+		ranges = <0x0 0xf 0xf4200000 0x200000>;
+		qportal0: qman-portal@0 {
+			cell-index = <0x0>;
+			compatible = "fsl,p4080-qman-portal", "fsl,qman-portal";
+			reg = <0x0 0x4000 0x100000 0x1000>;
+			cpu-handle = <&cpu0>;
+			interrupts = <104 0x2 0 0>;
+			interrupt-parent = <&mpic>;
+			fsl,qman-channel-id = <0x0>;
+			fsl,qman-pool-channels = <&qpool1 &qpool2 &qpool3
+						  &qpool4 &qpool5 &qpool6
+						  &qpool7 &qpool8 &qpool9
+						  &qpool10 &qpool11 &qpool12
+						  &qpool13 &qpool14 &qpool15>;
+			crypto@0 {
+				dev-handle = <&crypto>;
+			};
+			pme@0 {
+				dev-handle = <&pme>;
+			};
+			fman@0 {
+				dev-handle = <&fman0>;
+			};
+			fman@1 {
+				dev-handle = <&fman1>;
+			};
+		};
+
+		qportal1: qman-portal@4000 {
+			cell-index = <0x1>;
+			compatible = "fsl,p4080-qman-portal", "fsl,qman-portal";
+			reg = <0x4000 0x4000 0x101000 0x1000>;
+			cpu-handle = <&cpu1>;
+			interrupts = <106 0x2 0 0>;
+			interrupt-parent = <&mpic>;
+			fsl,qman-channel-id = <0x1>;
+			fsl,qman-pool-channels = <&qpool1 &qpool2 &qpool3
+						  &qpool4 &qpool5 &qpool6
+						  &qpool7 &qpool8 &qpool9
+						  &qpool10 &qpool11 &qpool12
+						  &qpool13 &qpool14 &qpool15>;
+			crypto@0 {
+				dev-handle = <&crypto>;
+			};
+			pme@0 {
+				dev-handle = <&pme>;
+			};
+			fman@0 {
+				dev-handle = <&fman0>;
+			};
+			fman@1 {
+				dev-handle = <&fman1>;
+			};
+		};
+
+		qportal2: qman-portal@8000 {
+			cell-index = <0x2>;
+			compatible = "fsl,p4080-qman-portal", "fsl,qman-portal";
+			reg = <0x8000 0x4000 0x102000 0x1000>;
+			cpu-handle = <&cpu2>;
+			interrupts = <108 0x2 0 0>;
+			interrupt-parent = <&mpic>;
+			fsl,qman-channel-id = <0x2>;
+			fsl,qman-pool-channels = <&qpool1 &qpool2 &qpool3
+						  &qpool4 &qpool5 &qpool6
+						  &qpool7 &qpool8 &qpool9
+						  &qpool10 &qpool11 &qpool12
+						  &qpool13 &qpool14 &qpool15>;
+			crypto@0 {
+				dev-handle = <&crypto>;
+			};
+			pme@0 {
+				dev-handle = <&pme>;
+			};
+			fman@0 {
+				dev-handle = <&fman0>;
+			};
+			fman@1 {
+				dev-handle = <&fman1>;
+			};
+		};
+
+		qportal3: qman-portal@c000 {
+			cell-index = <0x3>;
+			compatible = "fsl,p4080-qman-portal", "fsl,qman-portal";
+			reg = <0xc000 0x4000 0x103000 0x1000>;
+			cpu-handle = <&cpu3>;
+			interrupts = <110 0x2 0 0>;
+			interrupt-parent = <&mpic>;
+			fsl,qman-channel-id = <0x3>;
+			fsl,qman-pool-channels = <&qpool1 &qpool2 &qpool3
+						  &qpool4 &qpool5 &qpool6
+						  &qpool7 &qpool8 &qpool9
+						  &qpool10 &qpool11 &qpool12
+						  &qpool13 &qpool14 &qpool15>;
+			crypto@0 {
+				dev-handle = <&crypto>;
+			};
+			pme@0 {
+				dev-handle = <&pme>;
+			};
+			fman@0 {
+				dev-handle = <&fman0>;
+			};
+			fman@1 {
+				dev-handle = <&fman1>;
+			};
+		};
+
+                qman-fqids@0 {
+                    compatible = "fsl,fqid-range";
+                    fsl,fqid-range = <256 256>;
+                };
+                qman-fqids@1 {
+                    compatible = "fsl,fqid-range";
+                    fsl,fqid-range = <32768 32768>;
+                };
+                qman-pools@0 {
+                    compatible = "fsl,pool-channel-range";
+                    fsl,pool-channel-range = <0x21 0xf>;
+                };
+                qman-cgrids@0 {
+                    compatible = "fsl,cgrid-range";
+                    fsl,cgrid-range = <0 256>;
+                };
+		qpool1: qman-pool@1 {
+			cell-index = <1>;
+			compatible = "fsl,p4080-qman-pool-channel", "fsl,qman-pool-channel";
+			fsl,qman-channel-id = <0x21>;
+		};
+
+		qpool2: qman-pool@2 {
+			cell-index = <2>;
+			compatible = "fsl,p4080-qman-pool-channel", "fsl,qman-pool-channel";
+			fsl,qman-channel-id = <0x22>;
+		};
+
+		qpool3: qman-pool@3 {
+			cell-index = <3>;
+			compatible = "fsl,p4080-qman-pool-channel", "fsl,qman-pool-channel";
+			fsl,qman-channel-id = <0x23>;
+		};
+
+		qpool4: qman-pool@4 {
+			cell-index = <4>;
+			compatible = "fsl,p4080-qman-pool-channel", "fsl,qman-pool-channel";
+			fsl,qman-channel-id = <0x24>;
+		};
+
+		qpool5: qman-pool@5 {
+			cell-index = <5>;
+			compatible = "fsl,p4080-qman-pool-channel", "fsl,qman-pool-channel";
+			fsl,qman-channel-id = <0x25>;
+		};
+
+		qpool6: qman-pool@6 {
+			cell-index = <6>;
+			compatible = "fsl,p4080-qman-pool-channel", "fsl,qman-pool-channel";
+			fsl,qman-channel-id = <0x26>;
+		};
+
+		qpool7: qman-pool@7 {
+			cell-index = <7>;
+			compatible = "fsl,p4080-qman-pool-channel", "fsl,qman-pool-channel";
+			fsl,qman-channel-id = <0x27>;
+		};
+
+		qpool8: qman-pool@8 {
+			cell-index = <8>;
+			compatible = "fsl,p4080-qman-pool-channel", "fsl,qman-pool-channel";
+			fsl,qman-channel-id = <0x28>;
+		};
+
+		qpool9: qman-pool@9 {
+			cell-index = <9>;
+			compatible = "fsl,p4080-qman-pool-channel", "fsl,qman-pool-channel";
+			fsl,qman-channel-id = <0x29>;
+		};
+
+		qpool10: qman-pool@10 {
+			cell-index = <10>;
+			compatible = "fsl,p4080-qman-pool-channel", "fsl,qman-pool-channel";
+			fsl,qman-channel-id = <0x2a>;
+		};
+
+		qpool11: qman-pool@11 {
+			cell-index = <11>;
+			compatible = "fsl,p4080-qman-pool-channel", "fsl,qman-pool-channel";
+			fsl,qman-channel-id = <0x2b>;
+		};
+
+		qpool12: qman-pool@12 {
+			cell-index = <12>;
+			compatible = "fsl,p4080-qman-pool-channel", "fsl,qman-pool-channel";
+			fsl,qman-channel-id = <0x2c>;
+		};
+
+		qpool13: qman-pool@13 {
+			cell-index = <13>;
+			compatible = "fsl,p4080-qman-pool-channel", "fsl,qman-pool-channel";
+			fsl,qman-channel-id = <0x2d>;
+		};
+
+		qpool14: qman-pool@14 {
+			cell-index = <14>;
+			compatible = "fsl,p4080-qman-pool-channel", "fsl,qman-pool-channel";
+			fsl,qman-channel-id = <0x2e>;
+		};
+
+		qpool15: qman-pool@15 {
+			cell-index = <15>;
+			compatible = "fsl,p4080-qman-pool-channel", "fsl,qman-pool-channel";
+			fsl,qman-channel-id = <0x2f>;
+		};
+	};
+
+	soc: soc@ffe000000 {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		device_type = "soc";
+		compatible = "simple-bus";
+		ranges = <0x00000000 0xf 0xfe000000 0x1000000>;
+		reg = <0xf 0xfe000000 0 0x00001000>;
+
+		soc-sram-error {
+			compatible = "fsl,soc-sram-error";
+			interrupt-parent = <&mpic>;
+                        interrupts = <16 2 1 29>;
+		};
+
+		corenet-law {
+			compatible = "fsl,corenet-law";
+			reg = <0x0 0x1000>;
+			fsl,num-laws = <32>;
+		};
+
+		corenet-cf {
+			compatible = "fsl,corenet-cf";
+			reg = <0x18000 0x1000>;
+			fsl,ccf-num-csdids = <32>;
+			fsl,ccf-num-snoopids = <32>;
+			interrupt-parent = <&mpic>;
+                        interrupts = <16 2 1 31>;
+		};
+
+		memory-controller@8000 {
+                        compatible = "fsl,qoriq-memory-controller-v4.4", "fsl,qoriq-memory-controller";
+			reg = <0x8000 0x1000>;
+			interrupt-parent = <&mpic>;
+			interrupts = <16 2 1 23>;
+		};
+
+		memory-controller@9000 {
+		        compatible = "fsl,qoriq-memory-controller-v4.4","fsl,qoriq-memory-controller";
+			reg = <0x9000 0x1000>;
+			interrupt-parent = <&mpic>;
+			interrupts = <16 2 1 22>;
+		};
+
+		cpc: l3-cache-controller {
+			compatible = "fsl,p4080-l3-cache-controller", "cache";
+			reg = <0x10000 0x1000
+			       0x11000 0x1000>;
+                        interrupts = <16 2 1 27
+                                      16 2 1 26>;
+		};
+
+		iommu@20000 {
+		        compatible = "fsl,pamu-v1.0", "fsl,pamu";
+			reg = <0x20000 0x5000>;
+			interrupts = <24 2 0 0>;
+			interrupt-parent = <&mpic>;
+		};
+
+		msi0: msi@41600 {
+			compatible = "fsl,mpic-msi";
+			reg = <0x41600 0x200>;
+			msi-available-ranges = <0 0x100>;
+			interrupts = <
+				0xe0 0 0 0
+				0xe1 0 0 0
+				0xe2 0 0 0
+				0xe3 0 0 0
+				0xe4 0 0 0
+				0xe5 0 0 0
+				0xe6 0 0 0
+				0xe7 0 0 0>;
+			interrupt-parent = <&mpic>;
+		};
+
+		msi1: msi@41800 {
+			compatible = "fsl,mpic-msi";
+			reg = <0x41800 0x200>;
+			msi-available-ranges = <0 0x100>;
+			interrupts = <
+				0xe8 0 0 0
+				0xe9 0 0 0
+				0xea 0 0 0
+				0xeb 0 0 0
+				0xec 0 0 0
+				0xed 0 0 0
+				0xee 0 0 0
+				0xef 0 0 0>;
+			interrupt-parent = <&mpic>;
+		};
+
+		msi2: msi@41a00 {
+			compatible = "fsl,mpic-msi";
+			reg = <0x41a00 0x200>;
+			msi-available-ranges = <0 0x100>;
+			interrupts = <
+				0xf0 0 0 0
+				0xf1 0 0 0
+				0xf2 0 0 0
+				0xf3 0 0 0
+				0xf4 0 0 0
+				0xf5 0 0 0
+				0xf6 0 0 0
+				0xf7 0 0 0>;
+			interrupt-parent = <&mpic>;
+		};
+
+		dma0: dma@100300 {
+			#address-cells = <1>;
+			#size-cells = <1>;
+			compatible = "fsl,p4080-dma", "fsl,eloplus-dma";
+			reg = <0x100300 0x4>;
+			ranges = <0x0 0x100100 0x200>;
+			cell-index = <0>;
+			dma-channel@0 {
+				compatible = "fsl,p4080-dma-channel",
+						"fsl,eloplus-dma-channel";
+				reg = <0x0 0x80>;
+				cell-index = <0>;
+				interrupt-parent = <&mpic>;
+				interrupts = <28 2 0 0>;
+			};
+			dma-channel@80 {
+				compatible = "fsl,p4080-dma-channel",
+						"fsl,eloplus-dma-channel";
+				reg = <0x80 0x80>;
+				cell-index = <1>;
+				interrupt-parent = <&mpic>;
+				interrupts = <29 2 0 0>;
+			};
+			dma-channel@100 {
+				compatible = "fsl,p4080-dma-channel",
+						"fsl,eloplus-dma-channel";
+				reg = <0x100 0x80>;
+				cell-index = <2>;
+				interrupt-parent = <&mpic>;
+				interrupts = <30 2 0 0>;
+			};
+			dma-channel@180 {
+				compatible = "fsl,p4080-dma-channel",
+						"fsl,eloplus-dma-channel";
+				reg = <0x180 0x80>;
+				cell-index = <3>;
+				interrupt-parent = <&mpic>;
+				interrupts = <31 2 0 0>;
+			};
+		};
+
+		dma1: dma@101300 {
+			#address-cells = <1>;
+			#size-cells = <1>;
+			compatible = "fsl,p4080-dma", "fsl,eloplus-dma";
+			reg = <0x101300 0x4>;
+			ranges = <0x0 0x101100 0x200>;
+			cell-index = <1>;
+			dma-channel@0 {
+				compatible = "fsl,p4080-dma-channel",
+						"fsl,eloplus-dma-channel";
+				reg = <0x0 0x80>;
+				cell-index = <0>;
+				interrupt-parent = <&mpic>;
+				interrupts = <32 2 0 0>;
+			};
+			dma-channel@80 {
+				compatible = "fsl,p4080-dma-channel",
+						"fsl,eloplus-dma-channel";
+				reg = <0x80 0x80>;
+				cell-index = <1>;
+				interrupt-parent = <&mpic>;
+				interrupts = <33 2 0 0>;
+			};
+			dma-channel@100 {
+				compatible = "fsl,p4080-dma-channel",
+						"fsl,eloplus-dma-channel";
+				reg = <0x100 0x80>;
+				cell-index = <2>;
+				interrupt-parent = <&mpic>;
+				interrupts = <34 2 0 0>;
+			};
+			dma-channel@180 {
+				compatible = "fsl,p4080-dma-channel",
+						"fsl,eloplus-dma-channel";
+				reg = <0x180 0x80>;
+				cell-index = <3>;
+				interrupt-parent = <&mpic>;
+				interrupts = <35 2 0 0>;
+			};
+		};
+
+		i2c@118000 {
+			#address-cells = <1>;
+			#size-cells = <0>;
+			cell-index = <0>;
+			compatible = "fsl-i2c";
+			reg = <0x118000 0x100>;
+			interrupts = <38 2 0 0>;
+			interrupt-parent = <&mpic>;
+			dfsrr;
+                        mux@71 {
+                                compatible = "pca9548,pca9548";
+                                reg = <0x71>;
+                                #address-cells = <1>;
+                                #size-cells = <0>;
+
+                                i2c@0 {
+                                        #address-cells = <1>;
+                                        #size-cells = <0>;
+                                        reg = <0>;
+                                        base-eeprom@52 {
+                                            compatible = "at24,24c256";
+                                            reg = <0x52>;
+                                        };
+                                };
+                                i2c@1 {
+                                        #address-cells = <1>;
+                                        #size-cells = <0>;
+                                        reg = <0>;
+                                        dc-eeprom@64 {
+                                            compatible = "at24,24c256";
+                                            reg = <0x64>;
+                                        };
+                                };
+			};
+		};
+
+		i2c@118100 {
+			#address-cells = <1>;
+			#size-cells = <0>;
+			cell-index = <1>;
+			compatible = "fsl-i2c";
+			reg = <0x118100 0x100>;
+			interrupts = <38 2 0 0>;
+			interrupt-parent = <&mpic>;
+			dfsrr;
+		};
+
+		i2c@119000 {
+			#address-cells = <1>;
+			#size-cells = <0>;
+			cell-index = <2>;
+			compatible = "fsl-i2c";
+			reg = <0x119000 0x100>;
+			interrupts = <39 2 0 0>;
+			interrupt-parent = <&mpic>;
+			dfsrr;
+			eeprom@52 {
+				compatible = "at24,24c256";
+				reg = <0x52>;
+			};
+                        ds1339@68 {
+                            compatible = "rtc-ds1307,ds1339";
+                            reg = <0x68>;
+                        };
+		};
+
+		i2c@119100 {
+			#address-cells = <1>;
+			#size-cells = <0>;
+			cell-index = <3>;
+			compatible = "fsl-i2c";
+			reg = <0x119100 0x100>;
+			interrupts = <39 2 0 0>;
+			interrupt-parent = <&mpic>;
+			dfsrr;
+		};
+
+		usb0: usb@210000 {
+			compatible = "fsl,p4080-usb2-mph",
+					"fsl,mpc85xx-usb2-mph", "fsl-usb2-mph";
+			reg = <0x210000 0x1000>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+			interrupt-parent = <&mpic>;
+			interrupts = <44 0x2 0 0>;
+			phy_type = "ulpi";
+		};
+
+		serial0: serial@11c500 {
+			cell-index = <0>;
+			device_type = "serial";
+                        compatible = "fsl,ns16550", "ns16550";
+			reg = <0x11c500 0x100>;
+			clock-frequency = <0>;
+			interrupts = <36 2 0 0>;
+			interrupt-parent = <&mpic>;
+		};
+
+		guts: global-utilities@e0000 {
+			compatible = "fsl,qoriq-device-config-1.0";
+			reg = <0xe0000 0xe00>;
+			fsl,has-rstcr;
+			#sleep-cells = <1>;
+			fsl,liodn-bits = <12>;
+		};
+
+		pins: global-utilities@e0e00 {
+			compatible = "fsl,qoriq-pin-control-1.0";
+			reg = <0xe0e00 0x200>;
+			#sleep-cells = <2>;
+		};
+
+		clockgen: global-utilities@e1000 {
+		        compatible = "fsl,p4080-clockgen", "fsl,qoriq-clockgen-1.0", "fixed-clock";
+			reg = <0xe1000 0x1000>;
+			clock-frequency = <0>;
+		};
+
+		rcpm: global-utilities@e2000 {
+			compatible = "fsl,qoriq-rcpm-1.0";
+			reg = <0xe2000 0x1000>;
+			#sleep-cells = <1>;
+		};
+
+		mpic: pic@40000 {
+			clock-frequency = <0>;
+			interrupt-controller;
+			#address-cells = <0>;
+			#interrupt-cells = <4>;
+			reg = <0x40000 0x40000>;
+                        compatible = "fsl,mpic", "chrp,open-pic";
+			device_type = "open-pic";
+			big-endian;
+			message@1400 {
+				compatible = "fsl,mpic-msg";
+				interrupts = <
+					0xb0 2 0 0
+					0xb1 2 0 0
+					0xb2 2 0 0
+					0xb3 2 0 0>;
+				interrupt-parent = < &mpic >;
+			};
+		};
+
+		sdhc: sdhc@114000 {
+			compatible = "fsl,p4080-esdhc", "fsl,esdhc";
+			reg = <0x114000 0x1000>;
+			interrupts = <48 2 0 0>;
+			interrupt-parent = <&mpic>;
+			fsl,sdhci-auto-cmd12;
+			clock-frequency = <0>;
+		};
+
+		gpio: gpio@130008 {
+			compatible = "fsl,qoriq-gpio";
+			reg = <0x130008 0xff8>;
+		};
+
+		crypto: crypto@300000 {
+		};
+
+		snvs: snvs@314000 {
+			compatible = "fsl,p4080-sec4.0-snvs", "fsl,sec4.0-snvs";
+			reg	   = <0x314000 0x1000>;
+			interrupts	 = <93 2 0 0>;
+			interrupt-parent = <&mpic>;
+		};
+
+		pme: pme@316000 {
+			compatible = "fsl,pme";
+			reg = <0x316000 0x10000>;
+                        interrupts = <16 2 1 5>;
+			interrupt-parent = <&mpic>;
+		};
+
+		qman: qman@318000 {
+			compatible = "fsl,p4080-qman", "fsl,qman";
+			reg = <0x318000 0x1000>;
+                        interrupts = <16 2 1 3>;
+			interrupt-parent = <&mpic>;
+		};
+
+		bman: bman@31a000 {
+			compatible = "fsl,p4080-bman", "fsl,bman";
+			reg = <0x31a000 0x1000>;
+			/* Same as fsl,qman-*, use default allocation */
+			/* fsl,bman-fbpr = <0x0 0x22000000 0x0 0x01000000>; */
+                        interrupts = <16 2 1 2>;
+			interrupt-parent = <&mpic>;
+		};
+
+		fman0: fman@400000 {
+			#address-cells = <1>;
+			#size-cells = <1>;
+			cell-index = <0>;
+			compatible = "fsl,p4080-fman", "fsl,fman", "simple-bus";
+			ranges = <0 0x400000 0x100000>;
+			reg = <0x400000 0x100000>;
+			clock-frequency = <0>;
+			interrupts = <96 2 0 0>;
+			interrupt-parent = <&mpic>;
+
+			cc@0 {
+				compatible = "fsl,p4080-fman-cc", "fsl,fman-cc";
+			};
+
+			parser@c7000 {
+				compatible = "fsl,p4080-fman-parser", "fsl,fman-parser";
+				reg = <0xc7000 0x1000>;
+			};
+
+			keygen@c1000 {
+				compatible = "fsl,p4080-fman-keygen", "fsl,fman-keygen";
+				reg = <0xc1000 0x1000>;
+			};
+
+			policer@c0000 {
+				compatible = "fsl,p4080-fman-policer", "fsl,fman-policer";
+				reg = <0xc0000 0x1000>;
+			};
+
+			muram@0 {
+				compatible = "fsl,p4080-fman-muram", "fsl,fman-muram";
+				reg = <0x0 0x28000>;
+			};
+
+			bmi@80000 {
+				compatible = "fsl,p4080-fman-bmi", "fsl,fman-bmi";
+				reg = <0x80000 0x400>;
+			};
+
+			qmi@80400 {
+				compatible = "fsl,p4080-fman-qmi", "fsl,fman-qmi";
+				reg = <0x80400 0x400>;
+			};
+
+			fman0_rx0: port@88000 {
+				cell-index = <0>;
+				compatible = "fsl,p4080-fman-port-1g-rx", "fsl,fman-port-1g-rx";
+				reg = <0x88000 0x1000>;
+			};
+			fman0_rx1: port@89000 {
+				cell-index = <1>;
+				compatible = "fsl,p4080-fman-port-1g-rx", "fsl,fman-port-1g-rx";
+				reg = <0x89000 0x1000>;
+			};
+			fman0_rx2: port@8a000 {
+				cell-index = <2>;
+				compatible = "fsl,p4080-fman-port-1g-rx", "fsl,fman-port-1g-rx";
+				reg = <0x8a000 0x1000>;
+			};
+			fman0_rx3: port@8b000 {
+				cell-index = <3>;
+				compatible = "fsl,p4080-fman-port-1g-rx", "fsl,fman-port-1g-rx";
+				reg = <0x8b000 0x1000>;
+			};
+			fman0_rx4: port@90000 {
+				cell-index = <0>;
+				compatible = "fsl,p4080-fman-port-10g-rx", "fsl,fman-port-10g-rx";
+				reg = <0x90000 0x1000>;
+			};
+
+			fman0_tx4: port@b0000 {
+				cell-index = <0>;
+				compatible = "fsl,p4080-fman-port-10g-tx", "fsl,fman-port-10g-tx";
+				reg = <0xb0000 0x1000>;
+				fsl,qman-channel-id = <0x40>;
+			};
+			fman0_tx0: port@a8000 {
+				cell-index = <0>;
+				compatible = "fsl,p4080-fman-port-1g-tx", "fsl,fman-port-1g-tx";
+				reg = <0xa8000 0x1000>;
+				fsl,qman-channel-id = <0x41>;
+			};
+			fman0_tx1: port@a9000 {
+				cell-index = <1>;
+				compatible = "fsl,p4080-fman-port-1g-tx", "fsl,fman-port-1g-tx";
+				reg = <0xa9000 0x1000>;
+				fsl,qman-channel-id = <0x42>;
+			};
+			fman0_tx2: port@aa000 {
+				cell-index = <2>;
+				compatible = "fsl,p4080-fman-port-1g-tx", "fsl,fman-port-1g-tx";
+				reg = <0xaa000 0x1000>;
+				fsl,qman-channel-id = <0x43>;
+			};
+			fman0_tx3: port@ab000 {
+				cell-index = <3>;
+				compatible = "fsl,p4080-fman-port-1g-tx", "fsl,fman-port-1g-tx";
+				reg = <0xab000 0x1000>;
+				fsl,qman-channel-id = <0x44>;
+			};
+
+			fman0_oh0: port@81000 {
+				cell-index = <0>;
+				compatible = "fsl,p4080-fman-port-oh", "fsl,fman-port-oh";
+				reg = <0x81000 0x1000>;
+				fsl,qman-channel-id = <0x45>;
+			};
+			fman0_oh1: port@82000 {
+				cell-index = <1>;
+				compatible = "fsl,p4080-fman-port-oh", "fsl,fman-port-oh";
+				reg = <0x82000 0x1000>;
+				fsl,qman-channel-id = <0x46>;
+			};
+			fman0_oh2: port@83000 {
+				cell-index = <2>;
+				compatible = "fsl,p4080-fman-port-oh", "fsl,fman-port-oh";
+				reg = <0x83000 0x1000>;
+				fsl,qman-channel-id = <0x47>;
+			};
+			fman0_oh3: port@84000 {
+				cell-index = <3>;
+				compatible = "fsl,p4080-fman-port-oh", "fsl,fman-port-oh";
+				reg = <0x84000 0x1000>;
+				fsl,qman-channel-id = <0x48>;
+			};
+			fman0_oh4: port@85000 {
+				cell-index = <4>;
+				compatible = "fsl,p4080-fman-port-oh", "fsl,fman-port-oh";
+				reg = <0x85000 0x1000>;
+				fsl,qman-channel-id = <0x49>;
+			};
+			fman0_oh5: port@86000 {
+				cell-index = <5>;
+				compatible = "fsl,p4080-fman-port-oh", "fsl,fman-port-oh";
+				reg = <0x86000 0x1000>;
+				fsl,qman-channel-id = <0x4a>;
+			};
+			fman0_oh6: port@87000 {
+				cell-index = <6>;
+				compatible = "fsl,p4080-fman-port-oh", "fsl,fman-port-oh";
+				reg = <0x87000 0x1000>;
+				fsl,qman-channel-id = <0x4b>;
+			};
+
+			mdio0: mdio@e1120 {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				compatible = "fsl,fman-mdio";
+				reg = <0xe1120 0xee0>;
+				interrupts = <100 1 0 0>;
+
+				phy0: ethernet-phy@0 {
+                                                reg = <0x0>;
+                                        };
+			};
+		};
+
+		fman1: fman@500000 {
+			#address-cells = <1>;
+			#size-cells = <1>;
+			cell-index = <1>;
+			compatible = "fsl,p4080-fman", "fsl,fman", "simple-bus";
+			ranges = <0 0x500000 0x100000>;
+			reg = <0x500000 0x100000>;
+			clock-frequency = <0>;
+			interrupts = <97 2 0 0>;
+			interrupt-parent = <&mpic>;
+
+			cc@0 {
+				compatible = "fsl,p4080-fman-cc", "fsl,fman-cc";
+			};
+
+			parser@c7000 {
+				compatible = "fsl,p4080-fman-parser", "fsl,fman-parser";
+				reg = <0xc7000 0x1000>;
+			};
+
+			keygen@c1000 {
+				compatible = "fsl,p4080-fman-keygen", "fsl,fman-keygen";
+				reg = <0xc1000 0x1000>;
+			};
+
+			policer@c0000 {
+				compatible = "fsl,p4080-fman-policer", "fsl,fman-policer";
+				reg = <0xc0000 0x1000>;
+			};
+
+			muram@0 {
+				compatible = "fsl,p4080-fman-muram", "fsl,fman-muram";
+				reg = <0x0 0x28000>;
+			};
+
+			bmi@80000 {
+				compatible = "fsl,p4080-fman-bmi", "fsl,fman-bmi";
+				reg = <0x80000 0x400>;
+			};
+
+			qmi@80400 {
+				compatible = "fsl,p4080-fman-qmi", "fsl,fman-qmi";
+				reg = <0x80400 0x400>;
+			};
+
+			fman1_rx0: port@88000 {
+				cell-index = <0>;
+				compatible = "fsl,p4080-fman-port-1g-rx", "fsl,fman-port-1g-rx";
+				reg = <0x88000 0x1000>;
+			};
+			fman1_rx1: port@89000 {
+				cell-index = <1>;
+				compatible = "fsl,p4080-fman-port-1g-rx", "fsl,fman-port-1g-rx";
+				reg = <0x89000 0x1000>;
+			};
+			fman1_rx2: port@8a000 {
+				cell-index = <2>;
+				compatible = "fsl,p4080-fman-port-1g-rx", "fsl,fman-port-1g-rx";
+				reg = <0x8a000 0x1000>;
+			};
+			fman1_rx3: port@8b000 {
+				cell-index = <3>;
+				compatible = "fsl,p4080-fman-port-1g-rx", "fsl,fman-port-1g-rx";
+				reg = <0x8b000 0x1000>;
+			};
+			fman1_rx4: port@90000 {
+				cell-index = <0>;
+				compatible = "fsl,p4080-fman-port-10g-rx", "fsl,fman-port-10g-rx";
+				reg = <0x90000 0x1000>;
+			};
+
+			fman1_tx4: port@b0000 {
+				cell-index = <0>;
+				compatible = "fsl,p4080-fman-port-10g-tx", "fsl,fman-port-10g-tx";
+				reg = <0xb0000 0x1000>;
+				fsl,qman-channel-id = <0x60>;
+			};
+			fman1_tx0: port@a8000 {
+				cell-index = <0>;
+				compatible = "fsl,p4080-fman-port-1g-tx", "fsl,fman-port-1g-tx";
+				reg = <0xa8000 0x1000>;
+				fsl,qman-channel-id = <0x61>;
+			};
+			fman1_tx1: port@a9000 {
+				cell-index = <1>;
+				compatible = "fsl,p4080-fman-port-1g-tx", "fsl,fman-port-1g-tx";
+				reg = <0xa9000 0x1000>;
+				fsl,qman-channel-id = <0x62>;
+			};
+			fman1_tx2: port@aa000 {
+				cell-index = <2>;
+				compatible = "fsl,p4080-fman-port-1g-tx", "fsl,fman-port-1g-tx";
+				reg = <0xaa000 0x1000>;
+				fsl,qman-channel-id = <0x63>;
+			};
+			fman1_tx3: port@ab000 {
+				cell-index = <3>;
+				compatible = "fsl,p4080-fman-port-1g-tx", "fsl,fman-port-1g-tx";
+				reg = <0xab000 0x1000>;
+				fsl,qman-channel-id = <0x64>;
+			};
+
+			fman1_oh0: port@81000 {
+				cell-index = <0>;
+				compatible = "fsl,p4080-fman-port-oh", "fsl,fman-port-oh";
+				reg = <0x81000 0x1000>;
+				fsl,qman-channel-id = <0x65>;
+			};
+			fman1_oh1: port@82000 {
+				cell-index = <1>;
+				compatible = "fsl,p4080-fman-port-oh", "fsl,fman-port-oh";
+				reg = <0x82000 0x1000>;
+				fsl,qman-channel-id = <0x66>;
+			};
+			fman1_oh2: port@83000 {
+				cell-index = <2>;
+				compatible = "fsl,p4080-fman-port-oh", "fsl,fman-port-oh";
+				reg = <0x83000 0x1000>;
+				fsl,qman-channel-id = <0x67>;
+			};
+			fman1_oh3: port@84000 {
+				cell-index = <3>;
+				compatible = "fsl,p4080-fman-port-oh", "fsl,fman-port-oh";
+				reg = <0x84000 0x1000>;
+				fsl,qman-channel-id = <0x68>;
+			};
+			fman1_oh4: port@85000 {
+				cell-index = <4>;
+				compatible = "fsl,p4080-fman-port-oh", "fsl,fman-port-oh";
+				reg = <0x85000 0x1000>;
+				fsl,qman-channel-id = <0x69>;
+			};
+			fman1_oh5: port@86000 {
+				cell-index = <5>;
+				compatible = "fsl,p4080-fman-port-oh", "fsl,fman-port-oh";
+				reg = <0x86000 0x1000>;
+				fsl,qman-channel-id = <0x6a>;
+			};
+			fman1_oh6: port@87000 {
+				cell-index = <6>;
+				compatible = "fsl,p4080-fman-port-oh", "fsl,fman-port-oh";
+				reg = <0x87000 0x1000>;
+				fsl,qman-channel-id = <0x6b>;
+			};
+
+			enet0: ethernet@e0000 {
+				cell-index = <0>;
+				compatible = "fsl,p4080-fman-1g-mac", "fsl,fman-1g-mac";
+				reg = <0xe0000 0x1000>;
+				fsl,port-handles = <&fman1_rx0 &fman1_tx0>;
+				tbi-handle = <&tbi0>;
+				phy-handle = <&phy0>;
+				/*fixed-link = <2 1 100 0 0>;*/
+				phy-connection-type = "sgmii";
+			};
+			mdio@e1120 {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				compatible = "fsl,fman-mdio";
+				reg = <0xe1120 0xee0>;
+				interrupts = <101 1 0 0>;
+
+				tbi0: tbi-phy@5 {
+					reg = <5>;
+					device_type = "tbi-phy";
+				};
+			};
+		};
+	};
+
+	pci0: pcie@ffe200000 {
+                compatible = "fsl,p4080-pcie", "fsl,qoriq-pcie-v2.1", "fsl,qoriq-pcie";
+		device_type = "pci";
+		#size-cells = <2>;
+		#address-cells = <3>;
+		reg = <0xf 0xfe200000 0 0x1000>;
+		bus-range = <0x0 0xff>;
+                ranges = <0x02000000 0 0xe0000000 0xc 0x00000000 0x0 0x20000000
+                          0x01000000 0 0x00000000 0xf 0xf8000000 0x0 0x00010000>;
+		clock-frequency = <0x1fca055>;
+		fsl,msi = <&msi0>;
+		interrupt-parent = <&mpic>;
+                interrupts = <16 2 1 15>;
+
+		pcie@0 {
+			reg = <0 0 0 0 0>;
+                        #interrupt-cells = <1>;
+			#size-cells = <2>;
+			#address-cells = <3>;
+			device_type = "pci";
+                        interrupts = <16 2 1 15>;
+                        interrupt-map-mask = <0xf800 0 0 7>;
+                        interrupt-map = <
+                            0000 0 0 1 &mpic 40 1 0 0
+                            0000 0 0 2 &mpic 1 1 0 0
+                            0000 0 0 3 &mpic 2 1 0 0
+                            0000 0 0 4 &mpic 3 1 0 0
+                            >;
+                        ranges = <0x02000000 0 0xe0000000
+                                  0x02000000 0 0xe0000000
+                                  0 0x20000000
+
+                                  0x01000000 0 0x00000000
+                                  0x01000000 0 0x00000000
+                                  0 0x00010000>;
+		};
+	};
+
+        pci1: pcie@ffe201000 {
+                compatible = "fsl,p4080-pcie", "fsl,qoriq-pcie-v2.1", "fsl,qoriq-pcie";
+                device_type = "pci";
+                #size-cells = <2>;
+                #address-cells = <3>;
+                reg = <0xf 0xfe201000 0 0x1000>;
+                bus-range = <0 0xff>;
+                ranges = <0x02000000 0x0 0xe0000000 0xc 0x20000000 0x0 0x20000000
+                          0x01000000 0x0 0x00000000 0xf 0xf8010000 0x0 0x00010000>;
+                clock-frequency = <0x1fca055>;
+                fsl,msi = <&msi1>;
+                interrupt-parent = <&mpic>;
+                pcie@0 {
+                        reg = <0 0 0 0 0>;
+                        #interrupt-cells = <1>;
+                        #size-cells = <2>;
+                        #address-cells = <3>;
+                        device_type = "pci";
+                        interrupts = <16 2 1 14>;
+                        interrupt-map-mask = <0xf800 0 0 7>;
+                        interrupt-map = <
+                            /* IDSEL 0x0 */
+                            0000 0 0 1 &mpic 41 1 0 0
+                            0000 0 0 2 &mpic 5 1 0 0
+                            0000 0 0 3 &mpic 6 1 0 0
+                            0000 0 0 4 &mpic 7 1 0 0
+                            >;
+                        ranges = <0x02000000 0 0xe0000000
+                                  0x02000000 0 0xe0000000
+                                  0 0x20000000
+
+                                  0x01000000 0 0x00000000
+                                  0x01000000 0 0x00000000
+                                  0 0x00010000>;
+                };
+        };
+
+        pci2: pcie@ffe202000 {
+                compatible = "fsl,p4080-pcie", "fsl,qoriq-pcie-v2.1", "fsl,qoriq-pcie";
+                device_type = "pci";
+                #size-cells = <2>;
+                #address-cells = <3>;
+                reg = <0xf 0xfe202000 0 0x1000>;
+                bus-range = <0x0 0xff>;
+                ranges = <0x02000000 0 0xe0000000 0xc 0x40000000 0 0x20000000
+                          0x01000000 0 0x00000000 0xf 0xf8020000 0 0x00010000>;
+                clock-frequency = <0x1fca055>;
+                fsl,msi = <&msi2>;
+                interrupt-parent = <&mpic>;
+                pcie@0 {
+                        reg = <0 0 0 0 0>;
+                        #interrupt-cells = <1>;
+                        #size-cells = <2>;
+                        #address-cells = <3>;
+                        device_type = "pci";
+                        interrupts = <16 2 1 13>;
+                        interrupt-map-mask = <0xf800 0 0 7>;
+                        interrupt-map = <
+                            /* IDSEL 0x0 */
+                            0000 0 0 1 &mpic 42 1 0 0
+                            0000 0 0 2 &mpic 9 1 0 0
+                            0000 0 0 3 &mpic 10 1 0 0
+                            0000 0 0 4 &mpic 11 1 0 0
+                            >;
+                        ranges = <0x02000000 0 0xe0000000
+                                  0x02000000 0 0xe0000000
+                                  0 0x20000000
+
+                                  0x01000000 0 0x00000000
+                                  0x01000000 0 0x00000000
+                                  0 0x00010000>;
+                };
+        };
+
+	fsl,dpaa {
+		compatible = "fsl,p4080-dpaa", "fsl,dpaa";
+
+		ethernet@0 {
+			compatible = "fsl,p4080-dpa-ethernet", "fsl,dpa-ethernet";
+			fsl,qman-channel = <&qpool1>;
+			fsl,fman-mac = <&enet0>;
+		};
+	};
+
+	localbus@ffe124000 {
+		compatible = "fsl,p4080-elbc", "fsl,elbc", "simple-bus";
+		reg = <0xf 0xfe124000 0 0x1000>;
+		interrupts = <25 2 0 0>;
+		interrupt-parent = <&mpic>;
+		#address-cells = <2>;
+		#size-cells = <1>;
+
+                ranges = <0x0 0x0 0xf 0xee000000 0x02000000
+                          0x1 0x0 0xf 0x00000000 0x00040000
+                          0x2 0x0 0xf 0x00040000 0x00040000>;
+
+
+		flash@0,0 {
+                        #address-cells = <1>;
+                        #size-cells = <1>;
+			compatible = "cfi-flash";
+			reg = <0 0 0x02000000>;
+			bank-width = <2>;
+			device-width = <2>;
+                        device-tree@20000 {
+                            label = "device-tree";
+                            reg = <0x20000 0x40000>;
+                        };
+                        linux-kernel@100000 {
+                            label = "linux-kernel";
+                            reg = <0x100000 0x800000>;
+                        };
+			rfs@900000 {
+                            label = "root filesystem";
+                            reg = <0x900000 0xa00000>;
+                        };
+			onie@1560000 {
+                            label ="onie";
+                            reg = <0x1560000 0xA00000>;
+                        };
+                        u-boot-env@1f60000 {
+                            label = "uboot-env";
+                            reg = <0x1f60000 0x20000>;
+			    env_size = <0x2000>;
+                        };
+                        u-boot@1f80000 {
+                            label = "uboot";
+                            reg = <0x1f80000 0x80000>;
+                        };
+                        open@20000 {
+                            label = "open";
+                            reg = <0x20000 0x1540000>;
+                        };
+			};
+                nand@1,0 {
+                        #address-cells = <1>;
+                        #size-cells = <1>;
+                        compatible = "fsl,elbc-fcm-nand";
+                        reg = <0x1 0x0 0x40000>;
+
+                        partition@user1 {
+                                reg = <0 0x3c000000>;
+                                label = "user1-nand";
+                        };
+			partition@res1 {
+                                reg = <0x3c000000 0x04000000>;
+                                label = "cfg1";
+                        };
+                };
+                nand@2,0 {
+                        #address-cells = <1>;
+                        #size-cells = <1>;
+			compatible = "fsl,elbc-fcm-nand";
+                        reg = <0x2 0x0 0x40000>;
+                        partition@user2 {
+                                reg = <0 0x3c000000>;
+                                label = "user2-nand";
+                        };
+			partition@res2 {
+                                reg = <0x3c000000 0x04000000>;
+                                label = "cfg2";
+                        };
+                };
+
+	};
+};
diff --git a/arch/powerpc/platforms/85xx/Kconfig b/arch/powerpc/platforms/85xx/Kconfig
index 0bc51f8..34a9373 100644
--- a/arch/powerpc/platforms/85xx/Kconfig
+++ b/arch/powerpc/platforms/85xx/Kconfig
@@ -288,6 +288,18 @@ config CORENET_GENERIC
 	  The following boards are supported for both 32bit and 64bit kernel:
 	    P5020 DS, P5040 DS, T104xQDS, T104xRDB, T102xQDS, T102xRDB
 
+config LENOVO_G8296
+       bool "Lenovo G8296"
+       select DEFAULT_UIMAGE
+       select E500
+       select PPC_E500MC
+       select PHYS_64BIT
+       select ARCH_REQUIRE_GPIOLIB
+       select GPIO_MPC8XXX
+       select HAS_FSL_QBMAN
+       help
+        This option enables support for the Lenovo G8296 networking platform
+
 endif # FSL_SOC_BOOKE
 
 config TQM85xx
diff --git a/arch/powerpc/platforms/85xx/Makefile b/arch/powerpc/platforms/85xx/Makefile
index 46995da..e3c6ede 100644
--- a/arch/powerpc/platforms/85xx/Makefile
+++ b/arch/powerpc/platforms/85xx/Makefile
@@ -33,3 +33,4 @@ obj-$(CONFIG_XES_MPC85xx) += xes_mpc85xx.o
 obj-$(CONFIG_GE_IMP3A)	  += ge_imp3a.o
 obj-$(CONFIG_PPC_QEMU_E500) += qemu_e500.o
 obj-$(CONFIG_SGY_CTS1000) += sgy_cts1000.o
+obj-$(CONFIG_LENOVO_G8296) += lenovo_g8296.o
diff --git a/arch/powerpc/platforms/85xx/lenovo_g8296.c b/arch/powerpc/platforms/85xx/lenovo_g8296.c
new file mode 100644
index 0000000..7f65f50
--- /dev/null
+++ b/arch/powerpc/platforms/85xx/lenovo_g8296.c
@@ -0,0 +1,177 @@
+/*
+ * Lenovo G8272  Board Setup
+ *
+ *  Maintained by Mark Pearson (mpearson @ lenovo com)
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+
+#include <linux/kernel.h>
+#include <linux/pci.h>
+#include <linux/kdev_t.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#include <linux/memblock.h>
+
+#include <asm/time.h>
+#include <asm/machdep.h>
+#include <asm/pci-bridge.h>
+#include <asm/ppc-pci.h>
+#include <mm/mmu_decl.h>
+#include <asm/prom.h>
+#include <asm/udbg.h>
+#include <asm/mpic.h>
+
+#include <linux/of_platform.h>
+#include <sysdev/fsl_soc.h>
+#include <sysdev/fsl_pci.h>
+#include <linux/fsl_usdpaa.h>
+
+void __init lenovo_g8296_pic_init(void)
+{
+	struct mpic *mpic;
+	unsigned int flags = MPIC_BIG_ENDIAN | MPIC_SINGLE_DEST_CPU | MPIC_NO_RESET;
+
+	if (ppc_md.get_irq == mpic_get_coreint_irq)
+		flags |= MPIC_ENABLE_COREINT;
+
+	mpic = mpic_alloc(NULL, 0, flags, 0, 512, " OpenPIC  ");
+	BUG_ON(mpic == NULL);
+
+	mpic_init(mpic);
+}
+
+/* Use board CPLD support for restarting the system */
+#define CARD_RESET_REG_ADDRESS   0xfe800000cUL 
+static void lenovo_g8296_restart(char *cmd)
+{
+    uint8_t __iomem * sys_cpld;
+
+    (void) cmd;
+
+    sys_cpld = ioremap(CARD_RESET_REG_ADDRESS, 4);
+    if (sys_cpld == NULL) {
+        printk (KERN_ERR "Error mapping CPLD registers\n");
+    }
+
+    local_irq_disable();
+    if (sys_cpld)
+        out_8(sys_cpld, 0x80);   /* RST_CARD */
+
+    /* Never return. */
+    while (1) ;
+}
+
+
+/*
+ * Setup the architecture
+ */
+#ifdef CONFIG_SMP
+void __init mpc85xx_smp_init(void);
+#endif
+
+void __init lenovo_g8296_setup_arch(void)
+{
+
+#ifdef CONFIG_SMP
+	mpc85xx_smp_init();
+#endif
+	printk(KERN_INFO "G8296 board from Lenovo\n");
+}
+
+static const struct of_device_id lenovo_g8296_ids[] = {
+	{
+		.compatible	= "simple-bus"
+	},
+	{
+		.compatible	= "fsl,rapidio-delta",
+	},
+	{
+		.compatible	= "fsl,p4080-pcie",
+	},
+	{
+		.compatible	= "fsl,qoriq-pcie-v2.2",
+	},
+	{
+		.compatible	= "fsl,dpaa",
+	},
+	{}
+};
+
+int __init lenovo_g8296_publish_devices(void)
+{
+	return of_platform_bus_probe(NULL, lenovo_g8296_ids, NULL);
+}
+
+/*
+ * Called very early, device-tree isn't unflattened
+ */
+static int __init lenovo_g8296_probe(void)
+{
+	unsigned long root = of_get_flat_dt_root();
+
+	if (of_flat_dt_is_compatible(root, "lenovo,g8296"))
+		return 1;
+        /*Hack - to be cleaned up*/
+	if (of_flat_dt_is_compatible(root, "fsl,jupiter"))
+		return 1;
+
+	return 0;
+}
+
+/* Early setup is required for large chunks of contiguous (and coarsely-aligned)
+ * memory. The following shoe-horns Q/Bman "init_early" calls into the
+ * platform setup to let them parse their CCSR nodes early on. */
+#ifdef CONFIG_FSL_QMAN_CONFIG
+void __init qman_init_early(void);
+#endif
+#ifdef CONFIG_FSL_BMAN_CONFIG
+void __init bman_init_early(void);
+#endif
+#ifdef CONFIG_FSL_PME2_CTRL
+void __init pme2_init_early(void);
+#endif
+
+static __init void lenovo_g8296_init_early(void)
+{
+#ifdef CONFIG_FSL_QMAN_CONFIG
+	qman_init_early();
+#endif
+#ifdef CONFIG_FSL_BMAN_CONFIG
+	bman_init_early();
+#endif
+#ifdef CONFIG_FSL_PME2_CTRL
+	pme2_init_early();
+#endif
+#ifdef CONFIG_FSL_USDPAA
+	fsl_usdpaa_init_early();
+#endif
+}
+
+define_machine(lenovo_g8296) {
+	.name			= "Lenovo G8296",
+	.probe			= lenovo_g8296_probe,
+	.setup_arch		= lenovo_g8296_setup_arch,
+	.init_IRQ		= lenovo_g8296_pic_init,
+#ifdef CONFIG_PCI
+	.pcibios_fixup_bus	= fsl_pcibios_fixup_bus,
+#endif
+	.get_irq		= mpic_get_coreint_irq,
+	.restart		= lenovo_g8296_restart,
+	.calibrate_decr		= generic_calibrate_decr,
+	.progress		= udbg_progress,
+#ifdef CONFIG_PPC64
+	.power_save		= book3e_idle,
+#else
+	.power_save		= e500_idle,
+#endif
+	.init_early		= lenovo_g8296_init_early,
+};
+
+machine_device_initcall(lenovo_g8296, lenovo_g8296_publish_devices);
+#ifdef CONFIG_SWIOTLB
+machine_arch_initcall(lenovo_g8296, swiotlb_setup_bus_notifier);
+#endif
diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/dtsec.c b/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/dtsec.c
index 5ae65f8..ca9fc96 100644
--- a/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/dtsec.c
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/dtsec.c
@@ -1116,6 +1116,9 @@ static t_Error DtsecRestartAutoneg(t_Handle h_Dtsec)
     SANITY_CHECK_RETURN_ERROR(p_Dtsec, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_Dtsec->p_DtsecDriverParam, E_INVALID_STATE);
 
+    if (ENET_INTERFACE_FROM_MODE(p_Dtsec->enetMode) == e_ENET_IF_TBI)
+        return E_OK;
+
     DTSEC_MII_ReadPhyReg(p_Dtsec, p_Dtsec->tbi_phy_addr, 0, &tmpReg16);
 
     tmpReg16 &= ~( PHY_CR_SPEED0 | PHY_CR_SPEED1 );
@@ -1265,11 +1268,23 @@ static t_Error DtsecInit(t_Handle h_Dtsec)
             tmpReg16 = PHY_TBIANA_1000X;
         else
             tmpReg16 = PHY_TBIANA_SGMII;
+
+	/*Lenovo G8296 board*/
+        printk("Forcing setting to 1000X 0x%x\n", tmpReg16);
+        tmpReg16 = PHY_TBIANA_1000X;
+
         DTSEC_MII_WritePhyReg(p_Dtsec, (uint8_t)p_DtsecDriverParam->tbipa, 4, tmpReg16);
 
         tmpReg16 = (PHY_CR_ANE | PHY_CR_RESET_AN | PHY_CR_FULLDUPLEX | PHY_CR_SPEED1);
 
         DTSEC_MII_WritePhyReg(p_Dtsec, (uint8_t)p_DtsecDriverParam->tbipa, 0, tmpReg16);
+
+	/* Lenovo G8296 - Disable autoneg to work with Marvell PHY*/
+        tmpReg16 = 0x8000;
+        DTSEC_MII_WritePhyReg(p_Dtsec, (uint8_t)p_DtsecDriverParam->tbipa, 0, tmpReg16);
+        tmpReg16 = 0x140;
+        DTSEC_MII_WritePhyReg(p_Dtsec, (uint8_t)p_DtsecDriverParam->tbipa, 0, tmpReg16);
+
     }
 
     /* Max Frame Length */
diff --git a/drivers/net/ethernet/freescale/fsl_pq_mdio.c b/drivers/net/ethernet/freescale/fsl_pq_mdio.c
index d31302a..8ac2a4a 100644
--- a/drivers/net/ethernet/freescale/fsl_pq_mdio.c
+++ b/drivers/net/ethernet/freescale/fsl_pq_mdio.c
@@ -331,6 +331,34 @@ static struct of_device_id fsl_pq_mdio_match[] = {
 			.get_tbipa = get_etsec_tbipa,
 		},
 	},
+        {
+                .compatible = "fsl,etsec1-tbi",
+                .data = &(struct fsl_pq_mdio_data) {
+                        .mii_offset = offsetof(struct fsl_pq_mdio, mii),
+                        .get_tbipa = get_etsec_tbipa,
+                },
+        },
+        {
+                .compatible = "fsl,etsec1-mdio",
+                .data = &(struct fsl_pq_mdio_data) {
+                        .mii_offset = offsetof(struct fsl_pq_mdio, mii),
+                        .get_tbipa = get_etsec_tbipa,
+                },
+        },
+        {
+                .compatible = "fsl,etsec3-tbi",
+                .data = &(struct fsl_pq_mdio_data) {
+                        .mii_offset = offsetof(struct fsl_pq_mdio, mii),
+                        .get_tbipa = get_etsec_tbipa,
+                },
+        },
+        {
+                .compatible = "fsl,etsec3-mdio",
+                .data = &(struct fsl_pq_mdio_data) {
+                        .mii_offset = offsetof(struct fsl_pq_mdio, mii),
+                        .get_tbipa = get_etsec_tbipa,
+                },
+        },
 #endif
 #if defined(CONFIG_UCC_GETH) || defined(CONFIG_UCC_GETH_MODULE)
 	{
diff --git a/drivers/net/phy/marvell.c b/drivers/net/phy/marvell.c
index 2128c6c..25433b0 100644
--- a/drivers/net/phy/marvell.c
+++ b/drivers/net/phy/marvell.c
@@ -49,6 +49,7 @@
 
 #define MII_M1011_PHY_SCR		0x10
 #define MII_M1011_PHY_SCR_AUTO_CROSS	0x0060
+#define MII_M1011_PHY_SCR_MAC_AUTOPWR   0x0008
 
 #define MII_M1145_PHY_EXT_CR		0x14
 #define MII_M1145_RGMII_RX_DELAY	0x0080
@@ -183,7 +184,7 @@ static int marvell_config_aneg(struct phy_device *phydev)
 		return err;
 
 	err = phy_write(phydev, MII_M1011_PHY_SCR,
-			MII_M1011_PHY_SCR_AUTO_CROSS);
+			MII_M1011_PHY_SCR_AUTO_CROSS | MII_M1011_PHY_SCR_MAC_AUTOPWR);
 	if (err < 0)
 		return err;
 
@@ -544,7 +545,27 @@ static int m88e1111_config_init(struct phy_device *phydev)
 	if (err < 0)
 		return err;
 
+#if 1
+	/*Lenovo G8296 PHY init....*/
+	err = phy_write(phydev, 0x1D, 0x3);
+        if (err < 0)
+                return err;
+        err = phy_write(phydev, 0x1E, 0x5f5f);
+        if (err < 0)
+                return err;
+        err = phy_write(phydev, 0x1E, 0x5f7f);
+        if (err < 0)
+                return err;
+        /*Bug43484 - auto off config being lost*/
+        temp = phy_read(phydev, MII_BMCR);
+        temp |= BMCR_RESET;
+        err = phy_write(phydev, MII_BMCR, temp);
+        if (err < 0)
+                return err;
+        return 0;
+#else
 	return phy_write(phydev, MII_BMCR, BMCR_RESET);
+#endif
 }
 
 static int m88e1118_config_aneg(struct phy_device *phydev)
@@ -695,6 +716,43 @@ static int m88e1145_config_init(struct phy_device *phydev)
 	return 0;
 }
 
+static int marvell_switch_page(struct phy_device *phydev,u16 page){
+        int err;
+
+        err = phy_write(phydev, 0x16, page);
+        if (err < 0)
+                return err;
+
+        return 0;
+}
+
+#define COPPER_LINK_STATUS_MASK 0x8000
+static int marvell_sgmii_copper_update_link(struct phy_device *phydev)
+{
+        int status, err;
+
+        /* Read link and autonegotiation status */
+        err = marvell_switch_page(phydev,1);
+        if (err < 0)
+                return err;
+
+        status = phy_read(phydev, MII_ADVERTISE);
+
+        err = marvell_switch_page(phydev,0);
+        if (err < 0)
+                return err;
+
+        if (status < 0)
+                return status;
+
+        if ((status & COPPER_LINK_STATUS_MASK) == 0)
+                phydev->link = 0;
+        else
+                phydev->link = 1;
+
+        return 0;
+}
+
 /* marvell_read_status
  *
  * Generic status code does not detect Fiber correctly!
@@ -713,7 +771,11 @@ static int marvell_read_status(struct phy_device *phydev)
 
 	/* Update the link, but return if there
 	 * was an error */
-	err = genphy_update_link(phydev);
+#if 1
+        err = marvell_sgmii_copper_update_link(phydev);
+#else
+        err = genphy_update_link(phydev);
+#endif
 	if (err)
 		return err;
 
@@ -726,10 +788,18 @@ static int marvell_read_status(struct phy_device *phydev)
 		if (lpa < 0)
 			return lpa;
 
+		err = marvell_switch_page(phydev,1);
+                if (err < 0)
+                        return err;
+
 		adv = phy_read(phydev, MII_ADVERTISE);
 		if (adv < 0)
 			return adv;
 
+                err = marvell_switch_page(phydev,0);
+                if (err < 0)
+                        return err;
+
 		lpa &= adv;
 
 		if (status & MII_M1011_PHY_STATUS_FULLDUPLEX)
@@ -779,6 +849,11 @@ static int marvell_read_status(struct phy_device *phydev)
 		phydev->pause = phydev->asym_pause = 0;
 	}
 
+	/*Lenovo G8296 - override duplex*/
+        if (phydev->interface == PHY_INTERFACE_MODE_SGMII) {
+                phydev->duplex = DUPLEX_FULL;
+        }
+
 	return 0;
 }
 
